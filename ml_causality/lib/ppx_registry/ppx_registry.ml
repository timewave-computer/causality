(** 
 * PPX Registry for Lisp Code Generation
 *
 * This module provides a global registry for storing Lisp S-expression 
 * strings generated by the PPX transpiler. It serves as a bridge between
 * OCaml code annotated with PPX attributes and the Lisp code that implements
 * the annotated functions' behavior in the TEL system.
 * 
 * Enhanced with SSZ-based content-addressed storage for consistency with Rust.
 *)

(** Key type for the registry (typically a fully qualified OCaml function name) *)
type key = string

(** Lisp code represented as an S-expression string *)
type lisp_code = string

(** Content-addressed ID for Lisp code using SSZ + SHA256 (consistent with Rust) *)
type lisp_code_id = string

(** 
 * Map module for the registry using string keys 
 * We use a functional map instead of a hashtable for better thread safety
 *)
module StringMap = Map.Make(String)

(**
 * Generate content-addressed ID for Lisp code using SSZ + SHA256 (consistent with Rust)
 * This allows deduplication of identical code segments
 *)
let generate_lisp_code_id (code: lisp_code) : lisp_code_id =
  let normalized_code = String.trim code in
  Digestif.SHA256.to_hex (Digestif.SHA256.digest_string normalized_code)

(**
 * Content-addressed storage for Lisp code (ID -> code mapping)
 * This provides deduplication - identical code gets same ID
 *)
let code_storage = ref StringMap.empty

(**
 * Function name to code ID mapping (function -> code ID)
 * This maintains the original functionality while enabling content addressing
 *)
let function_registry = ref StringMap.empty

(**
 * Store Lisp code in content-addressed storage
 * Returns the content-addressed ID for the code
 *
 * @param code The Lisp S-expression code
 * @return Content-addressed ID for the code
 *)
let store_lisp_code (code: lisp_code) : lisp_code_id =
  let code_id = generate_lisp_code_id code in
  code_storage := StringMap.add code_id code !code_storage;
  code_id

(**
 * Retrieve Lisp code by content-addressed ID
 *
 * @param code_id Content-addressed ID
 * @return The Lisp code if found, None otherwise
 *)
let get_lisp_code_by_id (code_id: lisp_code_id) : lisp_code option =
  try Some (StringMap.find code_id !code_storage)
  with Not_found -> None

(**
 * Register Lisp code for a given OCaml function (enhanced version)
 *
 * This function is called by the PPX rewriter when it processes
 * OCaml functions annotated with attributes like [@@tel_dynamic] or
 * [@@tel_static]. It now uses content-addressed storage for deduplication.
 *
 * @param k The fully qualified OCaml function name
 * @param code The generated Lisp S-expression code
 * @return The content-addressed ID of the stored code
 *)
let register_logic (k: key) (code: lisp_code) : lisp_code_id =
  let code_id = store_lisp_code code in
  function_registry := StringMap.add k code_id !function_registry;
  code_id

(**
 * Retrieve the Lisp code associated with an OCaml function (backward compatible)
 *
 * This function is used by the DSL and effect system to get the Lisp code
 * that should be executed for a given OCaml function. It returns None if
 * no code has been registered for the given key.
 *
 * @param k The fully qualified OCaml function name
 * @return The Lisp code if found, None otherwise
 *)
let get_logic (k: key) : lisp_code option =
  try 
    let code_id = StringMap.find k !function_registry in
    get_lisp_code_by_id code_id
  with Not_found -> None

(**
 * Get the content-addressed ID for a function's Lisp code
 *
 * @param k The fully qualified OCaml function name
 * @return The content-addressed ID if found, None otherwise
 *)
let get_logic_id (k: key) : lisp_code_id option =
  try Some (StringMap.find k !function_registry)
  with Not_found -> None

(**
 * Get statistics about code deduplication
 *
 * @return (unique_functions, unique_code_segments) tuple
 *)
let get_deduplication_stats () : (int * int) =
  let unique_functions = StringMap.cardinal !function_registry in
  let unique_code_segments = StringMap.cardinal !code_storage in
  (unique_functions, unique_code_segments)

(* 
 * Example pre-population for testing - commented out for production
 *
 * let () = ignore (register_logic "Example.Module.StaticTrue" "t")
 * let () = ignore (register_logic "Example.Module.DynamicNoop" "(progn)")
 *)

(* Binary logic registry removed - SSZ functionality moved to ssz_bridge module *)
