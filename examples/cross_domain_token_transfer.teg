(define-teg cross-domain-token-transfer-example
  ;;===========================================================================
  ;; Global Lisp Definitions
  ;;===========================================================================
  (:global-lisp
    (include "capability_system.lisp")

    (defun make-transfer-message (msg-id from-acc to-acc amount token kind context-info)
      ;; Creates a standardized message map for transfers
      (make-map 
        :message-id msg-id
        :type "transfer"
        :kind kind ;; e.g., :debit-request, :credit-advice
        :sender-account from-acc
        :recipient-account to-acc
        :amount amount
        :token-type token
        :status :pending ;; initial status
        :context context-info ;; e.g., source transaction, related effect IDs
        )
    )

    (defun make-ack-message (original-msg-id status details)
      (make-map
        :message-id (generate-id "ack_msg")
        :type "acknowledgement"
        :original-message-id original-msg-id
        :ack-status status ;; :success, :failure
        :details details
      )
    )
  )

  ;;===========================================================================
  ;; Handler Definitions
  ;;===========================================================================
  (:handlers
    ;; A generic handler for dispatching based on message type within a domain
    (handler process-domain-message
      :dynamic-expr (lambda (message context)
                      (log-info (format "Processing domain message: ~a" message))
                      ;; In a real system, this would dispatch to more specific logic
                      ;; based on message.type or message.kind.
                      ;; For now, just returns the message as processed.
                      message 
                    )
    )

    ;; Handler for initiating a debit in the source domain
    (handler initiate-debit-handler
      :dynamic-expr (lambda (transfer-params context) ;; transfer-params is a map
                      (log-info (format "Initiating debit for: ~a" transfer-params))
                      ;; 1. Construct debit message for Domain B
                      (let* ((msg-id (generate-id "debit_req_msg"))
                             (debit-msg (make-transfer-message
                                          msg-id
                                          (get-field transfer-params :from-account)
                                          (get-field transfer-params :to-account)
                                          (get-field transfer-params :amount)
                                          (get-field transfer-params :token)
                                          :debit-request-CrossDomain
                                          (make-map :source-tx (get-field context :current-tx-id))))
                            )
                        ;; 2. Return the message to be sent and new state (e.g. pending debit)
                        (make-map :outgoing-message debit-msg :local-status :debit-pending)
                      )
                    )
    )

    ;; Handler for Domain B to process a debit request and prepare credit
    (handler process-debit-request-and-credit
      :dynamic-expr (lambda (debit-message context)
                      (log-info (format "Domain B processing debit request: ~a" debit-message))
                      ;; 1. Validate message (e.g., using check-message-integrity)
                      (if (not (check-message-integrity debit-message context))
                          (begin
                            (log-error "Debit message integrity check failed.")
                            (make-map :status :error :error-details "Integrity check failed" 
                                      :ack-message (make-ack-message (get-field debit-message :message-id) :failure "Integrity fail")))
                          ;; 2. If valid, prepare credit advice for Domain A & log local credit
                          (let* ((credit-advice-msg-id (generate-id "credit_adv_msg"))
                                 (credit-advice-msg (make-transfer-message
                                                      credit-advice-msg-id
                                                      (get-field debit-message :sender-account) ;; Domain A is sender of funds
                                                      (get-field debit-message :recipient-account) ;; Recipient in Domain B
                                                      (get-field debit-message :amount)
                                                      (get-field debit-message :token-type)
                                                      :credit-advice-CrossDomain ;; Advice back to A that B will credit
                                                      (make-map :original-debit-msg-id (get-field debit-message :message-id)
                                                                :domain-b-tx (get-field context :current-tx-id) )))
                                )
                            (make-map :status :processed 
                                      :local-status :credit-initiated-in-B
                                      :outgoing-message credit-advice-msg)
                          )
                      )
                    )
    )
    
    ;; Handler for Domain A to finalize debit upon receiving credit advice
     (handler finalize-debit-on-advice
      :dynamic-expr (lambda (credit-advice-message context)
                      (log-info (format "Domain A received credit advice: ~a" credit-advice-message))
                      ;; 1. Validate advice
                      (if (not (check-message-integrity credit-advice-message context)) ; simple reuse
                          (begin
                            (log-error "Credit advice integrity check failed.")
                            (make-map :status :error :error-details "Advice integrity failed"))
                          ;; 2. Finalize local debit
                          (begin
                            (log-info "Finalizing debit in Domain A.")
                            (make-map :status :debit-finalized-in-A))
                      )
                    )
    )
  )

  ;;===========================================================================
  ;; Subgraph for Domain A (Source of transfer)
  ;;===========================================================================
  (:subgraph domain-A
    :metadata (:description "Domain A - Initiates and finalizes debit for cross-domain transfer"
               :domain-id "urn:domain:A")
    :entry-nodes (initiate-transfer-in-A)
    :exit-nodes (transfer-finalized-A)

    ;; Subgraph specific checks (could use functions from capability_system.lisp)
    :static-check (lambda (subgraph-context) 
                    (log-info "Static check for Domain A subgraph passed.")
                    #t)
    :capability-check (lambda (subgraph-context) 
                        (log-info "Capability check for Domain A subgraph passed.")
                        #t)

    (:effects
      (effect initiate-transfer-in-A 
        :type "control.StartTransfer"
        ;; Properties for this specific invocation
        :properties (:from-account "account-A123" 
                     :to-account "account-B456" 
                     :amount 100 
                     :token "USD")
      )
      (effect send-debit-request-to-B
        :type "communication.SendMessage"
        ;; Static check for message sending capability
        :static-check (lambda (effect-props context) 
                        (can-send-message (get-field effect-props :message) context))
      )
      (effect await-credit-advice-from-B
        :type "control.WaitForMessage"
        :properties (:expected-message-type "credit-advice-CrossDomain")
      )
      (effect finalize-debit-in-A
        :type "ledger.FinalizeDebit"
      )
      (effect transfer-finalized-A
        :type "control.EndTransfer"
      )
    )
    (:edges
      ;; Initial transfer request uses initiate-debit-handler
      (edge start-to-send-debit
        :from initiate-transfer-in-A 
        :to send-debit-request-to-B
        :kind (handler-ref initiate-debit-handler) 
        ;; The output of the handler (a map) becomes input to send-debit-request-to-B
        ;; send-debit-request-to-B effect should know to extract :outgoing-message
      )
      (edge send-debit-to-await-advice
        :from send-debit-request-to-B
        :to await-credit-advice-from-B
        :kind (lambda (send-result context) 
                (log-info "Debit request sent. Awaiting advice.")
                send-result ; Pass through result
               )
      )
      (edge advice-to-finalize-debit
        :from await-credit-advice-from-B
        :to finalize-debit-in-A
        :kind (handler-ref finalize-debit-on-advice)
      )
      (edge finalize-debit-to-end
        :from finalize-debit-in-A
        :to transfer-finalized-A
        :kind (lambda (finalize-result context)
                (log-info "Transfer finalized in Domain A.")
                finalize-result
              )
      )
    )
  )

  ;;===========================================================================
  ;; Subgraph for Domain B (Recipient of transfer)
  ;;===========================================================================
  (:subgraph domain-B
    :metadata (:description "Domain B - Processes debit, initiates credit, sends advice"
               :domain-id "urn:domain:B")
    :entry-nodes (receive-debit-request-in-B)
    :exit-nodes (credit-completed-B)

    (:effects
      (effect receive-debit-request-in-B
        :type "communication.ReceiveMessage"
        :properties (:expected-message-type "debit-request-CrossDomain")
      )
      (effect process-debit-and-send-advice
        :type "control.ProcessAndRespond" 
        ;; Capability check for processing debit and initiating credit
        :capability-check (lambda (effect-props context)
                             (and (can-credit-account (get-field effect-props :recipient-account) 
                                                      (get-field effect-props :amount) 
                                                      (get-field effect-props :token-type) 
                                                      context)
                                  (can-send-message (get-field effect-props :message-to-send) context)
                             )
                           )
      )
      (effect finalize-credit-in-B ;; Assuming credit is finalized based on internal logic after advice sent
        :type "ledger.FinalizeCredit"
      )
      (effect credit-completed-B
        :type "control.End"
      )
    )
    (:edges
      (edge receive-debit-to-process
        :from receive-debit-request-in-B
        :to process-debit-and-send-advice
        :kind (handler-ref process-debit-request-and-credit)
        ;; The output of process-debit-request-and-credit (a map) is passed.
        ;; process-debit-and-send-advice effect should know to extract :outgoing-message for sending.
      )
       (edge process-to-finalize-credit
        :from process-debit-and-send-advice
        :to finalize-credit-in-B
        :kind (lambda (process-result context)
                (log-info "Credit processed in Domain B, advice sent. Finalizing credit.")
                ;; Use data from process-result if needed to finalize credit
                (get-field process-result :local-status) 
              )
      )
      (edge finalize-credit-to-end
        :from finalize-credit-in-B
        :to credit-completed-B
        :kind (lambda (credit-result context)
                (log-info "Credit finalized and completed in Domain B.")
                credit-result
              )
      )
    )
  )
) 