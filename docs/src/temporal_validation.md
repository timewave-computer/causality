# Temporal Validation

This document outlines the temporal validation system within the unified resource architecture, describing how operations are validated for temporal consistency and how relationships between facts are enforced.

## Core Concepts

### Temporal Validation

Temporal validation ensures that operations respect the causal ordering of events in the system by:

1. **Dependency Validation**: Ensuring required temporal facts exist and are valid
2. **Causal Ordering**: Ensuring operations respect happened-before relationships
3. **Consistency Checks**: Validating that new operations don't violate existing temporal constraints
4. **Cross-Domain Synchronization**: Validating temporal facts across domain boundaries
5. **Time Map Integration**: Ensuring operation consistency with the global time map

This validation layer is crucial for maintaining a consistent view of time across the distributed system.

### Temporal Context

```rust
/// Context for temporal validation operations
pub struct TemporalValidationContext {
    /// The operation being validated
    operation: Operation,
    
    /// The temporal facts store
    fact_store: TemporalFactStore,
    
    /// The time map for global time coordination
    time_map: TimeMap,
    
    /// Domain-specific facts by domain
    domain_facts: HashMap<DomainId, Vec<FactId>>,
    
    /// Related facts for contextual validation
    related_facts: Vec<FactId>,
    
    /// Custom validators for temporal validation
    custom_validators: Vec<Box<dyn TemporalValidator>>,
}
```

### Temporal Fact Model

The temporal validation system builds on the unified temporal fact model:

```rust
/// A fact with temporal context
pub struct TemporalFact {
    /// Unique identifier for the fact
    id: FactId,
    
    /// The actual data of the fact
    data: FactData,
    
    /// Temporal context of the fact
    temporal_context: TemporalContext,
    
    /// Provenance information about the fact
    provenance: FactProvenance,
    
    /// Facts this fact depends on
    dependencies: Vec<FactDependency>,
}

/// Temporal context for a fact
pub struct TemporalContext {
    /// When the fact was created
    created_at: Timestamp,
    
    /// The domain where the fact was created
    domain_id: DomainId,
    
    /// The trace this fact belongs to
    trace_id: Option<TraceId>,
    
    /// The logical clock value
    logical_clock: LogicalClock,
    
    /// Vector clock for cross-domain ordering
    vector_clock: VectorClock,
}
```

## Validation Components

The temporal validation system consists of several specialized components:

```rust
/// The main temporal validator
pub struct TemporalValidator {
    /// Validates fact dependencies
    dependency_validator: DependencyValidator,
    
    /// Validates causal ordering
    causal_ordering_validator: CausalOrderingValidator,
    
    /// Validates fact consistency
    consistency_validator: ConsistencyValidator,
    
    /// Validates cross-domain synchronization
    cross_domain_validator: CrossDomainValidator,
    
    /// Validates time map integration
    time_map_validator: TimeMapValidator,
    
    /// Registry of custom temporal validators
    custom_validator_registry: CustomTemporalValidatorRegistry,
    
    /// Configuration for validation
    config: TemporalValidationConfig,
}

/// Configuration for the temporal validator
pub struct TemporalValidationConfig {
    /// Whether to validate dependencies
    validate_dependencies: bool,
    
    /// Whether to validate causal ordering
    validate_causal_ordering: bool,
    
    /// Whether to validate consistency
    validate_consistency: bool,
    
    /// Whether to validate cross-domain synchronization
    validate_cross_domain: bool,
    
    /// Whether to validate time map integration
    validate_time_map: bool,
    
    /// Whether to apply custom validators
    apply_custom_validators: bool,
}
```

## Integration with Operation Model

The temporal validator integrates with the unified operation model:

1. **Operation Validation**: Validates operations for temporal consistency before execution
2. **Fact Generation**: Validates that new facts generated by operations are temporally valid
3. **Dependency Tracking**: Tracks and validates fact dependencies for operations
4. **Transaction Boundaries**: Enforces temporal constraints across transaction boundaries

## Usage Examples

### Basic Temporal Validation

```rust
// Create a temporal validator
let validator = TemporalValidator::new(
    TemporalValidationConfig::default()
        .with_validate_dependencies(true)
        .with_validate_causal_ordering(true)
        .with_validate_consistency(true)
        .with_validate_cross_domain(true)
        .with_validate_time_map(true)
);

// Create an operation to validate
let operation = Operation::new(OperationType::TransferResource)
    .with_input(source_resource.clone())
    .with_output(destination_resource.clone())
    .with_parameter("amount", 100u64)
    .with_context(ExecutionContext::new(ExecutionPhase::Planning))
    .with_authorization(Authorization::with_capabilities(
        invoker.clone(),
        vec![transfer_capability]
    ))
    .with_temporal_dependencies(vec![
        dependency_fact.id.clone(),
        context_fact.id.clone(),
    ]);

// Create a validation context
let context = TemporalValidationContext::new()
    .with_operation(operation.clone())
    .with_fact_store(fact_store.clone())
    .with_time_map(time_map.clone())
    .with_domain_facts(domain_facts.clone())
    .with_related_facts(related_facts.clone());

// Validate the operation
let validation_result = validator.validate(&context)?;

if validation_result.is_valid() {
    // Execute the operation
    let result = execute_operation(operation, &execution_context).await?;
    // Process the result
} else {
    // Handle validation failure
    println!("Temporal validation failed: {}", validation_result.error_message().unwrap());
    for issue in validation_result.issues() {
        println!("  - {}: {}", issue.severity, issue.message);
    }
}
```

### Dependency Validation

```rust
// Create a dependency validator
let dependency_validator = DependencyValidator::new(fact_store.clone());

// Validate fact dependencies for an operation
let dependencies = operation.temporal_dependencies();
let validation_result = dependency_validator.validate_dependencies(&dependencies)?;

if !validation_result.is_valid() {
    // Handle dependency validation issues
    println!("Dependency validation failed: {}", validation_result.error_message().unwrap());
    
    // Get missing dependencies
    let missing_dependencies = validation_result
        .get_value::<Vec<FactId>>("missing_dependencies")
        .unwrap_or_default();
    
    println!("Missing dependencies: {:?}", missing_dependencies);
}
```

### Causal Ordering Validation

```rust
// Create a causal ordering validator
let causal_validator = CausalOrderingValidator::new(fact_store.clone());

// Define a new fact to validate
let new_fact = TemporalFact::new(
    FactId::new(),
    FactData::new("transfer", json!({
        "source": source_resource.id(),
        "destination": destination_resource.id(),
        "amount": 100,
    })),
    TemporalContext::new(
        time::now(),
        current_domain.id(),
        Some(trace_id.clone()),
        LogicalClock::new(5),
        VectorClock::new()
    ),
    FactProvenance::new(
        operation.id(),
        invoker.id(),
    ),
    vec![
        FactDependency::new(dependency_fact.id.clone(), DependencyType::HappenedBefore),
    ]
);

// Validate causal ordering
let validation_result = causal_validator.validate_causal_ordering(&new_fact)?;

if !validation_result.is_valid() {
    // Handle causal ordering validation issues
    println!("Causal ordering validation failed: {}", validation_result.error_message().unwrap());
    
    // Get violated constraints
    let violated_constraints = validation_result
        .get_value::<Vec<(FactId, FactId)>>("violated_constraints")
        .unwrap_or_default();
    
    for (before, after) in violated_constraints {
        println!("Violation: {:?} should happen before {:?}", before, after);
    }
}
```

### Consistency Validation

```rust
// Create a consistency validator
let consistency_validator = ConsistencyValidator::new(fact_store.clone());

// Validate consistency of a new fact with existing facts
let validation_result = consistency_validator.validate_consistency(&new_fact)?;

if !validation_result.is_valid() {
    // Handle consistency validation issues
    println!("Consistency validation failed: {}", validation_result.error_message().unwrap());
    
    // Get inconsistent facts
    let inconsistent_facts = validation_result
        .get_value::<Vec<(FactId, String)>>("inconsistent_facts")
        .unwrap_or_default();
    
    for (fact_id, reason) in inconsistent_facts {
        println!("Inconsistency with fact {:?}: {}", fact_id, reason);
    }
}
```

### Cross-Domain Validation

```rust
// Create a cross-domain validator
let cross_domain_validator = CrossDomainValidator::new(
    fact_store.clone(),
    domain_registry.clone()
);

// Validate cross-domain aspects of a fact
let source_domain = Domain::new("source", DomainType::CosmWasm);
let target_domain = Domain::new("target", DomainType::EVM);

let validation_result = cross_domain_validator
    .validate_cross_domain(
        &new_fact,
        &source_domain,
        &target_domain
    )?;

if !validation_result.is_valid() {
    // Handle cross-domain validation issues
    println!("Cross-domain validation failed: {}", validation_result.error_message().unwrap());
    
    // Get synchronization issues
    let sync_issues = validation_result
        .get_value::<Vec<(DomainId, String)>>("synchronization_issues")
        .unwrap_or_default();
    
    for (domain_id, issue) in sync_issues {
        println!("Synchronization issue with domain {:?}: {}", domain_id, issue);
    }
}
```

### Time Map Validation

```rust
// Create a time map validator
let time_map_validator = TimeMapValidator::new(time_map.clone());

// Validate time map consistency for a fact
let validation_result = time_map_validator.validate_time_map(&new_fact)?;

if !validation_result.is_valid() {
    // Handle time map validation issues
    println!("Time map validation failed: {}", validation_result.error_message().unwrap());
    
    // Get time map issues
    let time_map_issues = validation_result
        .get_value::<Vec<String>>("time_map_issues")
        .unwrap_or_default();
    
    for issue in time_map_issues {
        println!("Time map issue: {}", issue);
    }
}
```

### Custom Temporal Validators

```rust
// Create a custom temporal validator
struct TokenTransferTemporalValidator;

impl TemporalValidatorTrait for TokenTransferTemporalValidator {
    fn validate(
        &self,
        fact: &TemporalFact,
        context: &TemporalValidationContext
    ) -> Result<ValidationResult> {
        // Only apply to token transfer facts
        if fact.data.fact_type() != "transfer" {
            return Ok(ValidationResult::valid());
        }
        
        // Extract data
        let data = fact.data.data();
        let amount: u64 = data.get("amount").and_then(|v| v.as_u64()).unwrap_or(0);
        
        // Example: Validate that large transfers have a longer validation delay
        if amount > 1000 {
            // Check if enough time has passed since dependency facts
            let min_delay = Duration::minutes(5);
            
            for dependency in &fact.dependencies {
                if let Some(dep_fact) = context.fact_store.get_fact(&dependency.fact_id)? {
                    let time_diff = fact.temporal_context.created_at() - 
                                   dep_fact.temporal_context.created_at();
                    
                    if time_diff < min_delay {
                        return Ok(ValidationResult::invalid(format!(
                            "Large transfers require at least {} minutes delay, but only {} elapsed",
                            min_delay.num_minutes(),
                            time_diff.num_minutes()
                        )));
                    }
                }
            }
        }
        
        Ok(ValidationResult::valid())
    }
    
    fn id(&self) -> &str {
        "token_transfer_temporal_validator"
    }
    
    fn description(&self) -> &str {
        "Validates temporal aspects of token transfers with amount-based rules"
    }
}

// Register the custom validator
validator.register_custom_validator(Box::new(TokenTransferTemporalValidator));
```

### Batch Validation

```rust
// Validate a batch of facts
let facts = vec![
    fact1.clone(),
    fact2.clone(),
    fact3.clone(),
];

// Validate the entire batch
let batch_result = validator.validate_batch(&facts, &context)?;

if batch_result.is_valid() {
    // All facts are valid
    println!("All facts are temporally valid");
} else {
    // Handle batch validation issues
    println!("Batch temporal validation failed");
    
    // Get results for individual facts
    let individual_results = batch_result.individual_results();
    for (i, result) in individual_results.iter().enumerate() {
        if !result.is_valid() {
            println!("Fact {} failed validation: {}", 
                     i, result.error_message().unwrap());
        }
    }
}
```

## Time Window Validation

The system supports validating operations within specific time windows:

```rust
// Create a time window
let time_window = TimeWindow::new(
    time::now() - Duration::hours(1),
    time::now() + Duration::minutes(5)
);

// Create a time window validator
let time_window_validator = TimeWindowValidator::new();

// Validate that a fact is within the time window
let validation_result = time_window_validator.validate_in_window(
    &new_fact,
    &time_window
)?;

if !validation_result.is_valid() {
    // Handle time window validation issues
    println!("Time window validation failed: {}", validation_result.error_message().unwrap());
    
    // Get time window details
    let out_of_window_reason = validation_result
        .get_value::<String>("out_of_window_reason")
        .unwrap_or_default();
    
    println!("Out of window reason: {}", out_of_window_reason);
}
```

## Vector Clock Validation

For distributed systems, vector clock validation ensures proper partial ordering:

```rust
// Create a vector clock validator
let vector_clock_validator = VectorClockValidator::new();

// Validate vector clocks between facts
let fact1_clock = fact1.temporal_context.vector_clock();
let fact2_clock = fact2.temporal_context.vector_clock();

let comparison = vector_clock_validator.compare_vector_clocks(
    fact1_clock,
    fact2_clock
)?;

match comparison {
    VectorClockComparison::Before => {
        println!("Fact 1 happened before Fact 2");
    },
    VectorClockComparison::After => {
        println!("Fact 1 happened after Fact 2");
    },
    VectorClockComparison::Concurrent => {
        println!("Fact 1 and Fact 2 are concurrent");
    },
}
```

## Temporal Query Validation

Operations often include temporal queries that need validation:

```rust
// Create a temporal query
let query = TemporalQuery::new()
    .with_fact_type("transfer")
    .with_time_range(
        time::now() - Duration::days(7),
        time::now()
    )
    .with_domain(domain_id.clone())
    .with_resource_id(resource_id.clone())
    .with_limit(10);

// Create a query validator
let query_validator = TemporalQueryValidator::new(fact_store.clone());

// Validate the query
let validation_result = query_validator.validate_query(&query)?;

if validation_result.is_valid() {
    // Execute the query
    let facts = fact_store.query(&query)?;
    // Process the facts
} else {
    // Handle query validation issues
    println!("Query validation failed: {}", validation_result.error_message().unwrap());
}
```

## Best Practices

1. **Validate Dependencies First**: Always validate fact dependencies before other temporal aspects.

2. **Check Causal Ordering**: Ensure all operations maintain proper causal ordering.

3. **Time Windows**: Use appropriate time windows for temporal validation based on operation sensitivity.

4. **Cross-Domain Synchronization**: Pay special attention to temporal validation in cross-domain scenarios.

5. **Vector Clocks**: Use vector clocks for distributed validation where physical time is unreliable.

6. **Batch Related Facts**: Validate related facts together for better consistency checking.

7. **Temporal Grace Periods**: Consider temporal grace periods for network delays in distributed systems.

8. **Audit Temporal Violations**: Log and audit all temporal validation failures for security monitoring.

9. **Use Time Maps**: Leverage time maps for global time coordination.

10. **Temporal Composition**: Consider the composition of temporal dependencies when validating complex operations.

## Implementation Status

The temporal validation system is fully implemented in the Causality system:

- ✅ Core `TemporalValidator` structure
- ✅ Dependency validation
- ✅ Causal ordering validation
- ✅ Consistency validation
- ✅ Cross-domain validation
- ✅ Time map validation
- ✅ Custom validators
- ✅ Batch validation
- ✅ Time window validation
- ✅ Vector clock validation

## Future Enhancements

1. **Predictive Validation**: Pre-validate likely temporal patterns
2. **Temporal Graph Analysis**: More sophisticated graph algorithms for temporal analysis
3. **Distributed Consensus**: Improved consensus mechanisms for temporal ordering
4. **Temporal Sharding**: Sharding strategies for large-scale temporal validation
5. **Machine Learning Models**: Using ML to detect temporal anomalies 