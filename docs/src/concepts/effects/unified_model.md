<!-- Unified model for effects -->
<!-- Original file: docs/src/unified_effect_model.md -->

# Unified Effect Model

This document outlines the unified effect model within the Causality architecture, describing how effects serve as abstract representations of operations that can be executed across different domains and contexts.

## Core Concepts

### Effects

An **Effect** is an abstract representation of an operation with side effects. It defines what should happen without specifying exactly how it should be implemented. Key characteristics of effects include:

1. **Abstraction**: Effects describe intent without implementation details
2. **Composability**: Effects can be composed to represent complex operations
3. **Domain-Agnostic**: Effects can be applied across different domains
4. **Side Effects**: Effects produce observable changes in system state
5. **Constraints**: Effects can have constraints that limit their application

The unified effect model provides a consistent approach to defining, validating, and executing operations across the system.

### Effect Structure

```rust
/// A trait representing an abstract effect
pub trait Effect: Send + Sync + Debug {
    /// Unique identifier for the effect
    fn id(&self) -> &EffectId;
    
    /// Display name for the effect
    fn display_name(&self) -> String;
    
    /// Description of the effect
    fn description(&self) -> String;
    
    /// Execute the effect synchronously
    fn execute(&self, context: &ExecutionContext) -> EffectResult<EffectOutcome>;
    
    /// Execute the effect asynchronously
    fn execute_async<'a>(&'a self, context: &'a ExecutionContext) 
        -> Pin<Box<dyn Future<Output = EffectResult<EffectOutcome>> + Send + 'a>>;
    
    /// Get the facts this effect depends on
    fn fact_dependencies(&self) -> Vec<FactDependency>;
    
    /// Get a snapshot of facts generated by this effect
    fn fact_snapshot(&self) -> Option<FactSnapshot>;
    
    /// Validate that fact dependencies are satisfied
    fn validate_fact_dependencies(&self, facts: &FactStore) -> Result<()>;
}

/// Outcome of an effect execution
pub struct EffectOutcome {
    /// ID of the effect that produced this outcome
    id: EffectId,
    
    /// Whether the effect executed successfully
    success: bool,
    
    /// Data produced by the effect
    data: HashMap<String, Value>,
    
    /// Error message if the effect failed
    error: Option<String>,
    
    /// ID of the execution context
    execution_id: Option<Uuid>,
    
    /// Resource changes resulting from the effect
    resource_changes: Vec<ResourceChange>,
    
    /// Additional metadata
    metadata: HashMap<String, Value>,
}

/// A unique identifier for an effect
pub struct EffectId(Uuid);
```

## Effect Categories

The system defines several categories of effects:

### Core Effects

```rust
/// An empty effect that does nothing
pub struct EmptyEffect {
    id: EffectId,
}

/// A composite effect that contains multiple sub-effects
pub struct CompositeEffect {
    id: EffectId,
    effects: Vec<Box<dyn Effect>>,
    composition_mode: CompositionMode,
}

/// A conditional effect that executes based on a condition
pub struct ConditionalEffect {
    id: EffectId,
    condition: Box<dyn Condition>,
    if_true: Box<dyn Effect>,
    if_false: Option<Box<dyn Effect>>,
}
```

### Resource Effects

```rust
/// Effect for transferring resources
pub struct TransferEffect {
    id: EffectId,
    source: ResourceId,
    destination: ResourceId,
    amount: u64,
    parameters: HashMap<String, Value>,
}

/// Effect for depositing to a resource
pub struct DepositEffect {
    id: EffectId,
    target: ResourceId,
    amount: u64,
    source_domain: Option<DomainId>,
    parameters: HashMap<String, Value>,
}

/// Effect for withdrawing from a resource
pub struct WithdrawalEffect {
    id: EffectId,
    source: ResourceId,
    amount: u64,
    target_domain: Option<DomainId>,
    parameters: HashMap<String, Value>,
}
```

### Observation Effects

```rust
/// Effect for observing resource state
pub struct ObservationEffect {
    id: EffectId,
    target: ResourceId,
    properties: Vec<String>,
    parameters: HashMap<String, Value>,
}

/// Effect for observing a fact
pub struct FactObservationEffect {
    id: EffectId,
    fact_id: FactId,
    parameters: HashMap<String, Value>,
}
```

### Domain-Specific Effects

```rust
/// Effect for EVM contract calls
pub struct EVMCallEffect {
    id: EffectId,
    contract_address: Address,
    function_signature: String,
    arguments: Vec<Value>,
    value: Option<u128>,
    gas_limit: Option<u64>,
}

/// Effect for CosmWasm contract execution
pub struct CosmWasmExecuteEffect {
    id: EffectId,
    contract_address: String,
    msg: Value,
    funds: Option<Vec<Coin>>,
}
```

### ZK Effects

```rust
/// Effect for ZK proof generation
pub struct ZKProveEffect {
    id: EffectId,
    prover_key: ProvingKey,
    public_inputs: Vec<Value>,
    private_inputs: Vec<Value>,
    parameters: HashMap<String, Value>,
}

/// Effect for ZK proof verification
pub struct ZKVerifyEffect {
    id: EffectId,
    verification_key: VerificationKey,
    proof: Proof,
    public_inputs: Vec<Value>,
    parameters: HashMap<String, Value>,
}
```

## Effect Constraints

Effects can be constrained to ensure they adhere to system rules:

```rust
/// A trait for effect constraints
pub trait EffectConstraint: Send + Sync + Debug {
    /// Check if the effect meets the constraint
    fn check_constraint(&self, effect: &dyn Effect) -> Result<bool>;
    
    /// Description of the constraint
    fn description(&self) -> String;
}

/// A constraint for transfer effects
pub struct TransferEffectConstraint {
    /// Maximum amount that can be transferred
    max_amount: Option<u64>,
    
    /// Allowed source domains
    allowed_source_domains: Option<Vec<DomainId>>,
    
    /// Allowed destination domains
    allowed_destination_domains: Option<Vec<DomainId>>,
    
    /// Custom validation function
    validator: Option<Box<dyn Fn(&TransferEffect) -> Result<bool> + Send + Sync>>,
}
```

## Effect Execution

Effects are executed through an interpreter:

```rust
/// Executes effects
pub struct Interpreter {
    /// Effect handlers
    handlers: HashMap<TypeId, Box<dyn EffectHandler>>,
    
    /// Execution context provider
    context_provider: Box<dyn ContextProvider>,
    
    /// Effect constraints
    constraints: Vec<Box<dyn EffectConstraint>>,
}

/// Handler for specific effect types
pub trait EffectHandler: Send + Sync {
    /// Check if this handler can handle the effect
    fn can_handle(&self, effect: &dyn Effect) -> bool;
    
    /// Handle the effect
    fn handle(&self, effect: &dyn Effect, context: &ExecutionContext) 
        -> EffectResult<EffectOutcome>;
    
    /// Handle the effect asynchronously
    fn handle_async<'a>(&'a self, effect: &'a dyn Effect, context: &'a ExecutionContext)
        -> Pin<Box<dyn Future<Output = EffectResult<EffectOutcome>> + Send + 'a>>;
}
```

## Integration with Operation Model

The effect model integrates with the unified operation model:

1. **Abstract Representation**: Effects serve as the abstract representation in operations
2. **Transformation**: Effects can be transformed to concrete implementations
3. **Validation**: Effects undergo validation before execution
4. **Composition**: Complex operations can be represented by composing effects
5. **Cross-Domain Execution**: Effects enable cross-domain operations

## Usage Examples

### Basic Effect Usage

```rust
// Create a transfer effect
let transfer_effect = TransferEffect::new(
    source_resource.id(),
    destination_resource.id(),
    100,
    hashmap! {
        "memo".to_string() => Value::String("Payment for services".to_string()),
    }
);

// Create an execution context
let context = ExecutionContext::new(ExecutionPhase::Execution)
    .with_environment(ExecutionEnvironment::Production)
    .with_domain(current_domain.id());

// Execute the effect
let interpreter = Interpreter::new();
let result = interpreter.execute(&transfer_effect, &context)?;

// Process the result
if result.success {
    println!("Transfer successful");
    // Access data from the result
    let new_balance = result.data.get("new_balance")
        .and_then(|v| v.as_u64())
        .unwrap_or(0);
    
    println!("New balance: {}", new_balance);
} else {
    println!("Transfer failed: {}", result.error.unwrap_or_default());
}
```

### Composite Effects

```rust
// Create individual effects
let observe_effect = ObservationEffect::new(
    source_resource.id(),
    vec!["balance".to_string()],
    HashMap::new()
);

let transfer_effect = TransferEffect::new(
    source_resource.id(),
    destination_resource.id(),
    100,
    HashMap::new()
);

let deposit_effect = DepositEffect::new(
    destination_resource.id(),
    50,
    None,
    HashMap::new()
);

// Compose them together
let composite_effect = CompositeEffect::new(
    vec![
        Box::new(observe_effect),
        Box::new(transfer_effect),
        Box::new(deposit_effect),
    ],
    CompositionMode::Sequential
);

// Execute the composite effect
let result = interpreter.execute(&composite_effect, &context)?;
```

### Conditional Effects

```rust
// Create a condition
let balance_condition = BalanceCondition::new(
    source_resource.id(),
    150,
    ComparisonOperator::GreaterThanOrEqual
);

// Create effects for true and false cases
let transfer_effect = TransferEffect::new(
    source_resource.id(),
    destination_resource.id(),
    100,
    HashMap::new()
);

let insufficient_funds_effect = ErrorEffect::new(
    "Insufficient funds for transfer".to_string()
);

// Create a conditional effect
let conditional_effect = ConditionalEffect::new(
    Box::new(balance_condition),
    Box::new(transfer_effect),
    Some(Box::new(insufficient_funds_effect))
);

// Execute the conditional effect
let result = interpreter.execute(&conditional_effect, &context)?;
```

### Domain-Specific Effects

```rust
// Create an EVM call effect
let evm_effect = EVMCallEffect::new(
    Address::from_str("0x1234567890123456789012345678901234567890").unwrap(),
    "transfer(address,uint256)".to_string(),
    vec![
        Value::String("0x9876543210987654321098765432109876543210".to_string()),
        Value::Number(100.into()),
    ],
    Some(0),
    Some(100000)
);

// Create a domain-specific context
let evm_context = ExecutionContext::new(ExecutionPhase::Execution)
    .with_environment(ExecutionEnvironment::Production)
    .with_domain(evm_domain.id());

// Execute the EVM effect
let result = interpreter.execute(&evm_effect, &evm_context)?;
```

### ZK Effects

```rust
// Create a ZK prove effect
let zk_prove_effect = ZKProveEffect::new(
    prover_key,
    vec![Value::Number(10.into())], // Public inputs
    vec![
        Value::Number(5.into()),
        Value::Number(2.into()),
    ], // Private inputs (e.g., 5 * 2 = 10)
    HashMap::new()
);

// Execute the ZK prove effect
let prove_result = interpreter.execute(&zk_prove_effect, &context)?;

// Get the proof from the result
let proof = prove_result.data.get("proof")
    .and_then(|v| v.as_str())
    .unwrap_or("");

// Create a ZK verify effect
let zk_verify_effect = ZKVerifyEffect::new(
    verification_key,
    Proof::from_str(proof).unwrap(),
    vec![Value::Number(10.into())], // Public inputs
    HashMap::new()
);

// Execute the ZK verify effect
let verify_result = interpreter.execute(&zk_verify_effect, &context)?;

// Check if verification succeeded
if verify_result.success {
    println!("ZK proof verified successfully");
} else {
    println!("ZK proof verification failed");
}
```

### Effect Templates

Effect templates provide reusable patterns for creating effects:

```rust
// Create a transfer template
let transfer_template = TransferTemplate::new();

// Use the template to create an effect
let transfer_effect = transfer_template.create_effect(
    source_resource.id(),
    destination_resource.id(),
    100,
    Some("Payment for services".to_string()),
    None
)?;

// Execute the effect
let result = interpreter.execute(&transfer_effect, &context)?;
```

### Custom Effects

Custom effects can be created for domain-specific needs:

```rust
// Define a custom effect
struct CustomTokenMintEffect {
    id: EffectId,
    token_id: ResourceId,
    amount: u64,
    recipient: ResourceId,
    metadata: HashMap<String, Value>,
}

impl Effect for CustomTokenMintEffect {
    fn id(&self) -> &EffectId {
        &self.id
    }
    
    fn display_name(&self) -> String {
        "Custom Token Mint Effect".to_string()
    }
    
    fn description(&self) -> String {
        format!("Mints {} tokens to recipient", self.amount)
    }
    
    fn execute(&self, context: &ExecutionContext) -> EffectResult<EffectOutcome> {
        // Implementation of token minting logic
        
        // Return a successful outcome
        Ok(EffectOutcome::success(
            self.id.clone(),
            hashmap! {
                "amount".to_string() => Value::Number(self.amount.into()),
                "recipient".to_string() => Value::String(self.recipient.to_string()),
            },
            vec![
                ResourceChange::new(
                    self.token_id.clone(),
                    ChangeType::Update,
                    hashmap! {
                        "total_supply".to_string() => Value::String(
                            format!("increased by {}", self.amount)
                        ),
                    }
                ),
                ResourceChange::new(
                    self.recipient.clone(),
                    ChangeType::Update,
                    hashmap! {
                        "balance".to_string() => Value::String(
                            format!("increased by {}", self.amount)
                        ),
                    }
                ),
            ],
            hashmap! {
                "token_type".to_string() => Value::String("Custom".to_string()),
            }
        ))
    }
    
    // Implement other required methods
}
```

## Effect Fact Integration

Effects integrate with the fact system to maintain temporal relationships:

```rust
// Implement fact-related methods for a transfer effect
impl Effect for TransferEffect {
    // ... other implementations
    
    fn fact_dependencies(&self) -> Vec<FactDependency> {
        vec![
            // Depend on the latest state of the source resource
            FactDependency::new(
                FactId::for_resource(self.source.clone()),
                DependencyType::HappenedBefore
            ),
            // Depend on the latest state of the destination resource
            FactDependency::new(
                FactId::for_resource(self.destination.clone()),
                DependencyType::HappenedBefore
            ),
        ]
    }
    
    fn fact_snapshot(&self) -> Option<FactSnapshot> {
        Some(FactSnapshot::new(
            FactId::new(),
            "transfer".to_string(),
            json!({
                "source": self.source.to_string(),
                "destination": self.destination.to_string(),
                "amount": self.amount,
            }),
            vec![
                // This fact happens after the source resource's latest state
                FactDependency::new(
                    FactId::for_resource(self.source.clone()),
                    DependencyType::HappenedAfter
                ),
                // This fact happens after the destination resource's latest state
                FactDependency::new(
                    FactId::for_resource(self.destination.clone()),
                    DependencyType::HappenedAfter
                ),
            ]
        ))
    }
    
    fn validate_fact_dependencies(&self, facts: &FactStore) -> Result<()> {
        // Check if all dependencies exist
        for dependency in self.fact_dependencies() {
            if !facts.fact_exists(&dependency.fact_id())? {
                return Err(Error::missing_fact_dependency(
                    dependency.fact_id(),
                    self.id()
                ));
            }
        }
        
        // Additional validation logic for dependencies
        
        Ok(())
    }
}
```

## Validation Integration

Effects are validated before execution:

```rust
// Create a validator for effects
let validator = EffectValidator::new();

// Add constraints
validator.add_constraint(Box::new(TransferEffectConstraint::new()
    .with_max_amount(1000)
    .with_allowed_destination_domains(vec![
        destination_domain.id().clone()
    ])
));

// Validate an effect
let validation_result = validator.validate(&transfer_effect)?;

if validation_result.is_valid() {
    // Effect is valid, proceed with execution
    let result = interpreter.execute(&transfer_effect, &context)?;
    // Process result
} else {
    // Handle validation failure
    println!("Validation failed: {}", validation_result.error_message().unwrap());
}
```

## Operation Model Integration

Effects integrate with the unified operation model:

```rust
// Create an abstract operation with an effect
let operation = Operation::new(OperationType::TransferResource)
    .with_input(source_resource.clone())
    .with_output(destination_resource.clone())
    .with_abstract_representation(Box::new(transfer_effect.clone()))
    .with_context(ExecutionContext::new(ExecutionPhase::Planning))
    .with_authorization(Authorization::with_capabilities(
        invoker.clone(),
        vec![transfer_capability]
    ));

// Transform the abstract operation to a concrete implementation
let transformation_service = OperationTransformationService::new();
let concrete_operation = transformation_service.transform_to_concrete(&operation)?;

// Execute the operation
let execution_service = OperationExecutionService::new();
let execution_result = execution_service.execute(&operation)?;
```

## Cross-Domain Effects

Effects can span multiple domains:

```rust
// Create a cross-domain transfer effect
let cross_domain_effect = CrossDomainTransferEffect::new(
    source_resource.id(),
    destination_domain.id(),
    recipient_address.to_string(),
    100,
    hashmap! {
        "memo".to_string() => Value::String("Cross-domain payment".to_string()),
    }
);

// Create a cross-domain execution context
let cross_domain_context = ExecutionContext::new(ExecutionPhase::Execution)
    .with_environment(ExecutionEnvironment::Production)
    .with_domain(source_domain.id())
    .with_metadata("target_domain", destination_domain.id().to_string());

// Execute the cross-domain effect
let result = interpreter.execute(&cross_domain_effect, &cross_domain_context)?;

// Process the result
if result.success {
    println!("Cross-domain transfer initiated");
    // Get the proof for the receiving chain
    let proof = result.data.get("proof")
        .and_then(|v| v.as_str())
        .unwrap_or("");
    
    println!("Proof for receiving chain: {}", proof);
} else {
    println!("Cross-domain transfer failed: {}", result.error.unwrap_or_default());
}
```

## Best Practices

1. **Abstraction Level**: Keep effects at an appropriate level of abstraction.

2. **Composability**: Design effects to be composable for complex operations.

3. **Idempotency**: When possible, design effects to be idempotent.

4. **Validation First**: Always validate effects before execution.

5. **Constraints**: Apply appropriate constraints to effects.

6. **Fact Integration**: Properly integrate effects with the fact system.

7. **Error Handling**: Provide clear error messages for effect failures.

8. **Domain Specificity**: Create domain-specific effects for specialized operations.

9. **Template Usage**: Use effect templates for common patterns.

10. **Context Awareness**: Design effects to be context-aware.

## Implementation Status

The unified effect model is fully implemented in the Causality system:

- ✅ Core `Effect` trait and base implementations
- ✅ Effect categories (Resource, Observation, Domain-specific, ZK)
- ✅ Effect constraints system
- ✅ Effect execution through the Interpreter
- ✅ Fact system integration
- ✅ Validation system
- ✅ Operation model integration
- ✅ Cross-domain effects
- ✅ Effect templates

## Future Enhancements

1. **Effect Versioning**: Support for versioned effects
2. **Effect Analytics**: Telemetry and analytics for effect execution
3. **Effect DSL**: Domain-specific language for defining effects
4. **Effect Optimization**: Performance optimizations for high-throughput scenarios
5. **Advanced Composition**: More sophisticated effect composition patterns 