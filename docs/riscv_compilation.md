# ZK-VM Integration for Causality Effects

This document describes the approach for executing Causality effects in established zero-knowledge virtual machines like Risc0 and Succinct.

## Overview

The Causality system uses algebraic effects to represent cross-domain operations. To execute these effects in a zero-knowledge proof system, we leverage established ZK-VMs like Risc0 and Succinct with the following approach:

1. Using our existing domain and effect adapters to generate Rust code targeting ZK-VM guest environments
2. Executing the generated code within the ZK-VM to produce proofs
3. Verifying these proofs on target blockchains through domain-specific verification contracts

## ZK-VM Integration Architecture

Rather than maintaining a custom RISC-V compiler, we utilize production-ready ZK-VMs with the following components:

1. **Domain Adapter Extensions**: Enhancing our existing domain adapters to target ZK-VM environments
2. **Code Generation**: Creating Rust code that can be executed in ZK-VM guest environments
3. **Effect Handling**: Implementing effects within the guest/host boundary of ZK-VMs
4. **Proof Management**: Generating and verifying proofs across multiple domains

### Supported ZK-VMs

- **Risc0**: A RISC-V based ZK-VM with strong tooling and performance characteristics
- **Succinct**: A high-performance ZK-VM with advanced proving technology
- **Extensible Backend**: The architecture supports adding additional ZK-VM backends as needed

## Domain Adapter to ZK-VM Mapping

Each domain adapter now includes ZK-VM targets that:

1. Generate guest code for the ZK-VM environment
2. Create host-side code for proof generation
3. Produce verification contracts for target blockchains

### Code Generation Process

```
Domain Effect Schema → Domain Adapter → ZK-VM Code Generator → Rust Guest Code
                                                             → Host Handler Code
                                                             → Verification Contract
```

## Effect Implementation in ZK-VM Environment

Effects are implemented as Rust functions that:

1. Accept effect parameters as inputs
2. Execute the effect logic within the ZK-VM guest environment
3. Produce outputs that can be verified on-chain

### Guest/Host Communication

For effects that require external data:

1. The guest code makes requests through a standardized guest/host interface
2. The host provides the necessary data as committed inputs
3. The guest validates and processes the inputs to maintain proof integrity

### Example: Deposit Effect in Risc0

```rust
// Guest code generated for a deposit effect
#[method]
pub fn deposit(
    account_id: AccountId,
    amount: Amount,
    timestamp: Timestamp,
) -> Result<Receipt, Error> {
    // Effect implementation
    let mut account = get_account(account_id)?;
    account.balance += amount;
    
    // Create receipt that can be verified on-chain
    let receipt = Receipt::new(
        account_id,
        Operation::Deposit,
        amount,
        account.balance,
        timestamp,
    );
    
    commit_account_state(account)?;
    Ok(receipt)
}
```

## Register Operations via ZK-VM

Register operations are implemented as specialized ZK-VM programs that:

1. Load register state from committed inputs
2. Perform register operations with appropriate validation
3. Produce proofs of valid register state transitions

### Register State Representation

```rust
// Register state representation for ZK-VM
struct Register {
    id: RegisterId,
    value: Vec<u8>,
    version: u64,
    owner: PublicKey,
    nullifier: Option<Nullifier>,
}

// Register operation
enum RegisterOp {
    Create,
    Update,
    Transfer,
    Delete,
}
```

## Cross-Domain Proof Propagation

Proofs generated by ZK-VMs are propagated across domains through:

1. Serialization of proofs into a standard format
2. Domain-specific verification contracts
3. Cross-chain messaging protocols

### Verification Contract Example (Ethereum)

```solidity
// Simplified verification contract for Ethereum
contract CausalityVerifier {
    // Verify a Risc0 proof
    function verifyRisc0Proof(
        bytes32 methodId,
        bytes32 stateRoot,
        bytes calldata proof
    ) public view returns (bool) {
        // Verification logic
        return Risc0Verifier.verify(methodId, stateRoot, proof);
    }
    
    // Process a verified register operation
    function processRegisterOperation(
        RegisterOp op,
        bytes32 registerId,
        bytes32 stateRoot,
        bytes calldata proof
    ) public {
        require(verifyRisc0Proof(REGISTER_METHOD_ID, stateRoot, proof), "Invalid proof");
        // Process the verified operation
        // ...
    }
}
```

## Unified Interface for ZK-VM Backends

A unified interface allows seamless switching between ZK-VM backends:

```rust
// Unified ZK-VM interface
trait ZkVmBackend {
    // Generate a proof for the given program and inputs
    fn generate_proof(
        program: &ZkProgram,
        inputs: &[u8],
    ) -> Result<ZkProof, Error>;
    
    // Verify a proof
    fn verify_proof(
        program_id: &ProgramId,
        public_inputs: &[u8],
        proof: &ZkProof,
    ) -> Result<bool, Error>;
    
    // Get estimated proving time and memory requirements
    fn estimate_resources(
        program: &ZkProgram,
    ) -> Result<ResourceEstimate, Error>;
}

// Concrete implementations
struct Risc0Backend;
struct SuccinctBackend;

impl ZkVmBackend for Risc0Backend {
    // Implementation for Risc0
}

impl ZkVmBackend for SuccinctBackend {
    // Implementation for Succinct
}
```

## Migration Path from Custom RISC-V

For projects using the previous custom RISC-V compiler:

1. Generate equivalent Rust code that matches the behavior of the RISC-V program
2. Execute the Rust code in the chosen ZK-VM
3. Update on-chain verification to use the new proof format

## Conclusion

By leveraging established ZK-VMs like Risc0 and Succinct, we maintain the power of our domain and effect adapter architecture while benefiting from industry-standard ZK proving technology. This approach:

1. Reduces the maintenance burden of a custom RISC-V compiler
2. Improves proving performance and reliability
3. Provides flexibility to choose the optimal ZK-VM for different workloads
4. Maintains compatibility with our existing domain adapter architecture

The key insight is that domain adapters remain the primary integration point, but now target ZK-VM environments for proof generation rather than generating custom RISC-V bytecode. 