//! RISC-V Templates for Code Generation
//!
//! This module provides templates for generating RISC-V code.

/// Basic RISC-V program template
pub const BASIC_PROGRAM_TEMPLATE: &str = r#"# RISC-V Program: {{PROGRAM_NAME}}
# Generated by Causality Effect Adapter System
#
# Entry point: {{ENTRY_POINT}}

.section .text
.globl {{ENTRY_POINT}}
{{ENTRY_POINT}}:
    {{INSTRUCTIONS}}

.section .data
    {{DATA}}
"#;

/// Operation template for RISC-V
pub const OPERATION_TEMPLATE: &str = r#"# Operation: {{OPERATION_NAME}}
# Description: {{OPERATION_DESCRIPTION}}

.globl op_{{OPERATION_NAME}}
op_{{OPERATION_NAME}}:
    # Prologue
    addi sp, sp, -16
    sw ra, 12(sp)
    sw fp, 8(sp)
    addi fp, sp, 16
    
    # Operation logic
    {{OPERATION_LOGIC}}
    
    # Epilogue
    lw ra, 12(sp)
    lw fp, 8(sp)
    addi sp, sp, 16
    ret
"#;

/// Test template for RISC-V
pub const TEST_TEMPLATE: &str = r#"# Test for: {{OPERATION_NAME}}
# Generated by Causality Effect Adapter System

.section .text
.globl test_{{OPERATION_NAME}}
test_{{OPERATION_NAME}}:
    # Test setup
    addi sp, sp, -16
    sw ra, 12(sp)
    
    # Call operation under test
    jal ra, op_{{OPERATION_NAME}}
    
    # Verify result
    {{TEST_VERIFICATION}}
    
    # Test cleanup
    lw ra, 12(sp)
    addi sp, sp, 16
    ret
"#;

/// Documentation template for RISC-V
pub const DOC_TEMPLATE: &str = r#"# RISC-V Documentation for {{ADAPTER_NAME}}

## Overview
This RISC-V implementation of the {{ADAPTER_NAME}} provides zero-knowledge proof
compatible operations for the {{DOMAIN_ID}} domain.

## Operations
{{OPERATIONS_LIST}}

## Memory Layout
The program follows this memory layout:
- 0x0000 - 0x1000: Program code
- 0x1000 - 0x8000: Stack region
- 0x8000 - 0xFFFF: Heap region

## Usage
This code is designed to be compiled with RISC-V toolchains and run on
zero-knowledge virtual machines that support the RV32I instruction set.
"#;

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    use crate::effect_adapters::codegen::templates::apply_template;
    
    #[test]
    fn test_basic_program_template() {
        let mut vars = HashMap::new();
        vars.insert("PROGRAM_NAME".to_string(), "TestProgram".to_string());
        vars.insert("ENTRY_POINT".to_string(), "main".to_string());
        vars.insert("INSTRUCTIONS".to_string(), "    nop\n    ret".to_string());
        vars.insert("DATA".to_string(), ".word 0x12345678".to_string());
        
        let result = apply_template(BASIC_PROGRAM_TEMPLATE, &vars).unwrap();
        
        assert!(result.contains("TestProgram"));
        assert!(result.contains("main"));
        assert!(result.contains("nop"));
        assert!(result.contains(".word 0x12345678"));
    }
} 