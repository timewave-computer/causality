crates/causality-effects/tests/basic/mod.rs:/// A basic transfer effect for testing
crates/causality-effects/tests/basic/mod.rs-pub struct TestTransferEffect {
--
crates/causality-effects/tests/basic/mod.rs-    domain_id: DomainId,
crates/causality-effects/tests/basic/mod.rs-}
crates/causality-effects/tests/basic/mod.rs-
crates/causality-effects/tests/basic/mod.rs-impl TestTransferEffect {
crates/causality-effects/tests/basic/mod.rs:    /// Create a new test transfer effect
crates/causality-effects/tests/basic/mod.rs-    pub fn new(
--
crates/causality-effects/tests/basic/mod.rs-        destination: Address,
crates/causality-effects/tests/basic/mod.rs-        resource_id: ContentId,
crates/causality-effects/tests/basic/mod.rs-        amount: u128,
--
crates/causality-effects/tests/basic/mod.rs:/// A basic storage effect for testing
crates/causality-effects/tests/basic/mod.rs-pub struct TestStorageEffect {
--
crates/causality-effects/tests/basic/mod.rs-    data: HashMap<String, serde_json::Value>,
crates/causality-effects/tests/basic/mod.rs-}
crates/causality-effects/tests/basic/mod.rs-
crates/causality-effects/tests/basic/mod.rs-impl TestStorageEffect {
crates/causality-effects/tests/basic/mod.rs:    /// Create a new test storage effect
crates/causality-effects/tests/basic/mod.rs-    pub fn new(
--
crates/causality-effects/tests/basic/mod.rs-        domain_id: DomainId,
crates/causality-effects/tests/basic/mod.rs-        fields: HashSet<String>,
crates/causality-effects/tests/basic/mod.rs-        visibility: StorageVisibility,
--
crates/causality-effects/tests/basic/mod.rs:/// A basic query effect for testing
crates/causality-effects/tests/basic/mod.rs-pub struct TestQueryEffect {
--
crates/causality-effects/tests/basic/mod.rs-    query_params: HashMap<String, serde_json::Value>,
crates/causality-effects/tests/basic/mod.rs-}
crates/causality-effects/tests/basic/mod.rs-
crates/causality-effects/tests/basic/mod.rs-impl TestQueryEffect {
crates/causality-effects/tests/basic/mod.rs:    /// Create a new test query effect
crates/causality-effects/tests/basic/mod.rs-    pub fn new(
--
crates/causality-effects/tests/basic/mod.rs-    ) -> Self {
--
crates/causality-effects/src/three_layer.rs:/// Core trait representing an algebraic effect in the system
crates/causality-effects/src/three_layer.rs:/// This is the base trait for all effects in the architecture
crates/causality-effects/src/three_layer.rs-#[async_trait]
crates/causality-effects/src/three_layer.rs-pub trait AlgebraicEffect: Send + Sync {
--
crates/causality-effects/src/three_layer.rs-    fn tel_hints(&self) -> Option<TelHints>;
crates/causality-effects/src/three_layer.rs-}
crates/causality-effects/src/three_layer.rs-
crates/causality-effects/src/three_layer.rs:/// Hints for TEL code generation/execution
crates/causality-effects/src/three_layer.rs-#[derive(Clone, Debug, Serialize, Deserialize)]
crates/causality-effects/src/three_layer.rs-pub struct TelHints {
crates/causality-effects/src/three_layer.rs:    /// Target domain type
crates/causality-effects/src/three_layer.rs-    pub domain_type: String,
crates/causality-effects/src/three_layer.rs-    
crates/causality-effects/src/three_layer.rs:    /// Function name pattern in TEL
crates/causality-effects/src/three_layer.rs-    pub function_pattern: String,
crates/causality-effects/src/three_layer.rs-    
crates/causality-effects/src/three_layer.rs:    /// Parameter mapping hints
crates/causality-effects/src/three_layer.rs-    pub parameter_mappings: HashMap<String, String>,
crates/causality-effects/src/three_layer.rs-    
crates/causality-effects/src/three_layer.rs:    /// Required imports/includes for TEL
crates/causality-effects/src/three_layer.rs-    pub required_imports: Vec<String>,
crates/causality-effects/src/three_layer.rs-    
crates/causality-effects/src/three_layer.rs:    /// Additional metadata for code generation
crates/causality-effects/src/three_layer.rs-    pub metadata: HashMap<String, String>,
--
crates/causality-effects/src/three_layer.rs-//
crates/causality-effects/src/three_layer.rs-// Layer 2: Effect Constraints Layer
--
crates/causality-effects/src/three_layer.rs:/// A trait for effects that transfer resources between addresses
crates/causality-effects/src/three_layer.rs-#[async_trait]
crates/causality-effects/src/three_layer.rs-pub trait TransferEffect: AlgebraicEffect {
--
crates/causality-effects/src/three_layer.rs-    async fn validate_transfer(&self, context: &EffectContext) -> EffectResult<()>;
crates/causality-effects/src/three_layer.rs-}
crates/causality-effects/src/three_layer.rs-
crates/causality-effects/src/three_layer.rs:/// A trait for effects that deposit resources to an address
crates/causality-effects/src/three_layer.rs-#[async_trait]
crates/causality-effects/src/three_layer.rs-pub trait DepositEffect: AlgebraicEffect {
--
crates/causality-effects/src/three_layer.rs-    async fn validate_deposit(&self, context: &EffectContext) -> EffectResult<()>;
crates/causality-effects/src/three_layer.rs-}
crates/causality-effects/src/three_layer.rs-
crates/causality-effects/src/three_layer.rs:/// A trait for effects that withdraw resources from an address
crates/causality-effects/src/three_layer.rs-#[async_trait]
crates/causality-effects/src/three_layer.rs-pub trait WithdrawEffect: AlgebraicEffect {
--
crates/causality-effects/src/three_layer.rs-    async fn validate_withdrawal(&self, context: &EffectContext) -> EffectResult<()>;
crates/causality-effects/src/three_layer.rs-}
crates/causality-effects/src/three_layer.rs-
crates/causality-effects/src/three_layer.rs:/// A trait for effects that store data on-chain
crates/causality-effects/src/three_layer.rs-#[async_trait]
crates/causality-effects/src/three_layer.rs-pub trait StorageEffect: AlgebraicEffect {
--
crates/causality-effects/src/three_layer.rs-    async fn validate_storage(&self, context: &EffectContext) -> EffectResult<()>;
crates/causality-effects/src/three_layer.rs-}
crates/causality-effects/src/three_layer.rs-
crates/causality-effects/src/three_layer.rs:/// A trait for effects that query on-chain data
crates/causality-effects/src/three_layer.rs-#[async_trait]
crates/causality-effects/src/three_layer.rs-pub trait QueryEffect: AlgebraicEffect {
--
crates/causality-effects/src/three_layer.rs-    async fn validate_query(&self, context: &EffectContext) -> EffectResult<()>;
crates/causality-effects/src/three_layer.rs-}
crates/causality-effects/src/three_layer.rs-
crates/causality-effects/src/three_layer.rs:/// Visibility options for storage effects
crates/causality-effects/src/three_layer.rs-#[derive(Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize)]
crates/causality-effects/src/three_layer.rs-pub enum StorageVisibility {
--
crates/causality-effects/src/three_layer.rs-
crates/causality-effects/src/three_layer.rs-//
crates/causality-effects/src/three_layer.rs-// Layer 3: Domain Implementation Layer
--
crates/causality-effects/src/three_layer.rs:/// A runtime for executing effects with domain-specific implementations
crates/causality-effects/src/three_layer.rs-pub struct EffectRuntime {
--
crates/causality-effects/src/three_layer.rs-    fallback_handlers: HashMap<&'static str, Arc<dyn FallbackHandler>>,
crates/causality-effects/src/three_layer.rs-}
crates/causality-effects/src/three_layer.rs-
crates/causality-effects/src/three_layer.rs-impl EffectRuntime {
crates/causality-effects/src/three_layer.rs:    /// Create a new effect runtime
crates/causality-effects/src/three_layer.rs-    pub fn new(
--
crates/causality-effects/src/three_layer.rs-    ) -> Self {
crates/causality-effects/src/three_layer.rs-        Self {
crates/causality-effects/src/three_layer.rs-            domain_adapters: HashMap::new(),
--
crates/causality-effects/src/three_layer.rs:    /// Register a domain adapter
crates/causality-effects/src/three_layer.rs-    pub fn register_domain_adapter(&mut self, domain_id: DomainId, adapter: Arc<dyn DomainAdapter>) {
crates/causality-effects/src/three_layer.rs-        self.domain_adapters.insert(domain_id, adapter);
crates/causality-effects/src/three_layer.rs-    }
crates/causality-effects/src/three_layer.rs-    
crates/causality-effects/src/three_layer.rs:    /// Register a fallback handler for an effect type
crates/causality-effects/src/three_layer.rs-    pub fn register_fallback_handler(&mut self, effect_type: &'static str, handler: Arc<dyn FallbackHandler>) {
crates/causality-effects/src/three_layer.rs-        self.fallback_handlers.insert(effect_type, handler);
crates/causality-effects/src/three_layer.rs-    }
crates/causality-effects/src/three_layer.rs-    
crates/causality-effects/src/three_layer.rs:    /// Execute an effect
crates/causality-effects/src/three_layer.rs-    pub async fn execute_effect(&self, effect: Arc<dyn AlgebraicEffect>, context: EffectContext) 
--
crates/causality-effects/src/three_layer.rs-        context: EffectContext,
crates/causality-effects/src/three_layer.rs-        hints: TelHints,
--
crates/causality-effects/src/three_layer.rs:/// Adapter for executing effects on a specific domain
crates/causality-effects/src/three_layer.rs-#[async_trait]
crates/causality-effects/src/three_layer.rs-pub trait DomainAdapter: Send + Sync {
--
crates/causality-effects/src/three_layer.rs-    async fn can_execute(&self, effect: Arc<dyn AlgebraicEffect>) -> bool;
crates/causality-effects/src/three_layer.rs-}
crates/causality-effects/src/three_layer.rs-
crates/causality-effects/src/three_layer.rs:/// Fallback handler for effects without domain-specific implementations
crates/causality-effects/src/three_layer.rs-#[async_trait]
crates/causality-effects/src/three_layer.rs-pub trait FallbackHandler: Send + Sync {
--
crates/causality-effects/src/three_layer.rs-        -> EffectResult<EffectOutcome>;
crates/causality-effects/src/three_layer.rs-}
crates/causality-effects/src/three_layer.rs-
crates/causality-effects/src/three_layer.rs:/// Compiler for generating TEL code from effects
crates/causality-effects/src/three_layer.rs-#[async_trait]
crates/causality-effects/src/three_layer.rs-pub trait TelCompiler: Send + Sync {
--
crates/causality-effects/src/three_layer.rs:    /// Check if an effect can be compiled to TEL
crates/causality-effects/src/three_layer.rs-    fn can_compile(&self, effect: Arc<dyn AlgebraicEffect>) -> bool;
crates/causality-effects/src/three_layer.rs-}
crates/causality-effects/src/three_layer.rs-
crates/causality-effects/src/three_layer.rs:/// A simple in-memory TEL compiler
crates/causality-effects/src/three_layer.rs-pub struct SimpleTelCompiler;
crates/causality-effects/src/three_layer.rs-
crates/causality-effects/src/three_layer.rs-impl SimpleTelCompiler {
crates/causality-effects/src/three_layer.rs:    /// Create a new simple TEL compiler
crates/causality-effects/src/three_layer.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/three_layer.rs-}
crates/causality-effects/src/three_layer.rs-
--
crates/causality-effects/src/random.rs:/// Types of random number generation
crates/causality-effects/src/random.rs-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
crates/causality-effects/src/random.rs-pub enum RandomType {
--
crates/causality-effects/src/random.rs-impl fmt::Display for RandomType {
crates/causality-effects/src/random.rs-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
--
crates/causality-effects/src/random.rs:/// Effect for generating random values
crates/causality-effects/src/random.rs-#[async_trait]
crates/causality-effects/src/random.rs-pub trait RandomEffect: Send + Sync + std::fmt::Debug {
--
crates/causality-effects/src/random.rs-    async fn fill_bytes(&self, context: &EffectContext, buffer: &mut [u8]) -> EffectResult<()>;
crates/causality-effects/src/random.rs-}
crates/causality-effects/src/random.rs-
crates/causality-effects/src/random.rs:/// Standard random effect implementation using the rand crate
crates/causality-effects/src/random.rs-#[derive(Debug, BorshSerialize, BorshDeserialize)]
crates/causality-effects/src/random.rs-pub struct StandardRandomEffect {
crates/causality-effects/src/random.rs-    id: EffectId,
crates/causality-effects/src/random.rs-    seed: Option<u64>,
crates/causality-effects/src/random.rs-}
--
crates/causality-effects/src/random.rs:    /// Create a new standard random effect
crates/causality-effects/src/random.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/random.rs-            id: EffectId::new(""), // Temporary placeholder
crates/causality-effects/src/random.rs-            seed: None,
crates/causality-effects/src/random.rs-        };
--
crates/causality-effects/src/random.rs:    /// Create a standard random effect with a seed for deterministic behavior
crates/causality-effects/src/random.rs-    pub fn with_seed(seed: u64) -> Self {
--
crates/causality-effects/src/random.rs-            seed: Some(seed),
crates/causality-effects/src/random.rs-        };
--
crates/causality-effects/src/random.rs:/// Cryptographically secure random effect implementation
crates/causality-effects/src/random.rs-#[derive(Debug, BorshSerialize, BorshDeserialize)]
crates/causality-effects/src/random.rs-pub struct SecureRandomEffect {
crates/causality-effects/src/random.rs-    id: EffectId,
crates/causality-effects/src/random.rs-}
crates/causality-effects/src/random.rs-
--
crates/causality-effects/src/random.rs:    /// Create a new cryptographically secure random effect
crates/causality-effects/src/random.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/random.rs-            id: EffectId::new(""), // Temporary placeholder
crates/causality-effects/src/random.rs-        };
crates/causality-effects/src/random.rs-        
--
crates/causality-effects/src/random.rs:/// Factory for creating random effects
crates/causality-effects/src/random.rs-pub struct RandomEffectFactory;
crates/causality-effects/src/random.rs-
crates/causality-effects/src/random.rs-impl RandomEffectFactory {
crates/causality-effects/src/random.rs:    /// Create a random effect of the specified type
crates/causality-effects/src/random.rs-    pub fn create_effect(random_type: RandomType) -> Box<dyn RandomEffect> {
--
crates/causality-effects/src/random.rs-            RandomType::CryptographicSecure => Box::new(SecureRandomEffect::new()),
crates/causality-effects/src/random.rs-            RandomType::Deterministic => Box::new(StandardRandomEffect::with_seed(42)), // Fixed seed for deterministic behavior
--
crates/causality-effects/src/types.rs:/// The type of effect being performed
crates/causality-effects/src/types.rs-#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
crates/causality-effects/src/types.rs-pub enum EffectType {
--
crates/causality-effects/src/types.rs-impl fmt::Display for EffectType {
crates/causality-effects/src/types.rs-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
--
crates/causality-effects/src/types.rs:/// Type of resource change
crates/causality-effects/src/types.rs-#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
crates/causality-effects/src/types.rs-pub enum ResourceChangeType {
--
crates/causality-effects/src/types.rs-impl fmt::Display for ResourceChangeType {
crates/causality-effects/src/types.rs-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
--
crates/causality-effects/src/types.rs:/// Represents a change to a resource
crates/causality-effects/src/types.rs-#[derive(Debug, Clone, Serialize, Deserialize)]
crates/causality-effects/src/types.rs-pub struct ResourceChange {
crates/causality-effects/src/types.rs:    /// ID of the resource that was changed
crates/causality-effects/src/types.rs-    pub resource_id: ContentId,
crates/causality-effects/src/types.rs:    /// Type of change that occurred
crates/causality-effects/src/types.rs-    pub change_type: ResourceChangeType,
crates/causality-effects/src/types.rs:    /// Hash of the previous state (if any)
crates/causality-effects/src/types.rs-    pub previous_state_hash: Option<String>,
crates/causality-effects/src/types.rs:    /// Hash of the new state
crates/causality-effects/src/types.rs-    pub new_state_hash: String,
crates/causality-effects/src/types.rs-} 
--
crates/causality-effects/src/effect_id.rs:/// Uniquely identifies an effect
crates/causality-effects/src/effect_id.rs-#[derive(Debug, Clone, PartialEq, Eq, Hash, BorshSerialize, BorshDeserialize)]
crates/causality-effects/src/effect_id.rs-pub struct EffectId {
--
crates/causality-effects/src/effect_id.rs-
crates/causality-effects/src/effect_id.rs-impl ContentAddressed for EffectIdContent {
crates/causality-effects/src/effect_id.rs-    fn content_hash(&self) -> HashOutput {
--
crates/causality-effects/src/effect_id.rs:    /// Create a new effect ID with the given ID
crates/causality-effects/src/effect_id.rs-    pub fn new(id: String) -> Self {
crates/causality-effects/src/effect_id.rs-        Self { id }
crates/causality-effects/src/effect_id.rs-    }
crates/causality-effects/src/effect_id.rs-    
crates/causality-effects/src/effect_id.rs:    /// Create a new unique effect ID using content-derived identifier
crates/causality-effects/src/effect_id.rs-    pub fn new_unique() -> Self {
--
crates/causality-effects/src/effect_id.rs-        let content = EffectIdContent {
crates/causality-effects/src/effect_id.rs-            effect_type: "generic".to_string(),
crates/causality-effects/src/effect_id.rs-            timestamp: std::time::SystemTime::now()
--
crates/causality-effects/src/effect_id.rs:    /// Create a new effect ID for a specific effect type
crates/causality-effects/src/effect_id.rs-    pub fn for_effect_type(effect_type: &str) -> Self {
--
crates/causality-effects/src/effect_id.rs-        let content = EffectIdContent {
crates/causality-effects/src/effect_id.rs-            effect_type: effect_type.to_string(),
crates/causality-effects/src/effect_id.rs-            timestamp: std::time::SystemTime::now()
--
crates/causality-effects/src/effect_id.rs:    /// Get the ID as a string
crates/causality-effects/src/effect_id.rs-    pub fn as_str(&self) -> &str {
--
crates/causality-effects/src/effect_id.rs-    }
crates/causality-effects/src/effect_id.rs-}
crates/causality-effects/src/effect_id.rs-
--
crates/causality-effects/src/constraints/validation.rs:/// Validates and orchestrates effects based on their constraints
crates/causality-effects/src/constraints/validation.rs-pub struct EffectValidator {
--
crates/causality-effects/src/constraints/validation.rs-    domain_registry: Arc<DomainRegistry>,
crates/causality-effects/src/constraints/validation.rs-    capability_repo: Arc<dyn CapabilityRepository>,
crates/causality-effects/src/constraints/validation.rs-    resource_api: Arc<dyn ResourceAPI>,
--
crates/causality-effects/src/constraints/validation.rs:    /// Create a new effect validator
crates/causality-effects/src/constraints/validation.rs-    pub fn new(
--
crates/causality-effects/src/constraints/validation.rs-        capability_repo: Arc<dyn CapabilityRepository>,
crates/causality-effects/src/constraints/validation.rs-        resource_api: Arc<dyn ResourceAPI>,
crates/causality-effects/src/constraints/validation.rs-    ) -> Self {
--
crates/causality-effects/src/constraints/validation.rs:    /// Validate an effect based on its constraints
crates/causality-effects/src/constraints/validation.rs-    pub async fn validate_effect(&self, effect: &dyn Effect, context: &EffectContext) -> Result<(), EffectError> {
--
crates/causality-effects/src/constraints/validation.rs-        if effect.query_type().is_empty() {
crates/causality-effects/src/constraints/validation.rs-            return Err(EffectError::ValidationError("Query type cannot be empty".to_string()));
crates/causality-effects/src/constraints/validation.rs-        }
--
crates/causality-effects/src/constraints/validation.rs:/// Orchestrates execution of effects
crates/causality-effects/src/constraints/validation.rs-pub struct EffectOrchestrator {
crates/causality-effects/src/constraints/validation.rs-    validator: EffectValidator,
crates/causality-effects/src/constraints/validation.rs-}
crates/causality-effects/src/constraints/validation.rs-
crates/causality-effects/src/constraints/validation.rs-impl EffectOrchestrator {
crates/causality-effects/src/constraints/validation.rs:    /// Create a new effect orchestrator
crates/causality-effects/src/constraints/validation.rs-    pub fn new(validator: EffectValidator) -> Self {
--
crates/causality-effects/src/constraints/validation.rs-            validator,
crates/causality-effects/src/constraints/validation.rs-        }
crates/causality-effects/src/constraints/validation.rs-    }
--
crates/causality-effects/src/constraints/validation.rs:    /// Execute an effect with validation
crates/causality-effects/src/constraints/validation.rs-    pub async fn execute_effect<E: Effect + ?Sized>(&self, effect: &E, context: EffectContext) -> EffectResult<EffectOutcome> {
--
crates/causality-effects/src/constraints/validation.rs-        self.validator.validate_effect(effect, &context).await?;
crates/causality-effects/src/constraints/validation.rs-        
crates/causality-effects/src/constraints/validation.rs-        // Execute the effect
--
crates/causality-effects/src/constraints/validation.rs:    /// Execute a sequence of effects
crates/causality-effects/src/constraints/validation.rs-    pub async fn execute_sequence(&self, effects: Vec<Arc<dyn Effect>>, mut context: EffectContext) -> EffectResult<Vec<EffectOutcome>> {
--
crates/causality-effects/src/constraints/validation.rs-        
crates/causality-effects/src/constraints/validation.rs-        for effect in effects {
crates/causality-effects/src/constraints/validation.rs-            // Validate and execute each effect in sequence
--
crates/causality-effects/src/constraints/validation.rs:    /// Execute effects in parallel
crates/causality-effects/src/constraints/validation.rs-    pub async fn execute_parallel(&self, effects: Vec<Arc<dyn Effect>>, context: EffectContext) -> EffectResult<Vec<EffectOutcome>> {
--
crates/causality-effects/src/constraints/validation.rs-        
crates/causality-effects/src/constraints/validation.rs-        // Create a future for each effect
crates/causality-effects/src/constraints/validation.rs-        let futures = effects.iter().map(|effect| {
--
crates/causality-effects/src/constraints/validation.rs:    /// Execute an effect conditionally
crates/causality-effects/src/constraints/validation.rs-    pub async fn execute_conditional(
--
crates/causality-effects/src/constraints/validation.rs-        then_effect: Arc<dyn Effect>,
crates/causality-effects/src/constraints/validation.rs-        else_effect: Option<Arc<dyn Effect>>,
--
crates/causality-effects/src/constraints/validation.rs:/// Result of constraint verification
crates/causality-effects/src/constraints/validation.rs-#[derive(Debug, Clone, PartialEq)]
crates/causality-effects/src/constraints/validation.rs-pub enum ConstraintVerificationResult {
--
crates/causality-effects/src/constraints/validation.rs-    Deferred,
crates/causality-effects/src/constraints/validation.rs-}
crates/causality-effects/src/constraints/validation.rs-
crates/causality-effects/src/constraints/validation.rs:/// Condition for applying a constraint
crates/causality-effects/src/constraints/validation.rs-#[derive(Debug, Clone, PartialEq)]
crates/causality-effects/src/constraints/validation.rs-pub enum ConstraintCondition {
--
crates/causality-effects/src/constraints/validation.rs:    /// Apply based on a custom predicate
crates/causality-effects/src/constraints/validation.rs-    Custom(Arc<dyn Fn(&dyn Effect) -> bool + Send + Sync>),
crates/causality-effects/src/constraints/validation.rs-}
crates/causality-effects/src/constraints/validation.rs-
crates/causality-effects/src/constraints/validation.rs:/// Effect constraint definition
crates/causality-effects/src/constraints/validation.rs-pub struct EffectConstraint {
--
crates/causality-effects/src/constraints/validation.rs-    verifier: Arc<dyn Fn(&dyn Effect) -> ConstraintVerificationResult + Send + Sync>,
crates/causality-effects/src/constraints/validation.rs-}
crates/causality-effects/src/constraints/validation.rs-
crates/causality-effects/src/constraints/validation.rs-impl EffectConstraint {
crates/causality-effects/src/constraints/validation.rs:    /// Create a new constraint
crates/causality-effects/src/constraints/validation.rs-    pub fn new(
--
crates/causality-effects/src/constraints/validation.rs-        description: impl Into<String>,
crates/causality-effects/src/constraints/validation.rs-        condition: ConstraintCondition,
crates/causality-effects/src/constraints/validation.rs-        verifier: impl Fn(&dyn Effect) -> ConstraintVerificationResult + Send + Sync + 'static,
--
crates/causality-effects/src/constraints/validation.rs:    /// Get the constraint name
crates/causality-effects/src/constraints/validation.rs-    pub fn name(&self) -> &str {
crates/causality-effects/src/constraints/validation.rs-        &self.name
crates/causality-effects/src/constraints/validation.rs-    }
crates/causality-effects/src/constraints/validation.rs-    
crates/causality-effects/src/constraints/validation.rs:    /// Get the constraint description
crates/causality-effects/src/constraints/validation.rs-    pub fn description(&self) -> &str {
crates/causality-effects/src/constraints/validation.rs-        &self.description
crates/causality-effects/src/constraints/validation.rs-    }
crates/causality-effects/src/constraints/validation.rs-    
crates/causality-effects/src/constraints/validation.rs:    /// Check if this constraint applies to the given effect
crates/causality-effects/src/constraints/validation.rs-    pub fn applies_to(&self, effect: &dyn Effect) -> bool {
--
crates/causality-effects/src/constraints/validation.rs-            ConstraintCondition::Always => true,
crates/causality-effects/src/constraints/validation.rs-            ConstraintCondition::EffectName(name) => effect.name() == name,
crates/causality-effects/src/constraints/validation.rs-            ConstraintCondition::Custom(predicate) => predicate(effect),
--
crates/causality-effects/src/constraints/validation.rs:    /// Verify if an effect satisfies this constraint
crates/causality-effects/src/constraints/validation.rs-    pub fn verify(&self, effect: &dyn Effect) -> ConstraintVerificationResult {
--
crates/causality-effects/src/constraints/validation.rs-            return ConstraintVerificationResult::Satisfied;
crates/causality-effects/src/constraints/validation.rs-        }
crates/causality-effects/src/constraints/validation.rs-        (self.verifier)(effect)
--
crates/causality-effects/src/constraints/validation.rs:/// Helper function to create a new constraint
crates/causality-effects/src/constraints/validation.rs-pub fn create_constraint(
--
crates/causality-effects/src/constraints/validation.rs-    description: impl Into<String>,
crates/causality-effects/src/constraints/validation.rs-    condition: ConstraintCondition,
crates/causality-effects/src/constraints/validation.rs-    verifier: impl Fn(&dyn Effect) -> ConstraintVerificationResult + Send + Sync + 'static,
--
crates/causality-effects/src/constraints/validation.rs:/// Constraint verifier for validating effects against constraints
crates/causality-effects/src/constraints/validation.rs-pub struct ConstraintVerifier {
--
crates/causality-effects/src/constraints/validation.rs-    constraints: Vec<EffectConstraint>,
crates/causality-effects/src/constraints/validation.rs-}
crates/causality-effects/src/constraints/validation.rs-
crates/causality-effects/src/constraints/validation.rs-impl ConstraintVerifier {
crates/causality-effects/src/constraints/validation.rs:    /// Create a new constraint verifier
crates/causality-effects/src/constraints/validation.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/constraints/validation.rs-            constraints: Vec::new(),
crates/causality-effects/src/constraints/validation.rs-        }
crates/causality-effects/src/constraints/validation.rs-    }
--
crates/causality-effects/src/constraints/validation.rs:    /// Register a constraint with this verifier
crates/causality-effects/src/constraints/validation.rs-    pub fn register_constraint(&mut self, constraint: EffectConstraint) {
crates/causality-effects/src/constraints/validation.rs-        self.constraints.push(constraint);
crates/causality-effects/src/constraints/validation.rs-    }
crates/causality-effects/src/constraints/validation.rs-    
crates/causality-effects/src/constraints/validation.rs:    /// Register multiple constraints
crates/causality-effects/src/constraints/validation.rs-    pub fn register_constraints(&mut self, constraints: Vec<EffectConstraint>) {
crates/causality-effects/src/constraints/validation.rs-        self.constraints.extend(constraints);
crates/causality-effects/src/constraints/validation.rs-    }
crates/causality-effects/src/constraints/validation.rs-    
crates/causality-effects/src/constraints/validation.rs:    /// Verify if an effect satisfies all applicable constraints
crates/causality-effects/src/constraints/validation.rs-    pub fn verify(&self, effect: &dyn Effect) -> Vec<(String, ConstraintVerificationResult)> {
--
crates/causality-effects/src/constraints/validation.rs-            .iter()
crates/causality-effects/src/constraints/validation.rs-            .filter(|constraint| constraint.applies_to(effect))
crates/causality-effects/src/constraints/validation.rs-            .map(|constraint| (constraint.name().to_string(), constraint.verify(effect)))
--
crates/causality-effects/src/constraints/validation.rs:    /// Verify an effect and return whether all constraints are satisfied
crates/causality-effects/src/constraints/validation.rs-    pub fn verify_all_satisfied(&self, effect: &dyn Effect) -> Result<(), String> {
--
crates/causality-effects/src/constraints/validation.rs-        
crates/causality-effects/src/constraints/validation.rs-        let failures: Vec<(String, String)> = results
crates/causality-effects/src/constraints/validation.rs-            .into_iter()
--
crates/causality-effects/src/constraints/validation.rs:    /// Execute an effect after verifying its constraints
crates/causality-effects/src/constraints/validation.rs-    pub async fn execute_effect<E: Effect + ?Sized>(&self, effect: &E, context: &EffectContext) -> EffectResult<EffectOutcome> {
--
crates/causality-effects/src/constraints/validation.rs-        if let Err(reason) = self.verify_all_satisfied(effect) {
crates/causality-effects/src/constraints/validation.rs-            return Err(EffectError::ValidationError(reason));
crates/causality-effects/src/constraints/validation.rs-        }
--
crates/causality-effects/src/constraints/validation.rs:    /// Execute a sequence of effects, verifying constraints for each
crates/causality-effects/src/constraints/validation.rs-    pub async fn execute_sequence(&self, effects: Vec<Arc<dyn Effect>>, context: &EffectContext) -> EffectResult<Vec<EffectOutcome>> {
--
crates/causality-effects/src/constraints/validation.rs-        
crates/causality-effects/src/constraints/validation.rs-        for effect in effects {
crates/causality-effects/src/constraints/validation.rs-            // Execute with constraints
--
crates/causality-effects/src/constraints/validation.rs:    /// Execute effects in parallel, verifying constraints for each
crates/causality-effects/src/constraints/validation.rs-    pub async fn execute_parallel(&self, effects: Vec<Arc<dyn Effect>>, context: &EffectContext) -> EffectResult<Vec<EffectOutcome>> {
--
crates/causality-effects/src/constraints/validation.rs-        
crates/causality-effects/src/constraints/validation.rs-        // Create futures for all effects
crates/causality-effects/src/constraints/validation.rs-        let futures = effects
--
crates/causality-effects/src/handler.rs:/// The outcome of handling an effect
crates/causality-effects/src/handler.rs-pub type HandlerResult<T> = Result<T>;
crates/causality-effects/src/handler.rs-
crates/causality-effects/src/handler.rs:/// Core trait for effect handlers that process and execute effects
crates/causality-effects/src/handler.rs-#[async_trait]
crates/causality-effects/src/handler.rs-pub trait EffectHandler: Send + Sync {
--
crates/causality-effects/src/handler.rs-        effect.can_execute_in(self.execution_boundary())
crates/causality-effects/src/handler.rs-    }
crates/causality-effects/src/handler.rs-}
crates/causality-effects/src/handler.rs-
crates/causality-effects/src/handler.rs:/// A handler that delegates to other handlers based on criteria
crates/causality-effects/src/handler.rs-pub struct CompositeHandler {
--
crates/causality-effects/src/handler.rs-    handlers: Vec<Arc<dyn EffectHandler>>,
crates/causality-effects/src/handler.rs-}
crates/causality-effects/src/handler.rs-
crates/causality-effects/src/handler.rs-impl CompositeHandler {
crates/causality-effects/src/handler.rs:    /// Create a new composite handler with the given boundary
crates/causality-effects/src/handler.rs-    pub fn new(boundary: ExecutionBoundary) -> Self {
--
crates/causality-effects/src/handler.rs-            boundary,
crates/causality-effects/src/handler.rs-            handlers: Vec::new(),
crates/causality-effects/src/handler.rs-        }
--
crates/causality-effects/src/handler.rs:    /// Add a handler to this composite
crates/causality-effects/src/handler.rs-    pub fn add_handler(&mut self, handler: Arc<dyn EffectHandler>) {
--
crates/causality-effects/src/handler.rs-            .find(|h| h.can_handle(effect))
crates/causality-effects/src/handler.rs-            .cloned()
crates/causality-effects/src/handler.rs-    }
--
crates/causality-effects/src/handler.rs:/// A simple handler for inside-system effects
crates/causality-effects/src/handler.rs-pub struct InsideSystemHandler;
crates/causality-effects/src/handler.rs-
crates/causality-effects/src/handler.rs-impl InsideSystemHandler {
crates/causality-effects/src/handler.rs:    /// Create a new inside-system handler
crates/causality-effects/src/handler.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/handler.rs-    }
crates/causality-effects/src/handler.rs-}
crates/causality-effects/src/handler.rs-
--
crates/causality-effects/src/handler.rs:/// A simple handler for outside-system effects
crates/causality-effects/src/handler.rs-pub struct OutsideSystemHandler;
crates/causality-effects/src/handler.rs-
crates/causality-effects/src/handler.rs-impl OutsideSystemHandler {
crates/causality-effects/src/handler.rs:    /// Create a new outside-system handler
crates/causality-effects/src/handler.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/handler.rs-    }
crates/causality-effects/src/handler.rs-}
crates/causality-effects/src/handler.rs-
--
crates/causality-effects/src/handler.rs:/// Factory for creating effect handlers
crates/causality-effects/src/handler.rs-pub struct HandlerFactory;
crates/causality-effects/src/handler.rs-
crates/causality-effects/src/handler.rs-impl HandlerFactory {
crates/causality-effects/src/handler.rs:    /// Create a handler for the given execution boundary
crates/causality-effects/src/handler.rs-    pub fn create(boundary: ExecutionBoundary) -> Box<dyn EffectHandler> {
--
crates/causality-effects/src/handler.rs-            ExecutionBoundary::InsideSystem => Box::new(InsideSystemHandler::new()),
crates/causality-effects/src/handler.rs-            ExecutionBoundary::OutsideSystem => Box::new(OutsideSystemHandler::new()),
crates/causality-effects/src/handler.rs-        }
--
crates/causality-effects/src/handler.rs:    /// Create a composite handler for multiple execution boundaries
crates/causality-effects/src/handler.rs-    pub fn create_composite(primary_boundary: ExecutionBoundary, 
--
crates/causality-effects/src/handler.rs-        
crates/causality-effects/src/handler.rs-        for h in additional_handlers {
--
crates/causality-effects/src/lib.rs:/// The result of applying an effect
crates/causality-effects/src/lib.rs-#[derive(Debug, Clone)]
crates/causality-effects/src/lib.rs-pub struct EffectOutcome {
crates/causality-effects/src/lib.rs:    /// ID of the effect
crates/causality-effects/src/lib.rs-    pub id: EffectId,
crates/causality-effects/src/lib.rs-    
crates/causality-effects/src/lib.rs:    /// Whether the effect was successful
crates/causality-effects/src/lib.rs-    pub success: bool,
crates/causality-effects/src/lib.rs-    
crates/causality-effects/src/lib.rs:    /// Output data (key-value pairs)
crates/causality-effects/src/lib.rs-    pub data: HashMap<String, String>,
crates/causality-effects/src/lib.rs-    
crates/causality-effects/src/lib.rs:    /// Error message if not successful
crates/causality-effects/src/lib.rs-    pub error: Option<String>,
crates/causality-effects/src/lib.rs-    
crates/causality-effects/src/lib.rs:    /// The execution context ID
crates/causality-effects/src/lib.rs-    pub execution_id: Option<ContentId>,
crates/causality-effects/src/lib.rs-    
crates/causality-effects/src/lib.rs:    /// Resource changes resulting from the effect
crates/causality-effects/src/lib.rs-    pub resource_changes: Vec<ResourceChange>,
crates/causality-effects/src/lib.rs-    
crates/causality-effects/src/lib.rs:    /// Metadata about the execution
crates/causality-effects/src/lib.rs-    pub metadata: HashMap<String, String>,
crates/causality-effects/src/lib.rs-}
crates/causality-effects/src/lib.rs-
crates/causality-effects/src/lib.rs-impl EffectOutcome {
crates/causality-effects/src/lib.rs:    /// Create a successful outcome
crates/causality-effects/src/lib.rs-    pub fn success(id: EffectId) -> Self {
--
crates/causality-effects/src/lib.rs-            id,
crates/causality-effects/src/lib.rs-            success: true,
crates/causality-effects/src/lib.rs-            data: HashMap::new(),
--
crates/causality-effects/src/lib.rs:    /// Create a failure outcome
crates/causality-effects/src/lib.rs-    pub fn failure(id: EffectId, error: impl Into<String>) -> Self {
--
crates/causality-effects/src/lib.rs-            id,
crates/causality-effects/src/lib.rs-            success: false,
crates/causality-effects/src/lib.rs-            data: HashMap::new(),
--
crates/causality-effects/src/lib.rs:    /// Set the execution ID
crates/causality-effects/src/lib.rs-    pub fn with_execution_id(mut self, execution_id: ContentId) -> Self {
crates/causality-effects/src/lib.rs-        self.execution_id = Some(execution_id);
crates/causality-effects/src/lib.rs-        self
crates/causality-effects/src/lib.rs-    }
crates/causality-effects/src/lib.rs-    
crates/causality-effects/src/lib.rs:    /// Add data to the outcome
crates/causality-effects/src/lib.rs-    pub fn with_data(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/lib.rs-        self.data.insert(key.into(), value.into());
crates/causality-effects/src/lib.rs-        self
crates/causality-effects/src/lib.rs-    }
crates/causality-effects/src/lib.rs-    
crates/causality-effects/src/lib.rs:    /// Add a resource change to the outcome
crates/causality-effects/src/lib.rs-    pub fn with_resource_change(mut self, change: ResourceChange) -> Self {
crates/causality-effects/src/lib.rs-        self.resource_changes.push(change);
crates/causality-effects/src/lib.rs-        self
crates/causality-effects/src/lib.rs-    }
crates/causality-effects/src/lib.rs-    
crates/causality-effects/src/lib.rs:    /// Add metadata to the outcome
crates/causality-effects/src/lib.rs-    pub fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
--
crates/causality-effects/src/lib.rs-        self
crates/causality-effects/src/lib.rs-    }
crates/causality-effects/src/lib.rs-}
--
crates/causality-effects/src/lib.rs:/// Status of an effect execution
crates/causality-effects/src/lib.rs-pub enum EffectExecution {
--
crates/causality-effects/src/lib.rs-    Error(Error),
crates/causality-effects/src/lib.rs-}
crates/causality-effects/src/lib.rs-
crates/causality-effects/src/lib.rs:/// Effect context for execution
crates/causality-effects/src/lib.rs-#[derive(Debug, Clone)]
crates/causality-effects/src/lib.rs-pub struct EffectContext {
crates/causality-effects/src/lib.rs:    /// When the effect was started
crates/causality-effects/src/lib.rs-    pub started_at: DateTime<Utc>,
crates/causality-effects/src/lib.rs-    
crates/causality-effects/src/lib.rs:    /// Caller address
crates/causality-effects/src/lib.rs-    pub caller: Option<String>,
crates/causality-effects/src/lib.rs-    
crates/causality-effects/src/lib.rs:    /// Context parameters
crates/causality-effects/src/lib.rs-    pub params: HashMap<String, String>,
crates/causality-effects/src/lib.rs-}
crates/causality-effects/src/lib.rs-
crates/causality-effects/src/lib.rs-impl EffectContext {
crates/causality-effects/src/lib.rs:    /// Create a new empty context
crates/causality-effects/src/lib.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/lib.rs-            started_at: Utc::now(),
crates/causality-effects/src/lib.rs-            caller: None,
crates/causality-effects/src/lib.rs-            params: HashMap::new(),
--
crates/causality-effects/src/lib.rs:    /// Create a context with a caller
crates/causality-effects/src/lib.rs-    pub fn with_caller(caller: String) -> Self {
--
crates/causality-effects/src/lib.rs-        context.caller = Some(caller);
crates/causality-effects/src/lib.rs-        context
crates/causality-effects/src/lib.rs-    }
--
crates/causality-effects/src/lib.rs:    /// Add a parameter to the context
crates/causality-effects/src/lib.rs-    pub fn with_param(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
--
crates/causality-effects/src/lib.rs-        self
crates/causality-effects/src/lib.rs-    }
crates/causality-effects/src/lib.rs-}
--
crates/causality-effects/src/lib.rs:/// Result type for effect execution
crates/causality-effects/src/lib.rs-pub type EffectResult<T> = std::result::Result<T, EffectError>;
crates/causality-effects/src/lib.rs-
crates/causality-effects/src/lib.rs:/// Error type for effect execution
crates/causality-effects/src/lib.rs-#[derive(Debug, thiserror::Error)]
crates/causality-effects/src/lib.rs-pub enum EffectError {
--
crates/causality-effects/src/lib.rs-    AuthenticationFailed(String),
crates/causality-effects/src/lib.rs-    
--
crates/causality-effects/src/lib.rs:/// Main effect trait - defines something that can be executed and produces an outcome
crates/causality-effects/src/lib.rs-#[async_trait]
crates/causality-effects/src/lib.rs-pub trait Effect: Send + Sync + std::fmt::Debug {
--
crates/causality-effects/src/lib.rs-    fn as_any(&self) -> &dyn Any;
crates/causality-effects/src/lib.rs-}
crates/causality-effects/src/lib.rs-
crates/causality-effects/src/lib.rs:/// Asynchronous execution trait for effects
crates/causality-effects/src/lib.rs-#[async_trait]
crates/causality-effects/src/lib.rs-pub trait AsyncEffect: Effect {
--
crates/causality-effects/src/lib.rs-    async fn execute_async(&self, context: &EffectContext) -> EffectResult<EffectOutcome>;
crates/causality-effects/src/lib.rs-}
crates/causality-effects/src/lib.rs-
crates/causality-effects/src/lib.rs:/// A structure to manage effect registrations and executions
crates/causality-effects/src/lib.rs-#[derive(Debug)]
crates/causality-effects/src/lib.rs-pub struct EffectRegistry {
crates/causality-effects/src/lib.rs-    effects: HashMap<String, Arc<dyn Effect>>,
crates/causality-effects/src/lib.rs-    crossing_registry: boundary::BoundaryCrossingRegistry,
crates/causality-effects/src/lib.rs-}
--
crates/causality-effects/src/lib.rs:    /// Create a new effect registry
crates/causality-effects/src/lib.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/lib.rs-            effects: HashMap::new(),
crates/causality-effects/src/lib.rs-            crossing_registry: boundary::BoundaryCrossingRegistry::new(),
crates/causality-effects/src/lib.rs-        }
--
crates/causality-effects/src/lib.rs:    /// Register an effect
crates/causality-effects/src/lib.rs-    pub fn register(&mut self, effect: Arc<dyn Effect>) {
crates/causality-effects/src/lib.rs-        self.effects.insert(effect.name().to_string(), effect);
crates/causality-effects/src/lib.rs-    }
crates/causality-effects/src/lib.rs-    
crates/causality-effects/src/lib.rs:    /// Get an effect by name
crates/causality-effects/src/lib.rs-    pub fn get(&self, name: &str) -> Option<Arc<dyn Effect>> {
crates/causality-effects/src/lib.rs-        self.effects.get(name).cloned()
crates/causality-effects/src/lib.rs-    }
crates/causality-effects/src/lib.rs-    
crates/causality-effects/src/lib.rs:    /// Get all registered effects
crates/causality-effects/src/lib.rs-    pub fn get_all(&self) -> Vec<Arc<dyn Effect>> {
crates/causality-effects/src/lib.rs-        self.effects.values().cloned().collect()
crates/causality-effects/src/lib.rs-    }
crates/causality-effects/src/lib.rs-    
crates/causality-effects/src/lib.rs:    /// Get effects that can execute in a specific boundary
crates/causality-effects/src/lib.rs-    pub fn get_for_boundary(&self, boundary: ExecutionBoundary) -> Vec<Arc<dyn Effect>> {
--
crates/causality-effects/src/lib.rs-            .values()
crates/causality-effects/src/lib.rs-            .filter(|e| e.can_execute_in(boundary))
crates/causality-effects/src/lib.rs-            .cloned()
--
crates/causality-effects/src/lib.rs:    /// Record a boundary crossing event
crates/causality-effects/src/lib.rs-    pub fn record_crossing<T>(&mut self, crossing: &boundary::BoundaryCrossing<T>, 
--
crates/causality-effects/src/lib.rs-                             success: bool, 
crates/causality-effects/src/lib.rs-                             error: Option<String>)
crates/causality-effects/src/lib.rs-    where
--
crates/causality-effects/src/lib.rs:    /// Get the boundary crossing registry
crates/causality-effects/src/lib.rs-    pub fn crossing_registry(&self) -> &boundary::BoundaryCrossingRegistry {
--
crates/causality-effects/src/lib.rs-}
crates/causality-effects/src/lib.rs-
--
crates/causality-effects/src/lib.rs:/// Effect Manager for executing and managing effects
crates/causality-effects/src/lib.rs-#[derive(Debug)]
crates/causality-effects/src/lib.rs-pub struct EffectManager {
crates/causality-effects/src/lib.rs-    registry: EffectRegistry,
crates/causality-effects/src/lib.rs-    resource_api: Option<Arc<dyn resource_api>>,
crates/causality-effects/src/lib.rs-}
--
crates/causality-effects/src/lib.rs:    /// Create a new effect manager
crates/causality-effects/src/lib.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/lib.rs-            registry: EffectRegistry::new(),
crates/causality-effects/src/lib.rs-            resource_api: None,
crates/causality-effects/src/lib.rs-        }
--
crates/causality-effects/src/lib.rs:    /// Create a new effect manager with a resource API
crates/causality-effects/src/lib.rs-    pub fn with_resource_api(resource_api: Arc<dyn resource_api>) -> Self {
--
crates/causality-effects/src/lib.rs-            registry: EffectRegistry::new(),
crates/causality-effects/src/lib.rs-            resource_api: Some(resource_api),
crates/causality-effects/src/lib.rs-        }
--
crates/causality-effects/src/lib.rs:    /// Register an effect
crates/causality-effects/src/lib.rs-    pub fn register_effect(&mut self, effect: Arc<dyn Effect>) {
crates/causality-effects/src/lib.rs-        self.registry.register(effect);
crates/causality-effects/src/lib.rs-    }
crates/causality-effects/src/lib.rs-    
crates/causality-effects/src/lib.rs:    /// Get the effect registry
crates/causality-effects/src/lib.rs-    pub fn registry(&self) -> &EffectRegistry {
crates/causality-effects/src/lib.rs-        &self.registry
crates/causality-effects/src/lib.rs-    }
crates/causality-effects/src/lib.rs-    
crates/causality-effects/src/lib.rs:    /// Get a mutable reference to the effect registry
crates/causality-effects/src/lib.rs-    pub fn registry_mut(&mut self) -> &mut EffectRegistry {
crates/causality-effects/src/lib.rs-        &mut self.registry
crates/causality-effects/src/lib.rs-    }
crates/causality-effects/src/lib.rs-    
crates/causality-effects/src/lib.rs:    /// Execute an effect by name
crates/causality-effects/src/lib.rs-    pub async fn execute_effect(&self, effect_name: &str, context: EffectContext) -> EffectResult<EffectOutcome> {
--
crates/causality-effects/src/lib.rs-            .ok_or_else(|| EffectError::NotFound(format!("Effect '{}' not found", effect_name)))?;
crates/causality-effects/src/lib.rs-        
crates/causality-effects/src/lib.rs-        // Verify capabilities if needed
--
crates/causality-effects/src/lib.rs:    /// Execute an effect asynchronously by name
crates/causality-effects/src/lib.rs-    pub async fn execute_effect_async(&self, effect_name: &str, context: EffectContext) -> EffectResult<EffectOutcome> {
--
crates/causality-effects/src/lib.rs-        if self.resource_api.is_none() {
crates/causality-effects/src/lib.rs-            return Ok(());
crates/causality-effects/src/lib.rs-        }
--
crates/causality-effects/src/lib.rs:/// Trait for effects that can be applied to program accounts
crates/causality-effects/src/lib.rs-pub trait ProgramAccountEffect: Effect {
--
crates/causality-effects/src/lib.rs-// This is a placeholder for the ProgramAccount trait
crates/causality-effects/src/lib.rs-trait ProgramAccount: Send + Sync {
--
crates/causality-effects/src/lib.rs:/// Basic no-op effect implementation
crates/causality-effects/src/lib.rs-#[derive(Debug, Clone)]
crates/causality-effects/src/lib.rs-pub struct EmptyEffect {
crates/causality-effects/src/lib.rs-    id: EffectId,
crates/causality-effects/src/lib.rs-    name: String,
crates/causality-effects/src/lib.rs-    description: String,
--
crates/causality-effects/src/lib.rs:    /// Create a new empty effect
crates/causality-effects/src/lib.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/lib.rs-            id: EffectId::new_unique(),
crates/causality-effects/src/lib.rs-            name: "empty".to_string(),
crates/causality-effects/src/lib.rs-            description: "No-op effect".to_string(),
--
crates/causality-effects/src/lib.rs:    /// Create a new empty effect with a specific name
crates/causality-effects/src/lib.rs-    pub fn with_name(name: impl Into<String>) -> Self {
--
crates/causality-effects/src/lib.rs-            id: EffectId::new_unique(),
crates/causality-effects/src/lib.rs-            name: name.into(),
crates/causality-effects/src/lib.rs-            description: "No-op effect".to_string(),
--
crates/causality-effects/src/lib.rs:    /// Create a new empty effect with a specific description
crates/causality-effects/src/lib.rs-    pub fn with_description(description: impl Into<String>) -> Self {
--
crates/causality-effects/src/lib.rs-            id: EffectId::new_unique(),
crates/causality-effects/src/lib.rs-            name: "empty".to_string(),
crates/causality-effects/src/lib.rs-            description: description.into(),
--
crates/causality-effects/src/lib.rs:    /// Create a new empty effect with a specific boundary
crates/causality-effects/src/lib.rs-    pub fn with_boundary(boundary: ExecutionBoundary) -> Self {
--
crates/causality-effects/src/lib.rs-            id: EffectId::new_unique(),
crates/causality-effects/src/lib.rs-            name: "empty".to_string(),
crates/causality-effects/src/lib.rs-            description: "No-op effect".to_string(),
--
crates/causality-effects/src/capability/conversion.rs:/// Converts domain capabilities to effect capabilities
crates/causality-effects/src/capability/conversion.rs-pub fn convert_domain_to_effect_capabilities(
--
crates/causality-effects/src/capability/conversion.rs-) -> HashSet<EffectCapability> {
crates/causality-effects/src/capability/conversion.rs-    let mut effect_capabilities = HashSet::new();
crates/causality-effects/src/capability/conversion.rs-    
--
crates/causality-effects/src/capability/conversion.rs:/// Converts effect capabilities to domain capabilities
crates/causality-effects/src/capability/conversion.rs-pub fn convert_effect_to_domain_capabilities(
--
crates/causality-effects/src/capability/conversion.rs-) -> HashSet<DomainCapability> {
crates/causality-effects/src/capability/conversion.rs-    let mut domain_capabilities = HashSet::new();
crates/causality-effects/src/capability/conversion.rs-    
--
crates/causality-effects/src/capability/conversion.rs:/// Maps a domain capability to an effect capability
crates/causality-effects/src/capability/conversion.rs-pub fn map_domain_to_effect_capability(domain_cap: &DomainCapability) -> Option<EffectCapability> {
--
crates/causality-effects/src/capability/conversion.rs-        DomainCapability::SendTransaction => Some(EffectCapability::SubmitTransaction),
crates/causality-effects/src/capability/conversion.rs-        DomainCapability::SignTransaction => Some(EffectCapability::SignTransaction),
crates/causality-effects/src/capability/conversion.rs-        DomainCapability::BatchTransactions => None, // No direct mapping
--
crates/causality-effects/src/capability/conversion.rs:/// Maps an effect capability to a domain capability
crates/causality-effects/src/capability/conversion.rs-pub fn map_effect_to_domain_capability(effect_cap: &EffectCapability) -> Option<DomainCapability> {
--
crates/causality-effects/src/capability/conversion.rs-        EffectCapability::CreateResource => Some(DomainCapability::WriteState),
crates/causality-effects/src/capability/conversion.rs-        EffectCapability::ReadResource => Some(DomainCapability::ReadState),
crates/causality-effects/src/capability/conversion.rs-        EffectCapability::UpdateResource => Some(DomainCapability::WriteState),
--
crates/causality-effects/src/capability/conversion.rs:/// Maps a domain capability to a cross-domain capability
crates/causality-effects/src/capability/conversion.rs-pub fn map_domain_to_cross_domain_capability(domain_cap: &DomainCapability) -> Option<CrossDomainCapability> {
--
crates/causality-effects/src/capability/conversion.rs-        DomainCapability::BridgeAssets => Some(CrossDomainCapability::TransferAssets),
crates/causality-effects/src/capability/conversion.rs-        DomainCapability::VerifyBridgeTransaction => Some(CrossDomainCapability::VerifyCrossDomainProof),
crates/causality-effects/src/capability/conversion.rs-        _ => None, // Most domain capabilities don't map to cross-domain
--
crates/causality-effects/src/capability/conversion.rs:/// Converts a domain adapter's capabilities to an effect context
crates/causality-effects/src/capability/conversion.rs-pub async fn convert_domain_adapter_to_effect_context(
--
crates/causality-effects/src/capability/conversion.rs-    identity: String
crates/causality-effects/src/capability/conversion.rs-) -> Result<EffectContext> {
crates/causality-effects/src/capability/conversion.rs-    // Get domain info
--
crates/causality-effects/src/capability/conversion.rs:/// Enhances an effect context with domain adapter capabilities
crates/causality-effects/src/capability/conversion.rs-pub async fn enhance_effect_context_with_domain_capabilities(
--
crates/causality-effects/src/capability/conversion.rs-    adapter: &dyn DomainAdapter
crates/causality-effects/src/capability/conversion.rs-) -> Result<()> {
crates/causality-effects/src/capability/conversion.rs-    let domain_id = adapter.domain_id().clone();
--
crates/causality-effects/src/capability/conversion.rs:/// Verifies that an effect context has the required domain capabilities
crates/causality-effects/src/capability/conversion.rs-pub fn verify_domain_capabilities(
--
crates/causality-effects/src/capability/conversion.rs-    domain_id: &str,
crates/causality-effects/src/capability/conversion.rs-    required_capabilities: &[DomainCapability]
crates/causality-effects/src/capability/conversion.rs-) -> EffectResult<()> {
--
crates/causality-effects/src/capability/conversion.rs:/// Creates inherited capabilities for composed effects
crates/causality-effects/src/capability/conversion.rs-pub fn create_inherited_capabilities(
--
crates/causality-effects/src/capability/conversion.rs-) -> EffectContext {
crates/causality-effects/src/capability/conversion.rs-    let mut child_context = EffectContext::new();
--
crates/causality-effects/src/capability/verification.rs:/// Trait for objects that can verify capabilities across domain and effect boundaries
crates/causality-effects/src/capability/verification.rs-#[async_trait]
crates/causality-effects/src/capability/verification.rs-pub trait CapabilityVerifier: Send + Sync {
--
crates/causality-effects/src/capability/verification.rs-        capabilities: &[CrossDomainCapability],
crates/causality-effects/src/capability/verification.rs-        context: &EffectContext
crates/causality-effects/src/capability/verification.rs-    ) -> EffectResult<()>;
--
crates/causality-effects/src/capability/verification.rs:/// Default implementation of the capability verifier
crates/causality-effects/src/capability/verification.rs-pub struct DefaultCapabilityVerifier {
--
crates/causality-effects/src/capability/verification.rs-    required_cross_domain_capabilities: HashMap<String, Vec<CrossDomainCapability>>,
crates/causality-effects/src/capability/verification.rs-}
crates/causality-effects/src/capability/verification.rs-
crates/causality-effects/src/capability/verification.rs-impl DefaultCapabilityVerifier {
crates/causality-effects/src/capability/verification.rs:    /// Create a new capability verifier with default capability mappings
crates/causality-effects/src/capability/verification.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/capability/verification.rs-        let mut required_effect_capabilities = HashMap::new();
crates/causality-effects/src/capability/verification.rs-        let mut required_cross_domain_capabilities = HashMap::new();
crates/causality-effects/src/capability/verification.rs-        
--
crates/causality-effects/src/capability/verification.rs:    /// Register required domain capabilities for an effect type
crates/causality-effects/src/capability/verification.rs-    pub fn register_required_domain_capabilities(
--
crates/causality-effects/src/capability/verification.rs-        effect_type: &str,
crates/causality-effects/src/capability/verification.rs-        capabilities: Vec<DomainCapability>
crates/causality-effects/src/capability/verification.rs-    ) {
--
crates/causality-effects/src/capability/verification.rs:    /// Register required effect capabilities for an effect type
crates/causality-effects/src/capability/verification.rs-    pub fn register_required_effect_capabilities(
--
crates/causality-effects/src/capability/verification.rs-        effect_type: &str,
crates/causality-effects/src/capability/verification.rs-        capabilities: Vec<EffectCapability>
crates/causality-effects/src/capability/verification.rs-    ) {
--
crates/causality-effects/src/capability/verification.rs:    /// Register required cross-domain capabilities for an effect type
crates/causality-effects/src/capability/verification.rs-    pub fn register_required_cross_domain_capabilities(
--
crates/causality-effects/src/capability/verification.rs-        effect_type: &str,
crates/causality-effects/src/capability/verification.rs-        capabilities: Vec<CrossDomainCapability>
crates/causality-effects/src/capability/verification.rs-    ) {
--
crates/causality-effects/src/capability/verification.rs:    /// Get required domain capabilities for an effect type
crates/causality-effects/src/capability/verification.rs-    pub fn get_required_domain_capabilities(&self, effect_type: &str) -> Vec<DomainCapability> {
--
crates/causality-effects/src/capability/verification.rs-            .get(effect_type)
crates/causality-effects/src/capability/verification.rs-            .cloned()
crates/causality-effects/src/capability/verification.rs-            .unwrap_or_default()
--
crates/causality-effects/src/capability/verification.rs:    /// Get required effect capabilities for an effect type
crates/causality-effects/src/capability/verification.rs-    pub fn get_required_effect_capabilities(&self, effect_type: &str) -> Vec<EffectCapability> {
--
crates/causality-effects/src/capability/verification.rs-            .get(effect_type)
crates/causality-effects/src/capability/verification.rs-            .cloned()
crates/causality-effects/src/capability/verification.rs-            .unwrap_or_default()
--
crates/causality-effects/src/capability/verification.rs:    /// Get required cross-domain capabilities for an effect type
crates/causality-effects/src/capability/verification.rs-    pub fn get_required_cross_domain_capabilities(&self, effect_type: &str) -> Vec<CrossDomainCapability> {
--
crates/causality-effects/src/capability/verification.rs-            .get(effect_type)
crates/causality-effects/src/capability/verification.rs-            .cloned()
crates/causality-effects/src/capability/verification.rs-            .unwrap_or_default()
--
crates/causality-effects/src/capability/verification.rs:/// Trait for effects that can provide their domain ID
crates/causality-effects/src/capability/verification.rs-pub trait DomainIdGetter {
crates/causality-effects/src/capability/verification.rs:    /// Get the domain ID for this effect
crates/causality-effects/src/capability/verification.rs-    fn domain_id(&self) -> &str;
crates/causality-effects/src/capability/verification.rs-}
crates/causality-effects/src/capability/verification.rs-
crates/causality-effects/src/capability/verification.rs:/// Extension for effects to report required capabilities
crates/causality-effects/src/capability/verification.rs-pub trait CapabilityRequirements {
--
crates/causality-effects/src/capability/verification.rs-    }
crates/causality-effects/src/capability/verification.rs-} 
--
crates/causality-effects/src/capability/unified.rs:/// Unified capability that can represent both domain and effect capabilities
crates/causality-effects/src/capability/unified.rs-#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
crates/causality-effects/src/capability/unified.rs-pub enum UnifiedCapability {
--
crates/causality-effects/src/capability/unified.rs-    CrossDomain(CrossDomainCapability),
crates/causality-effects/src/capability/unified.rs-}
crates/causality-effects/src/capability/unified.rs-
crates/causality-effects/src/capability/unified.rs:/// Standard effect capabilities
crates/causality-effects/src/capability/unified.rs-#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
crates/causality-effects/src/capability/unified.rs-pub enum EffectCapability {
--
crates/causality-effects/src/capability/unified.rs-    CreateResource,
crates/causality-effects/src/capability/unified.rs-    ReadResource,
--
crates/causality-effects/src/capability/unified.rs:/// Cross-domain capabilities for operations spanning multiple domains
crates/causality-effects/src/capability/unified.rs-#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
crates/causality-effects/src/capability/unified.rs-pub enum CrossDomainCapability {
crates/causality-effects/src/capability/unified.rs-    // Asset bridge capabilities
crates/causality-effects/src/capability/unified.rs-    TransferAssets,
crates/causality-effects/src/capability/unified.rs-    LockAssets,
--
crates/causality-effects/src/capability/unified.rs:    /// Convert to string representation
crates/causality-effects/src/capability/unified.rs-    pub fn to_string(&self) -> String {
--
crates/causality-effects/src/capability/unified.rs-            UnifiedCapability::Domain(cap) => format!("domain:{}", cap.to_string()),
crates/causality-effects/src/capability/unified.rs-            UnifiedCapability::Effect(cap) => format!("effect:{}", effect_capability_to_string(cap)),
crates/causality-effects/src/capability/unified.rs-            UnifiedCapability::CrossDomain(cap) => format!("cross:{}", cross_domain_capability_to_string(cap)),
--
crates/causality-effects/src/capability/unified.rs:    /// Parse from string
crates/causality-effects/src/capability/unified.rs-    pub fn from_string(s: &str) -> Option<Self> {
--
crates/causality-effects/src/capability/unified.rs-            DomainCapability::from_string(cap_str).map(UnifiedCapability::Domain)
crates/causality-effects/src/capability/unified.rs-        } else if s.starts_with("effect:") {
--
crates/causality-effects/src/capability/unified.rs:/// Unified capability context for both domain and effect capabilities
crates/causality-effects/src/capability/unified.rs-#[derive(Debug, Clone)]
crates/causality-effects/src/capability/unified.rs-pub struct UnifiedCapabilityContext {
--
crates/causality-effects/src/capability/unified.rs-    cross_domain_capabilities: HashSet<CrossDomainCapability>,
crates/causality-effects/src/capability/unified.rs-}
crates/causality-effects/src/capability/unified.rs-
crates/causality-effects/src/capability/unified.rs-impl UnifiedCapabilityContext {
crates/causality-effects/src/capability/unified.rs:    /// Create a new empty capability context
crates/causality-effects/src/capability/unified.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/capability/unified.rs-            domain_capabilities: HashMap::new(),
crates/causality-effects/src/capability/unified.rs-            effect_capabilities: HashSet::new(),
crates/causality-effects/src/capability/unified.rs-            cross_domain_capabilities: HashSet::new(),
--
crates/causality-effects/src/capability/unified.rs:    /// Create from an effect context
crates/causality-effects/src/capability/unified.rs-    pub fn from_effect_context(context: &EffectContext) -> Self {
--
crates/causality-effects/src/capability/unified.rs-        
crates/causality-effects/src/capability/unified.rs-        // Extract capabilities from the effect context
crates/causality-effects/src/capability/unified.rs-        // This would parse the capability strings and organize them
--
crates/causality-effects/src/capability/unified.rs:    /// Add a domain capability
crates/causality-effects/src/capability/unified.rs-    pub fn add_domain_capability(&mut self, domain_id: impl Into<String>, capability: DomainCapability) {
--
crates/causality-effects/src/capability/unified.rs-        self.domain_capabilities
crates/causality-effects/src/capability/unified.rs-            .entry(domain_id)
crates/causality-effects/src/capability/unified.rs-            .or_insert_with(HashSet::new)
--
crates/causality-effects/src/capability/unified.rs:    /// Add an effect capability
crates/causality-effects/src/capability/unified.rs-    pub fn add_effect_capability(&mut self, capability: EffectCapability) {
crates/causality-effects/src/capability/unified.rs-        self.effect_capabilities.insert(capability);
crates/causality-effects/src/capability/unified.rs-    }
crates/causality-effects/src/capability/unified.rs-    
crates/causality-effects/src/capability/unified.rs:    /// Add a cross-domain capability
crates/causality-effects/src/capability/unified.rs-    pub fn add_cross_domain_capability(&mut self, capability: CrossDomainCapability) {
crates/causality-effects/src/capability/unified.rs-        self.cross_domain_capabilities.insert(capability);
crates/causality-effects/src/capability/unified.rs-    }
crates/causality-effects/src/capability/unified.rs-    
crates/causality-effects/src/capability/unified.rs:    /// Check if the context has a specific domain capability
crates/causality-effects/src/capability/unified.rs-    pub fn has_domain_capability(&self, domain_id: &str, capability: &DomainCapability) -> bool {
--
crates/causality-effects/src/capability/unified.rs-            .get(domain_id)
crates/causality-effects/src/capability/unified.rs-            .map(|caps| caps.contains(capability))
crates/causality-effects/src/capability/unified.rs-            .unwrap_or(false)
--
crates/causality-effects/src/capability/unified.rs:    /// Check if the context has a specific effect capability
crates/causality-effects/src/capability/unified.rs-    pub fn has_effect_capability(&self, capability: &EffectCapability) -> bool {
crates/causality-effects/src/capability/unified.rs-        self.effect_capabilities.contains(capability)
crates/causality-effects/src/capability/unified.rs-    }
crates/causality-effects/src/capability/unified.rs-    
crates/causality-effects/src/capability/unified.rs:    /// Check if the context has a specific cross-domain capability
crates/causality-effects/src/capability/unified.rs-    pub fn has_cross_domain_capability(&self, capability: &CrossDomainCapability) -> bool {
crates/causality-effects/src/capability/unified.rs-        self.cross_domain_capabilities.contains(capability)
crates/causality-effects/src/capability/unified.rs-    }
crates/causality-effects/src/capability/unified.rs-    
crates/causality-effects/src/capability/unified.rs:    /// Convert to a set of capability strings for an effect context
crates/causality-effects/src/capability/unified.rs-    pub fn to_capability_strings(&self) -> Vec<String> {
--
crates/causality-effects/src/capability/unified.rs-        
crates/causality-effects/src/capability/unified.rs-        // Add domain capabilities
crates/causality-effects/src/capability/unified.rs-        for (domain_id, caps) in &self.domain_capabilities {
--
crates/causality-effects/src/capability/unified.rs:    /// Convert to an effect context
crates/causality-effects/src/capability/unified.rs-    pub fn to_effect_context(&self, identity: String) -> EffectContext {
--
crates/causality-effects/src/capability/unified.rs-        
crates/causality-effects/src/capability/unified.rs-        // Set identity
crates/causality-effects/src/capability/unified.rs-        context.set_identity(identity);
--
crates/causality-effects/src/capability/unified.rs:/// Unified capability manager for both domain and effect capabilities
crates/causality-effects/src/capability/unified.rs-pub struct UnifiedCapabilityManager {
--
crates/causality-effects/src/capability/unified.rs-    cross_domain_capabilities: RwLock<HashMap<String, HashSet<CrossDomainCapability>>>,
crates/causality-effects/src/capability/unified.rs-}
crates/causality-effects/src/capability/unified.rs-
crates/causality-effects/src/capability/unified.rs-impl UnifiedCapabilityManager {
crates/causality-effects/src/capability/unified.rs:    /// Create a new unified capability manager
crates/causality-effects/src/capability/unified.rs-    pub fn new(domain_manager: Arc<DomainCapabilityManager>) -> Self {
--
crates/causality-effects/src/capability/unified.rs-            domain_manager,
crates/causality-effects/src/capability/unified.rs-            effect_capabilities: RwLock::new(HashMap::new()),
crates/causality-effects/src/capability/unified.rs-            cross_domain_capabilities: RwLock::new(HashMap::new()),
--
crates/causality-effects/src/capability/unified.rs:    /// Register effect capabilities for an identity
crates/causality-effects/src/capability/unified.rs-    pub fn register_effect_capabilities(&self, identity: &str, capabilities: HashSet<EffectCapability>) -> Result<()> {
--
crates/causality-effects/src/capability/unified.rs-        caps.insert(identity.to_string(), capabilities);
crates/causality-effects/src/capability/unified.rs-        Ok(())
crates/causality-effects/src/capability/unified.rs-    }
--
crates/causality-effects/src/capability/unified.rs:    /// Register cross-domain capabilities for an identity
crates/causality-effects/src/capability/unified.rs-    pub fn register_cross_domain_capabilities(&self, identity: &str, capabilities: HashSet<CrossDomainCapability>) -> Result<()> {
--
crates/causality-effects/src/capability/unified.rs-        caps.insert(identity.to_string(), capabilities);
crates/causality-effects/src/capability/unified.rs-        Ok(())
crates/causality-effects/src/capability/unified.rs-    }
--
crates/causality-effects/src/capability/unified.rs:    /// Get effect capabilities for an identity
crates/causality-effects/src/capability/unified.rs-    pub fn get_effect_capabilities(&self, identity: &str) -> Option<HashSet<EffectCapability>> {
crates/causality-effects/src/capability/unified.rs-        let caps = self.effect_capabilities.read().unwrap();
crates/causality-effects/src/capability/unified.rs-        caps.get(identity).cloned()
crates/causality-effects/src/capability/unified.rs-    }
crates/causality-effects/src/capability/unified.rs-    
crates/causality-effects/src/capability/unified.rs:    /// Get cross-domain capabilities for an identity
crates/causality-effects/src/capability/unified.rs-    pub fn get_cross_domain_capabilities(&self, identity: &str) -> Option<HashSet<CrossDomainCapability>> {
crates/causality-effects/src/capability/unified.rs-        let caps = self.cross_domain_capabilities.read().unwrap();
crates/causality-effects/src/capability/unified.rs-        caps.get(identity).cloned()
crates/causality-effects/src/capability/unified.rs-    }
crates/causality-effects/src/capability/unified.rs-    
crates/causality-effects/src/capability/unified.rs:    /// Check if an identity has a specific effect capability
crates/causality-effects/src/capability/unified.rs-    pub fn has_effect_capability(&self, identity: &str, capability: &EffectCapability) -> bool {
--
crates/causality-effects/src/capability/unified.rs-        caps.get(identity)
crates/causality-effects/src/capability/unified.rs-            .map(|set| set.contains(capability))
crates/causality-effects/src/capability/unified.rs-            .unwrap_or(false)
--
crates/causality-effects/src/capability/unified.rs:    /// Check if an identity has a specific cross-domain capability
crates/causality-effects/src/capability/unified.rs-    pub fn has_cross_domain_capability(&self, identity: &str, capability: &CrossDomainCapability) -> bool {
--
crates/causality-effects/src/capability/unified.rs-        caps.get(identity)
crates/causality-effects/src/capability/unified.rs-            .map(|set| set.contains(capability))
crates/causality-effects/src/capability/unified.rs-            .unwrap_or(false)
--
crates/causality-effects/src/capability/unified.rs:    /// Create a unified capability context for an identity
crates/causality-effects/src/capability/unified.rs-    pub fn create_context(&self, identity: &str) -> Result<UnifiedCapabilityContext> {
--
crates/causality-effects/src/capability/unified.rs-        
crates/causality-effects/src/capability/unified.rs-        // Add effect capabilities
crates/causality-effects/src/capability/unified.rs-        if let Some(effect_caps) = self.get_effect_capabilities(identity) {
--
crates/causality-effects/src/capability/unified.rs:    /// Convert a domain capability to an effect capability
crates/causality-effects/src/capability/unified.rs-    pub fn map_domain_to_effect_capability(&self, domain_cap: &DomainCapability) -> Option<EffectCapability> {
--
crates/causality-effects/src/capability/unified.rs-            DomainCapability::SendTransaction => Some(EffectCapability::SubmitTransaction),
crates/causality-effects/src/capability/unified.rs-            DomainCapability::SignTransaction => Some(EffectCapability::SignTransaction),
crates/causality-effects/src/capability/unified.rs-            DomainCapability::ReadState => Some(EffectCapability::ReadResource),
--
crates/causality-effects/src/capability/unified.rs:    /// Convert an effect capability to a domain capability
crates/causality-effects/src/capability/unified.rs-    pub fn map_effect_to_domain_capability(&self, effect_cap: &EffectCapability) -> Option<DomainCapability> {
--
crates/causality-effects/src/capability/unified.rs-            EffectCapability::SubmitTransaction => Some(DomainCapability::SendTransaction),
crates/causality-effects/src/capability/unified.rs-            EffectCapability::SignTransaction => Some(DomainCapability::SignTransaction),
crates/causality-effects/src/capability/unified.rs-            EffectCapability::ReadResource => Some(DomainCapability::ReadState),
--
crates/causality-effects/src/capability/unified.rs:    /// Check if an effect requires a specific domain capability
crates/causality-effects/src/capability/unified.rs-    pub fn effect_requires_domain_capability(&self, effect_type: &EffectType, domain_id: &str) -> Option<DomainCapability> {
--
crates/causality-effects/src/capability/unified.rs-            EffectType::Create => Some(DomainCapability::WriteState),
crates/causality-effects/src/capability/unified.rs-            EffectType::Read => Some(DomainCapability::ReadState),
crates/causality-effects/src/capability/unified.rs-            EffectType::Update => Some(DomainCapability::WriteState),
--
crates/causality-effects/src/capability/unified.rs:/// Trait for effects that require domain capabilities
crates/causality-effects/src/capability/unified.rs-pub trait DomainCapabilityAware {
--
crates/causality-effects/src/capability/unified.rs-            if !context.has_domain_capability(&domain_id, &capability) {
crates/causality-effects/src/capability/unified.rs-                return false;
crates/causality-effects/src/capability/unified.rs-            }
--
crates/causality-effects/src/capability/unified.rs:/// Extension trait for effect context to support unified capabilities
crates/causality-effects/src/capability/unified.rs-pub trait EffectContextCapabilityExt {
--
crates/causality-effects/src/capability/unified.rs-// Implementation of the extension trait for EffectContext
crates/causality-effects/src/capability/unified.rs-impl EffectContextCapabilityExt for EffectContext {
--
crates/causality-effects/src/empty_effect.rs:/// A simple effect that does nothing, used as a placeholder
crates/causality-effects/src/empty_effect.rs-#[derive(Debug, BorshSerialize, BorshDeserialize)]
crates/causality-effects/src/empty_effect.rs-pub struct SimpleEmptyEffect {
--
crates/causality-effects/src/empty_effect.rs-    description: String,
crates/causality-effects/src/empty_effect.rs-}
--
crates/causality-effects/src/boundary.rs:/// Defines the execution environment of an effect
crates/causality-effects/src/boundary.rs-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
crates/causality-effects/src/boundary.rs-pub enum ExecutionBoundary {
--
crates/causality-effects/src/boundary.rs-    OutsideSystem,
crates/causality-effects/src/boundary.rs-}
crates/causality-effects/src/boundary.rs-
crates/causality-effects/src/boundary.rs:/// Defines the execution environment for a specific blockchain
crates/causality-effects/src/boundary.rs-#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
crates/causality-effects/src/boundary.rs-pub enum ChainBoundary {
--
crates/causality-effects/src/boundary.rs-    Custom(String),
crates/causality-effects/src/boundary.rs-}
crates/causality-effects/src/boundary.rs-
crates/causality-effects/src/boundary.rs:/// Represents the context in which an effect is executed
crates/causality-effects/src/boundary.rs-#[derive(Debug, Clone, Serialize, Deserialize, BorshSerialize, BorshDeserialize)]
crates/causality-effects/src/boundary.rs-pub struct EffectContext {
crates/causality-effects/src/boundary.rs:    /// Unique identifier for this effect execution
crates/causality-effects/src/boundary.rs-    pub execution_id: ContentId,
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// The execution boundary (inside or outside system)
crates/causality-effects/src/boundary.rs-    pub boundary: ExecutionBoundary,
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// The chain boundary if relevant
crates/causality-effects/src/boundary.rs-    pub chain: Option<ChainBoundary>,
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// The invoker of the effect
crates/causality-effects/src/boundary.rs-    pub invoker: Address,
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// Capabilities provided to the effect
crates/causality-effects/src/boundary.rs-    pub capabilities: Vec<CapabilityRef>,
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// Custom context parameters
crates/causality-effects/src/boundary.rs-    pub parameters: HashMap<String, String>,
--
crates/causality-effects/src/boundary.rs-        let mut hashable_context = self.clone();
crates/causality-effects/src/boundary.rs-        hashable_context.execution_id = ContentId::nil(); // Use nil ContentId for hashing
crates/causality-effects/src/boundary.rs-        
--
crates/causality-effects/src/boundary.rs:    /// Create a new effect context with the given boundary
crates/causality-effects/src/boundary.rs-    pub fn new(boundary: ExecutionBoundary) -> Self {
--
crates/causality-effects/src/boundary.rs-            execution_id: ContentId::nil(), // Temporary placeholder
crates/causality-effects/src/boundary.rs-            boundary,
crates/causality-effects/src/boundary.rs-            chain: None,
--
crates/causality-effects/src/boundary.rs:    /// Create a new effect context for inside-system execution
crates/causality-effects/src/boundary.rs-    pub fn new_inside(invoker: Address) -> Self {
--
crates/causality-effects/src/boundary.rs-            execution_id: ContentId::nil(), // Temporary placeholder
crates/causality-effects/src/boundary.rs-            boundary: ExecutionBoundary::InsideSystem,
crates/causality-effects/src/boundary.rs-            chain: None,
--
crates/causality-effects/src/boundary.rs:    /// Create a new effect context for outside-system execution
crates/causality-effects/src/boundary.rs-    pub fn new_outside(invoker: Address) -> Self {
--
crates/causality-effects/src/boundary.rs-            execution_id: ContentId::nil(), // Temporary placeholder
crates/causality-effects/src/boundary.rs-            boundary: ExecutionBoundary::OutsideSystem,
crates/causality-effects/src/boundary.rs-            chain: None,
--
crates/causality-effects/src/boundary.rs:    /// Set the chain boundary
crates/causality-effects/src/boundary.rs-    pub fn with_chain(mut self, chain: ChainBoundary) -> Self {
crates/causality-effects/src/boundary.rs-        self.chain = Some(chain);
crates/causality-effects/src/boundary.rs-        self
crates/causality-effects/src/boundary.rs-    }
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// Add a capability to the context
crates/causality-effects/src/boundary.rs-    pub fn with_capability(mut self, capability: CapabilityRef) -> Self {
crates/causality-effects/src/boundary.rs-        self.capabilities.push(capability);
crates/causality-effects/src/boundary.rs-        self
crates/causality-effects/src/boundary.rs-    }
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// Add multiple capabilities to the context
crates/causality-effects/src/boundary.rs-    pub fn with_capabilities(mut self, capabilities: Vec<CapabilityRef>) -> Self {
crates/causality-effects/src/boundary.rs-        self.capabilities.extend(capabilities);
crates/causality-effects/src/boundary.rs-        self
crates/causality-effects/src/boundary.rs-    }
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// Add a parameter to the context
crates/causality-effects/src/boundary.rs-    pub fn with_parameter(mut self, key: &str, value: &str) -> Self {
--
crates/causality-effects/src/boundary.rs-    }
crates/causality-effects/src/boundary.rs-}
--
crates/causality-effects/src/boundary.rs:/// Represents data crossing a system boundary
crates/causality-effects/src/boundary.rs-#[derive(Debug, Clone, Serialize, Deserialize)]
crates/causality-effects/src/boundary.rs-pub struct BoundaryCrossing<T> {
crates/causality-effects/src/boundary.rs:    /// The context of the boundary crossing
crates/causality-effects/src/boundary.rs-    pub context: EffectContext,
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// The payload being transferred across the boundary
crates/causality-effects/src/boundary.rs-    pub payload: T,
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// Authentication information for the crossing
crates/causality-effects/src/boundary.rs-    pub auth: BoundaryAuthentication,
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// Timestamp of the crossing
crates/causality-effects/src/boundary.rs-    pub timestamp: u64,
crates/causality-effects/src/boundary.rs-}
crates/causality-effects/src/boundary.rs-
crates/causality-effects/src/boundary.rs:/// Types of authentication used for boundary crossings
crates/causality-effects/src/boundary.rs-#[derive(Debug, Clone, Serialize, Deserialize)]
crates/causality-effects/src/boundary.rs-pub enum BoundaryAuthentication {
--
crates/causality-effects/src/boundary.rs-    None,
crates/causality-effects/src/boundary.rs-}
crates/causality-effects/src/boundary.rs-
crates/causality-effects/src/boundary.rs-impl<T: Serialize> BoundaryCrossing<T> {
crates/causality-effects/src/boundary.rs:    /// Create a new boundary crossing from inside to outside
crates/causality-effects/src/boundary.rs-    pub fn new_outbound(context: EffectContext, payload: T) -> Self {
--
crates/causality-effects/src/boundary.rs-            context,
crates/causality-effects/src/boundary.rs-            payload,
crates/causality-effects/src/boundary.rs-            auth: BoundaryAuthentication::None,
--
crates/causality-effects/src/boundary.rs:    /// Create a new boundary crossing from outside to inside
crates/causality-effects/src/boundary.rs-    pub fn new_inbound(context: EffectContext, payload: T) -> Self {
--
crates/causality-effects/src/boundary.rs-            context,
crates/causality-effects/src/boundary.rs-            payload,
crates/causality-effects/src/boundary.rs-            auth: BoundaryAuthentication::None,
--
crates/causality-effects/src/boundary.rs:    /// Set the authentication method for the boundary crossing
crates/causality-effects/src/boundary.rs-    pub fn with_auth(mut self, auth: BoundaryAuthentication) -> Self {
crates/causality-effects/src/boundary.rs-        self.auth = auth;
crates/causality-effects/src/boundary.rs-        self
crates/causality-effects/src/boundary.rs-    }
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// Serialize the boundary crossing for transport
crates/causality-effects/src/boundary.rs-    pub fn serialize(&self) -> Result<Vec<u8>, serde_json::Error> {
--
crates/causality-effects/src/boundary.rs-    }
crates/causality-effects/src/boundary.rs-}
crates/causality-effects/src/boundary.rs-
--
crates/causality-effects/src/boundary.rs:    /// Deserialize a boundary crossing from bytes
crates/causality-effects/src/boundary.rs-    pub fn deserialize(data: &[u8]) -> Result<Self, serde_json::Error> {
crates/causality-effects/src/boundary.rs-        serde_json::from_slice(data)
crates/causality-effects/src/boundary.rs-    }
crates/causality-effects/src/boundary.rs-}
crates/causality-effects/src/boundary.rs-
crates/causality-effects/src/boundary.rs:/// Trait for types that can be invoked across system boundaries
crates/causality-effects/src/boundary.rs-pub trait BoundaryCrossingHandler<T, R> {
--
crates/causality-effects/src/boundary.rs-    fn create_outbound(&self, context: EffectContext, payload: T) -> BoundaryCrossing<T>;
crates/causality-effects/src/boundary.rs-}
crates/causality-effects/src/boundary.rs-
crates/causality-effects/src/boundary.rs:/// Errors that can occur during boundary crossings
crates/causality-effects/src/boundary.rs-#[derive(Debug, thiserror::Error)]
crates/causality-effects/src/boundary.rs-pub enum BoundaryError {
--
crates/causality-effects/src/boundary.rs-    AuthenticationFailed(String),
crates/causality-effects/src/boundary.rs-    
--
crates/causality-effects/src/boundary.rs:/// A registry for tracking boundary crossings for auditing purposes
crates/causality-effects/src/boundary.rs-#[derive(Default)]
crates/causality-effects/src/boundary.rs-pub struct BoundaryCrossingRegistry {
crates/causality-effects/src/boundary.rs-    crossings: HashMap<ContentId, BoundaryCrossingRecord>,
crates/causality-effects/src/boundary.rs-}
crates/causality-effects/src/boundary.rs-
crates/causality-effects/src/boundary.rs:/// A record of a boundary crossing
crates/causality-effects/src/boundary.rs-#[derive(Debug, Clone, Serialize, Deserialize)]
crates/causality-effects/src/boundary.rs-pub struct BoundaryCrossingRecord {
crates/causality-effects/src/boundary.rs:    /// The unique ID of the crossing
crates/causality-effects/src/boundary.rs-    pub id: ContentId,
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// The direction of the crossing
crates/causality-effects/src/boundary.rs-    pub direction: CrossingDirection,
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// The boundary that was crossed
crates/causality-effects/src/boundary.rs-    pub boundary: ExecutionBoundary,
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// The chain involved (if any)
crates/causality-effects/src/boundary.rs-    pub chain: Option<ChainBoundary>,
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// The invoker of the crossing
crates/causality-effects/src/boundary.rs-    pub invoker: Address,
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// The timestamp of the crossing
crates/causality-effects/src/boundary.rs-    pub timestamp: u64,
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// Whether the crossing was successful
crates/causality-effects/src/boundary.rs-    pub success: bool,
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// Error message if the crossing failed
crates/causality-effects/src/boundary.rs-    pub error: Option<String>,
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// The type of payload
crates/causality-effects/src/boundary.rs-    pub payload_type: String,
crates/causality-effects/src/boundary.rs-}
crates/causality-effects/src/boundary.rs-
crates/causality-effects/src/boundary.rs:/// The direction of a boundary crossing
crates/causality-effects/src/boundary.rs-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
crates/causality-effects/src/boundary.rs-pub enum CrossingDirection {
--
crates/causality-effects/src/boundary.rs-    Outbound,
crates/causality-effects/src/boundary.rs-}
crates/causality-effects/src/boundary.rs-
crates/causality-effects/src/boundary.rs-impl BoundaryCrossingRegistry {
crates/causality-effects/src/boundary.rs:    /// Create a new boundary crossing registry
crates/causality-effects/src/boundary.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/boundary.rs-            crossings: HashMap::new(),
crates/causality-effects/src/boundary.rs-        }
crates/causality-effects/src/boundary.rs-    }
--
crates/causality-effects/src/boundary.rs:    /// Record a boundary crossing
crates/causality-effects/src/boundary.rs-    pub fn record<T>(&mut self, crossing: &BoundaryCrossing<T>, direction: CrossingDirection, success: bool, error: Option<String>) 
--
crates/causality-effects/src/boundary.rs-        T: std::any::Any,
crates/causality-effects/src/boundary.rs-    {
crates/causality-effects/src/boundary.rs-        let record = BoundaryCrossingRecord {
--
crates/causality-effects/src/boundary.rs:    /// Get a boundary crossing record by ID
crates/causality-effects/src/boundary.rs-    pub fn get(&self, id: &ContentId) -> Option<&BoundaryCrossingRecord> {
crates/causality-effects/src/boundary.rs-        self.crossings.get(id)
crates/causality-effects/src/boundary.rs-    }
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// Get all boundary crossing records
crates/causality-effects/src/boundary.rs-    pub fn get_all(&self) -> Vec<&BoundaryCrossingRecord> {
crates/causality-effects/src/boundary.rs-        self.crossings.values().collect()
crates/causality-effects/src/boundary.rs-    }
crates/causality-effects/src/boundary.rs-    
crates/causality-effects/src/boundary.rs:    /// Get all boundary crossing records for a specific direction
crates/causality-effects/src/boundary.rs-    pub fn get_by_direction(&self, direction: CrossingDirection) -> Vec<&BoundaryCrossingRecord> {
--
crates/causality-effects/src/boundary.rs-            .filter(|record| record.direction == direction)
crates/causality-effects/src/boundary.rs-            .collect()
crates/causality-effects/src/boundary.rs-    }
--
crates/causality-effects/src/boundary.rs:    /// Get all boundary crossing records for a specific invoker
crates/causality-effects/src/boundary.rs-    pub fn get_by_invoker(&self, invoker: &Address) -> Vec<&BoundaryCrossingRecord> {
--
crates/causality-effects/src/boundary.rs-            .collect()
crates/causality-effects/src/boundary.rs-    }
--
crates/causality-effects/src/effect.rs:/// Type of effect
crates/causality-effects/src/effect.rs-#[derive(Debug, Clone, PartialEq, Eq, BorshSerialize, BorshDeserialize)]
crates/causality-effects/src/effect.rs-pub enum EffectType {
--
crates/causality-effects/src/effect.rs-impl std::fmt::Display for EffectType {
crates/causality-effects/src/effect.rs-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
--
crates/causality-effects/src/effect.rs:/// An effect that can be executed
crates/causality-effects/src/effect.rs-#[derive(Debug, Clone, PartialEq, Eq, BorshSerialize, BorshDeserialize)]
crates/causality-effects/src/effect.rs-pub struct Effect {
--
crates/causality-effects/src/effect.rs-    resource_id: Option<ContentId>,
crates/causality-effects/src/effect.rs-}
crates/causality-effects/src/effect.rs-
crates/causality-effects/src/effect.rs-impl Effect {
crates/causality-effects/src/effect.rs:    /// Create a new effect
crates/causality-effects/src/effect.rs-    pub fn new(effect_type: EffectType) -> Self {
--
crates/causality-effects/src/effect.rs-            effect_type,
crates/causality-effects/src/effect.rs-            parameters: HashMap::new(),
crates/causality-effects/src/effect.rs-            resource_id: None,
--
crates/causality-effects/src/effect.rs:    /// Create a new effect with a resource ID
crates/causality-effects/src/effect.rs-    pub fn with_resource(effect_type: EffectType, resource_id: ContentId) -> Self {
--
crates/causality-effects/src/effect.rs-            effect_type,
crates/causality-effects/src/effect.rs-            parameters: HashMap::new(),
crates/causality-effects/src/effect.rs-            resource_id: Some(resource_id),
--
crates/causality-effects/src/effect.rs:    /// Get the effect type
crates/causality-effects/src/effect.rs-    pub fn effect_type(&self) -> &EffectType {
crates/causality-effects/src/effect.rs-        &self.effect_type
crates/causality-effects/src/effect.rs-    }
crates/causality-effects/src/effect.rs-    
crates/causality-effects/src/effect.rs:    /// Set a parameter
crates/causality-effects/src/effect.rs-    pub fn set_parameter(&mut self, key: impl Into<String>, value: impl Into<Vec<u8>>) {
crates/causality-effects/src/effect.rs-        self.parameters.insert(key.into(), value.into());
crates/causality-effects/src/effect.rs-    }
crates/causality-effects/src/effect.rs-    
crates/causality-effects/src/effect.rs:    /// Get a parameter
crates/causality-effects/src/effect.rs-    pub fn get_parameter(&self, key: &str) -> Option<&[u8]> {
crates/causality-effects/src/effect.rs-        self.parameters.get(key).map(|v| v.as_slice())
crates/causality-effects/src/effect.rs-    }
crates/causality-effects/src/effect.rs-    
crates/causality-effects/src/effect.rs:    /// Set the resource ID
crates/causality-effects/src/effect.rs-    pub fn set_resource_id(&mut self, resource_id: ContentId) {
crates/causality-effects/src/effect.rs-        self.resource_id = Some(resource_id);
crates/causality-effects/src/effect.rs-    }
crates/causality-effects/src/effect.rs-    
crates/causality-effects/src/effect.rs:    /// Get the resource ID
crates/causality-effects/src/effect.rs-    pub fn resource_id(&self) -> Option<&ContentId> {
--
crates/causality-effects/src/effect.rs-}
crates/causality-effects/src/effect.rs-
--
crates/causality-effects/src/effect.rs:/// Result of effect execution
crates/causality-effects/src/effect.rs-#[derive(Debug, Clone, PartialEq, Eq, BorshSerialize, BorshDeserialize)]
crates/causality-effects/src/effect.rs-pub struct EffectOutcome {
--
crates/causality-effects/src/effect.rs-    error: Option<String>,
crates/causality-effects/src/effect.rs-}
crates/causality-effects/src/effect.rs-
crates/causality-effects/src/effect.rs-impl EffectOutcome {
crates/causality-effects/src/effect.rs:    /// Create a successful outcome
crates/causality-effects/src/effect.rs-    pub fn success() -> Self {
--
crates/causality-effects/src/effect.rs-            success: true,
crates/causality-effects/src/effect.rs-            result: None,
crates/causality-effects/src/effect.rs-            error: None,
--
crates/causality-effects/src/effect.rs:    /// Create a successful outcome with result data
crates/causality-effects/src/effect.rs-    pub fn with_result(result: Vec<u8>) -> Self {
--
crates/causality-effects/src/effect.rs-            success: true,
crates/causality-effects/src/effect.rs-            result: Some(result),
crates/causality-effects/src/effect.rs-            error: None,
--
crates/causality-effects/src/effect.rs:    /// Create a failed outcome with an error message
crates/causality-effects/src/effect.rs-    pub fn failure(error: impl Into<String>) -> Self {
--
crates/causality-effects/src/effect.rs-            success: false,
crates/causality-effects/src/effect.rs-            result: None,
crates/causality-effects/src/effect.rs-            error: Some(error.into()),
--
crates/causality-effects/src/effect.rs:    /// Check if the outcome was successful
crates/causality-effects/src/effect.rs-    pub fn is_success(&self) -> bool {
crates/causality-effects/src/effect.rs-        self.success
crates/causality-effects/src/effect.rs-    }
crates/causality-effects/src/effect.rs-    
crates/causality-effects/src/effect.rs:    /// Get the result data
crates/causality-effects/src/effect.rs-    pub fn result(&self) -> Option<&[u8]> {
crates/causality-effects/src/effect.rs-        self.result.as_ref().map(|v| v.as_slice())
crates/causality-effects/src/effect.rs-    }
crates/causality-effects/src/effect.rs-    
crates/causality-effects/src/effect.rs:    /// Get the error message
crates/causality-effects/src/effect.rs-    pub fn error(&self) -> Option<&str> {
--
crates/causality-effects/src/effect.rs-    }
crates/causality-effects/src/effect.rs-}
crates/causality-effects/src/effect.rs-
--
crates/causality-effects/src/effect.rs:/// A registry for content-addressed effects
crates/causality-effects/src/effect.rs-pub struct EffectRegistry {
--
crates/causality-effects/src/effect.rs-    effects: HashMap<ContentId, Effect>,
crates/causality-effects/src/effect.rs-}
crates/causality-effects/src/effect.rs-
crates/causality-effects/src/effect.rs-impl EffectRegistry {
crates/causality-effects/src/effect.rs:    /// Create a new empty registry
crates/causality-effects/src/effect.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/effect.rs-            effects: HashMap::new(),
crates/causality-effects/src/effect.rs-        }
crates/causality-effects/src/effect.rs-    }
--
crates/causality-effects/src/effect.rs:    /// Register an effect
crates/causality-effects/src/effect.rs-    pub fn register(&mut self, effect: Effect) -> ContentId {
--
crates/causality-effects/src/effect.rs-        self.effects.insert(content_id.clone(), effect);
crates/causality-effects/src/effect.rs-        content_id
crates/causality-effects/src/effect.rs-    }
--
crates/causality-effects/src/effect.rs:    /// Get an effect by its content ID
crates/causality-effects/src/effect.rs-    pub fn get(&self, content_id: &ContentId) -> Option<&Effect> {
crates/causality-effects/src/effect.rs-        self.effects.get(content_id)
crates/causality-effects/src/effect.rs-    }
crates/causality-effects/src/effect.rs-    
crates/causality-effects/src/effect.rs:    /// Remove an effect by its content ID
crates/causality-effects/src/effect.rs-    pub fn remove(&mut self, content_id: &ContentId) -> Option<Effect> {
crates/causality-effects/src/effect.rs-        self.effects.remove(content_id)
crates/causality-effects/src/effect.rs-    }
crates/causality-effects/src/effect.rs-    
crates/causality-effects/src/effect.rs:    /// Check if the registry contains an effect
crates/causality-effects/src/effect.rs-    pub fn contains(&self, content_id: &ContentId) -> bool {
crates/causality-effects/src/effect.rs-        self.effects.contains_key(content_id)
crates/causality-effects/src/effect.rs-    }
crates/causality-effects/src/effect.rs-    
crates/causality-effects/src/effect.rs:    /// Get the number of effects in the registry
crates/causality-effects/src/effect.rs-    pub fn len(&self) -> usize {
crates/causality-effects/src/effect.rs-        self.effects.len()
crates/causality-effects/src/effect.rs-    }
crates/causality-effects/src/effect.rs-    
crates/causality-effects/src/effect.rs:    /// Check if the registry is empty
crates/causality-effects/src/effect.rs-    pub fn is_empty(&self) -> bool {
crates/causality-effects/src/effect.rs-        self.effects.is_empty()
crates/causality-effects/src/effect.rs-    }
crates/causality-effects/src/effect.rs-    
crates/causality-effects/src/effect.rs:    /// Get an iterator over all effects
crates/causality-effects/src/effect.rs-    pub fn iter(&self) -> impl Iterator<Item = (&ContentId, &Effect)> {
--
crates/causality-effects/src/effect.rs-}
crates/causality-effects/src/effect.rs-
--
crates/causality-effects/src/executor.rs:/// Value type for the execution environment
crates/causality-effects/src/executor.rs-#[derive(Debug, Clone, Serialize, Deserialize)]
crates/causality-effects/src/executor.rs-pub enum Value {
--
crates/causality-effects/src/executor.rs-    CodeRef(ContentHash),
crates/causality-effects/src/executor.rs-}
crates/causality-effects/src/executor.rs-
crates/causality-effects/src/executor.rs-impl Value {
crates/causality-effects/src/executor.rs:    /// Convert a value to a boolean
crates/causality-effects/src/executor.rs-    pub fn as_bool(&self) -> Option<bool> {
--
crates/causality-effects/src/executor.rs-            Value::Bool(b) => Some(*b),
crates/causality-effects/src/executor.rs-            _ => None,
crates/causality-effects/src/executor.rs-        }
--
crates/causality-effects/src/executor.rs:    /// Convert a value to an integer
crates/causality-effects/src/executor.rs-    pub fn as_int(&self) -> Option<i64> {
--
crates/causality-effects/src/executor.rs-            Value::Int(i) => Some(*i),
crates/causality-effects/src/executor.rs-            Value::Float(f) => Some(*f as i64),
crates/causality-effects/src/executor.rs-            _ => None,
--
crates/causality-effects/src/executor.rs:    /// Convert a value to a float
crates/causality-effects/src/executor.rs-    pub fn as_float(&self) -> Option<f64> {
--
crates/causality-effects/src/executor.rs-            Value::Int(i) => Some(*i as f64),
crates/causality-effects/src/executor.rs-            Value::Float(f) => Some(*f),
crates/causality-effects/src/executor.rs-            _ => None,
--
crates/causality-effects/src/executor.rs:    /// Convert a value to a string
crates/causality-effects/src/executor.rs-    pub fn as_string(&self) -> Option<&str> {
--
crates/causality-effects/src/executor.rs-            Value::String(s) => Some(s),
crates/causality-effects/src/executor.rs-            _ => None,
crates/causality-effects/src/executor.rs-        }
--
crates/causality-effects/src/executor.rs:    /// Convert a value to bytes
crates/causality-effects/src/executor.rs-    pub fn as_bytes(&self) -> Option<&[u8]> {
--
crates/causality-effects/src/executor.rs-            Value::Bytes(b) => Some(b),
crates/causality-effects/src/executor.rs-            _ => None,
crates/causality-effects/src/executor.rs-        }
--
crates/causality-effects/src/executor.rs:    /// Convert a value to an array
crates/causality-effects/src/executor.rs-    pub fn as_array(&self) -> Option<&[Value]> {
--
crates/causality-effects/src/executor.rs-            Value::Array(a) => Some(a),
crates/causality-effects/src/executor.rs-            _ => None,
crates/causality-effects/src/executor.rs-        }
--
crates/causality-effects/src/executor.rs:    /// Convert a value to a map
crates/causality-effects/src/executor.rs-    pub fn as_map(&self) -> Option<&HashMap<String, Value>> {
--
crates/causality-effects/src/executor.rs-            Value::Map(m) => Some(m),
crates/causality-effects/src/executor.rs-            _ => None,
crates/causality-effects/src/executor.rs-        }
--
crates/causality-effects/src/executor.rs:    /// Check if the value is null
crates/causality-effects/src/executor.rs-    pub fn is_null(&self) -> bool {
--
crates/causality-effects/src/executor.rs-    }
crates/causality-effects/src/executor.rs-}
crates/causality-effects/src/executor.rs-
crates/causality-effects/src/executor.rs:/// Content data for context ID generation
crates/causality-effects/src/executor.rs-#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
crates/causality-effects/src/executor.rs-pub struct ContextIdContentData {
crates/causality-effects/src/executor.rs:    /// Creation timestamp
crates/causality-effects/src/executor.rs-    pub timestamp: u64,
crates/causality-effects/src/executor.rs-    
crates/causality-effects/src/executor.rs:    /// Creator information (optional)
crates/causality-effects/src/executor.rs-    pub creator: Option<String>,
crates/causality-effects/src/executor.rs-    
crates/causality-effects/src/executor.rs:    /// Random nonce for uniqueness
crates/causality-effects/src/executor.rs-    pub nonce: [u8; 16],
--
crates/causality-effects/src/executor.rs-impl ContentAddressed for ContextIdContentData {
crates/causality-effects/src/executor.rs-    fn content_hash(&self) -> Result<ContentId> {
--
crates/causality-effects/src/executor.rs:/// A unique identifier for an execution context
crates/causality-effects/src/executor.rs-#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
crates/causality-effects/src/executor.rs-pub struct ContextId(pub String);
crates/causality-effects/src/executor.rs-
crates/causality-effects/src/executor.rs-impl ContextId {
crates/causality-effects/src/executor.rs:    /// Create a new random context ID
crates/causality-effects/src/executor.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/executor.rs-        let now = SystemTime::now()
crates/causality-effects/src/executor.rs-            .duration_since(UNIX_EPOCH)
crates/causality-effects/src/executor.rs-            .unwrap_or_default()
--
crates/causality-effects/src/executor.rs:    /// Create a context ID from a string
crates/causality-effects/src/executor.rs-    pub fn from_string(id: &str) -> Self {
crates/causality-effects/src/executor.rs-        ContextId(id.to_string())
crates/causality-effects/src/executor.rs-    }
crates/causality-effects/src/executor.rs-    
crates/causality-effects/src/executor.rs:    /// Create a context ID with creator information
crates/causality-effects/src/executor.rs-    pub fn with_creator(creator: &str) -> Self {
--
crates/causality-effects/src/executor.rs-            .unwrap_or_default()
crates/causality-effects/src/executor.rs-            .as_secs();
--
crates/causality-effects/src/executor.rs:/// Execution event emitted during code execution
crates/causality-effects/src/executor.rs-#[derive(Debug, Clone, Serialize, Deserialize)]
crates/causality-effects/src/executor.rs-pub enum ExecutionEvent {
--
crates/causality-effects/src/executor.rs-        timestamp: chrono::DateTime<chrono::Utc>,
crates/causality-effects/src/executor.rs-    },
crates/causality-effects/src/executor.rs-}
crates/causality-effects/src/executor.rs-
crates/causality-effects/src/executor.rs:/// Security sandbox for code execution
crates/causality-effects/src/executor.rs-pub trait SecuritySandbox: Send + Sync {
--
crates/causality-effects/src/executor.rs:    /// Get the maximum memory allowed (in bytes)
crates/causality-effects/src/executor.rs-    fn max_memory(&self) -> u64;
crates/causality-effects/src/executor.rs-}
crates/causality-effects/src/executor.rs-
crates/causality-effects/src/executor.rs:/// Default security sandbox implementation
crates/causality-effects/src/executor.rs-pub struct DefaultSecuritySandbox {
--
crates/causality-effects/src/executor.rs-    max_memory: u64,
crates/causality-effects/src/executor.rs-}
crates/causality-effects/src/executor.rs-
--
crates/causality-effects/src/executor.rs:    /// Create a new default security sandbox
crates/causality-effects/src/executor.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/executor.rs-            max_execution_time: Duration::from_secs(5),
crates/causality-effects/src/executor.rs-            max_memory: 1024 * 1024 * 10, // 10 MB
crates/causality-effects/src/executor.rs-        }
--
crates/causality-effects/src/executor.rs:    /// Create a new security sandbox with custom limits
crates/causality-effects/src/executor.rs-    pub fn with_limits(max_execution_time: Duration, max_memory: u64) -> Self {
--
crates/causality-effects/src/executor.rs-            max_execution_time,
crates/causality-effects/src/executor.rs-            max_memory,
crates/causality-effects/src/executor.rs-        }
--
crates/causality-effects/src/executor.rs:/// Execution context for content-addressable code
crates/causality-effects/src/executor.rs-pub struct ExecutionContext {
crates/causality-effects/src/executor.rs:    /// Unique identifier for this context
crates/causality-effects/src/executor.rs-    pub id: ContextId,
--
crates/causality-effects/src/executor.rs-    event_listener: Option<Box<dyn Fn(ExecutionEvent) + Send + Sync>>,
crates/causality-effects/src/executor.rs-}
crates/causality-effects/src/executor.rs-
crates/causality-effects/src/executor.rs:/// A single frame in the call stack
crates/causality-effects/src/executor.rs-#[derive(Debug, Clone)]
crates/causality-effects/src/executor.rs-pub struct CallFrame {
crates/causality-effects/src/executor.rs:    /// Code hash
crates/causality-effects/src/executor.rs-    pub code_hash: ContentHash,
crates/causality-effects/src/executor.rs:    /// Function name
crates/causality-effects/src/executor.rs-    pub name: Option<String>,
crates/causality-effects/src/executor.rs:    /// Arguments
crates/causality-effects/src/executor.rs-    pub args: Vec<Value>,
crates/causality-effects/src/executor.rs:    /// Start time
crates/causality-effects/src/executor.rs-    pub start_time: Instant,
crates/causality-effects/src/executor.rs-}
crates/causality-effects/src/executor.rs-
crates/causality-effects/src/executor.rs-impl ExecutionContext {
crates/causality-effects/src/executor.rs:    /// Create a new execution context
crates/causality-effects/src/executor.rs-    pub fn new(security: Arc<dyn SecuritySandbox>) -> Self {
--
crates/causality-effects/src/executor.rs-            id: ContextId::new(),
crates/causality-effects/src/executor.rs-            variables: HashMap::new(),
crates/causality-effects/src/executor.rs-            call_stack: Vec::new(),
--
crates/causality-effects/src/executor.rs:    /// Set an event listener
crates/causality-effects/src/executor.rs-    pub fn set_event_listener<F>(&mut self, listener: F)
--
crates/causality-effects/src/executor.rs-        F: Fn(ExecutionEvent) + Send + Sync + 'static,
crates/causality-effects/src/executor.rs-    {
crates/causality-effects/src/executor.rs-        self.event_listener = Some(Box::new(listener));
--
crates/causality-effects/src/executor.rs:    /// Emit an execution event
crates/causality-effects/src/executor.rs-    pub fn emit_event(&self, event: ExecutionEvent) {
--
crates/causality-effects/src/executor.rs-            listener(event);
crates/causality-effects/src/executor.rs-        }
crates/causality-effects/src/executor.rs-    }
--
crates/causality-effects/src/executor.rs:    /// Get a variable from the context
crates/causality-effects/src/executor.rs-    pub fn get_variable(&self, name: &str) -> Option<&Value> {
crates/causality-effects/src/executor.rs-        self.variables.get(name)
crates/causality-effects/src/executor.rs-    }
crates/causality-effects/src/executor.rs-    
crates/causality-effects/src/executor.rs:    /// Set a variable in the context
crates/causality-effects/src/executor.rs-    pub fn set_variable(&mut self, name: &str, value: Value) {
--
crates/causality-effects/src/executor.rs-        
crates/causality-effects/src/executor.rs-        // Emit assignment event
crates/causality-effects/src/executor.rs-        self.emit_event(ExecutionEvent::Assignment {
--
crates/causality-effects/src/executor.rs:    /// Push a call frame onto the stack
crates/causality-effects/src/executor.rs-    pub fn push_call(&mut self, code_hash: ContentHash, name: Option<String>, args: Vec<Value>) {
--
crates/causality-effects/src/executor.rs-            code_hash,
crates/causality-effects/src/executor.rs-            name: name.clone(),
crates/causality-effects/src/executor.rs-            args: args.clone(),
--
crates/causality-effects/src/executor.rs:    /// Pop a call frame from the stack and return the elapsed time
crates/causality-effects/src/executor.rs-    pub fn pop_call(&mut self, result: Value) -> Duration {
--
crates/causality-effects/src/executor.rs-            let duration = frame.start_time.elapsed();
crates/causality-effects/src/executor.rs-            
crates/causality-effects/src/executor.rs-            // Emit call end event
--
crates/causality-effects/src/executor.rs:    /// Check if the context has exceeded its execution time limit
crates/causality-effects/src/executor.rs-    pub fn check_timeout(&self) -> Result<()> {
--
crates/causality-effects/src/executor.rs-        let max_time = self.security.max_execution_time();
crates/causality-effects/src/executor.rs-        
crates/causality-effects/src/executor.rs-        if elapsed > max_time {
--
crates/causality-effects/src/executor.rs:    /// Check if an operation is allowed
crates/causality-effects/src/executor.rs-    pub fn check_operation(&self, operation: &str, args: &[Value]) -> Result<()> {
crates/causality-effects/src/executor.rs-        self.security.check_operation(operation, args)
crates/causality-effects/src/executor.rs-    }
crates/causality-effects/src/executor.rs-    
crates/causality-effects/src/executor.rs:    /// Check if resource access is allowed
crates/causality-effects/src/executor.rs-    pub fn check_resource_access(&self, resource_id: &ContentId, access_type: &str) -> Result<()> {
crates/causality-effects/src/executor.rs-        self.security.check_resource_access(resource_id, access_type)
crates/causality-effects/src/executor.rs-    }
crates/causality-effects/src/executor.rs-}
crates/causality-effects/src/executor.rs-
crates/causality-effects/src/executor.rs:/// Content-addressable executor for effects
crates/causality-effects/src/executor.rs-pub struct ContentAddressableExecutor<R: CodeRepository> {
--
crates/causality-effects/src/executor.rs-    security: Arc<dyn SecuritySandbox>,
crates/causality-effects/src/executor.rs-}
crates/causality-effects/src/executor.rs-
--
crates/causality-effects/src/executor.rs:    /// Create a new content-addressable executor
crates/causality-effects/src/executor.rs-    pub fn new(repository: Arc<R>, security: Arc<dyn SecuritySandbox>) -> Self {
--
crates/causality-effects/src/executor.rs-            repository,
crates/causality-effects/src/executor.rs-            security,
crates/causality-effects/src/executor.rs-        }
--
crates/causality-effects/src/executor.rs:    /// Execute content-addressed code
crates/causality-effects/src/executor.rs-    pub async fn execute(&self, code_hash: &ContentHash, args: Vec<Value>) -> Result<Value> {
--
crates/causality-effects/src/executor.rs-        let code_entry = self.repository.get_code(code_hash).await?
crates/causality-effects/src/executor.rs-            .ok_or_else(|| Error::NotFound(format!("Code hash not found: {}", code_hash)))?;
crates/causality-effects/src/executor.rs-        
--
crates/causality-effects/src/executor.rs:    /// Execute an effect with content-addressed code
crates/causality-effects/src/executor.rs-    pub async fn execute_effect<E: Effect + 'static>(&self, effect: &E) -> Result<EffectOutcome> {
--
crates/causality-effects/src/domain_effect.rs:/// Core trait for domain-specific effects
crates/causality-effects/src/domain_effect.rs-///
crates/causality-effects/src/domain_effect.rs:/// This trait extends the standard Effect trait with domain-specific
crates/causality-effects/src/domain_effect.rs:/// functionality, allowing domain operations to be used as effects.
crates/causality-effects/src/domain_effect.rs-#[async_trait]
crates/causality-effects/src/domain_effect.rs-pub trait DomainAdapterEffect: Effect {
--
crates/causality-effects/src/domain_effect.rs-    fn map_outcome<T: Any>(&self, domain_result: DomainResult<T>) -> EffectResult<EffectOutcome>;
crates/causality-effects/src/domain_effect.rs-}
crates/causality-effects/src/domain_effect.rs-
crates/causality-effects/src/domain_effect.rs:/// Context for domain effect execution
crates/causality-effects/src/domain_effect.rs-#[derive(Debug, Clone)]
crates/causality-effects/src/domain_effect.rs-pub struct DomainContext {
crates/causality-effects/src/domain_effect.rs:    /// Domain ID
crates/causality-effects/src/domain_effect.rs-    pub domain_id: DomainId,
crates/causality-effects/src/domain_effect.rs-    
crates/causality-effects/src/domain_effect.rs:    /// Caller identity
crates/causality-effects/src/domain_effect.rs-    pub caller: Option<String>,
crates/causality-effects/src/domain_effect.rs-    
crates/causality-effects/src/domain_effect.rs:    /// Authorization tokens
crates/causality-effects/src/domain_effect.rs-    pub auth_tokens: HashMap<String, String>,
crates/causality-effects/src/domain_effect.rs-    
crates/causality-effects/src/domain_effect.rs:    /// Parameters for execution
crates/causality-effects/src/domain_effect.rs-    pub parameters: HashMap<String, String>,
crates/causality-effects/src/domain_effect.rs-    
crates/causality-effects/src/domain_effect.rs:    /// Timestamp for execution
crates/causality-effects/src/domain_effect.rs-    pub timestamp: u64,
crates/causality-effects/src/domain_effect.rs-}
crates/causality-effects/src/domain_effect.rs-
crates/causality-effects/src/domain_effect.rs-impl DomainContext {
crates/causality-effects/src/domain_effect.rs:    /// Create a new domain context
crates/causality-effects/src/domain_effect.rs-    pub fn new(domain_id: DomainId) -> Self {
--
crates/causality-effects/src/domain_effect.rs-            domain_id,
crates/causality-effects/src/domain_effect.rs-            caller: None,
crates/causality-effects/src/domain_effect.rs-            auth_tokens: HashMap::new(),
--
crates/causality-effects/src/domain_effect.rs:    /// Create from effect context
crates/causality-effects/src/domain_effect.rs-    pub fn from_effect_context(domain_id: DomainId, context: &EffectContext) -> Self {
--
crates/causality-effects/src/domain_effect.rs-        domain_context.caller = context.caller.clone();
crates/causality-effects/src/domain_effect.rs-        domain_context.parameters = context.params.clone();
crates/causality-effects/src/domain_effect.rs-        domain_context.timestamp = context.started_at.timestamp() as u64;
--
crates/causality-effects/src/domain_effect.rs:    /// Set caller
crates/causality-effects/src/domain_effect.rs-    pub fn with_caller(mut self, caller: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect.rs-        self.caller = Some(caller.into());
crates/causality-effects/src/domain_effect.rs-        self
crates/causality-effects/src/domain_effect.rs-    }
crates/causality-effects/src/domain_effect.rs-    
crates/causality-effects/src/domain_effect.rs:    /// Add auth token
crates/causality-effects/src/domain_effect.rs-    pub fn with_auth_token(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect.rs-        self.auth_tokens.insert(key.into(), value.into());
crates/causality-effects/src/domain_effect.rs-        self
crates/causality-effects/src/domain_effect.rs-    }
crates/causality-effects/src/domain_effect.rs-    
crates/causality-effects/src/domain_effect.rs:    /// Add parameter
crates/causality-effects/src/domain_effect.rs-    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
--
crates/causality-effects/src/domain_effect.rs-    }
crates/causality-effects/src/domain_effect.rs-}
--
crates/causality-effects/src/domain_effect.rs:/// Domain query effect for querying facts from a domain
crates/causality-effects/src/domain_effect.rs-#[derive(Debug)]
crates/causality-effects/src/domain_effect.rs-pub struct DomainQueryEffect {
--
crates/causality-effects/src/domain_effect.rs-    parameters: HashMap<String, String>,
crates/causality-effects/src/domain_effect.rs-}
crates/causality-effects/src/domain_effect.rs-
crates/causality-effects/src/domain_effect.rs-impl DomainQueryEffect {
crates/causality-effects/src/domain_effect.rs:    /// Create a new domain query effect
crates/causality-effects/src/domain_effect.rs-    pub fn new(domain_id: DomainId, query: FactQuery) -> Self {
--
crates/causality-effects/src/domain_effect.rs-            id: EffectId::new(),
crates/causality-effects/src/domain_effect.rs-            domain_id,
crates/causality-effects/src/domain_effect.rs-            query,
--
crates/causality-effects/src/domain_effect.rs:    /// Add a parameter
crates/causality-effects/src/domain_effect.rs-    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect.rs-        self.parameters.insert(key.into(), value.into());
crates/causality-effects/src/domain_effect.rs-        self
crates/causality-effects/src/domain_effect.rs-    }
crates/causality-effects/src/domain_effect.rs-    
crates/causality-effects/src/domain_effect.rs:    /// Get the fact query
crates/causality-effects/src/domain_effect.rs-    pub fn query(&self) -> &FactQuery {
--
crates/causality-effects/src/domain_effect.rs-}
crates/causality-effects/src/domain_effect.rs-
--
crates/causality-effects/src/domain_effect.rs:/// Domain transaction effect for submitting transactions to a domain
crates/causality-effects/src/domain_effect.rs-#[derive(Debug)]
crates/causality-effects/src/domain_effect.rs-pub struct DomainTransactionEffect {
--
crates/causality-effects/src/domain_effect.rs-    parameters: HashMap<String, String>,
crates/causality-effects/src/domain_effect.rs-}
crates/causality-effects/src/domain_effect.rs-
crates/causality-effects/src/domain_effect.rs-impl DomainTransactionEffect {
crates/causality-effects/src/domain_effect.rs:    /// Create a new domain transaction effect
crates/causality-effects/src/domain_effect.rs-    pub fn new(domain_id: DomainId, transaction: Transaction) -> Self {
--
crates/causality-effects/src/domain_effect.rs-        assert_eq!(domain_id, transaction.domain_id, 
crates/causality-effects/src/domain_effect.rs-            "Transaction domain ID must match effect domain ID");
crates/causality-effects/src/domain_effect.rs-            
--
crates/causality-effects/src/domain_effect.rs:    /// Wait for confirmation
crates/causality-effects/src/domain_effect.rs-    pub fn with_confirmation(mut self, wait: bool) -> Self {
crates/causality-effects/src/domain_effect.rs-        self.wait_for_confirmation = wait;
crates/causality-effects/src/domain_effect.rs-        self
crates/causality-effects/src/domain_effect.rs-    }
crates/causality-effects/src/domain_effect.rs-    
crates/causality-effects/src/domain_effect.rs:    /// Set maximum wait time
crates/causality-effects/src/domain_effect.rs-    pub fn with_max_wait(mut self, max_wait_ms: u64) -> Self {
crates/causality-effects/src/domain_effect.rs-        self.max_wait_ms = Some(max_wait_ms);
crates/causality-effects/src/domain_effect.rs-        self
crates/causality-effects/src/domain_effect.rs-    }
crates/causality-effects/src/domain_effect.rs-    
crates/causality-effects/src/domain_effect.rs:    /// Add a parameter
crates/causality-effects/src/domain_effect.rs-    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect.rs-        self.parameters.insert(key.into(), value.into());
crates/causality-effects/src/domain_effect.rs-        self
crates/causality-effects/src/domain_effect.rs-    }
crates/causality-effects/src/domain_effect.rs-    
crates/causality-effects/src/domain_effect.rs:    /// Get the transaction
crates/causality-effects/src/domain_effect.rs-    pub fn transaction(&self) -> &Transaction {
--
crates/causality-effects/src/domain_effect.rs-}
crates/causality-effects/src/domain_effect.rs-
--
crates/causality-effects/src/domain_effect.rs:/// Domain time map effect for working with time synchronization between domains
crates/causality-effects/src/domain_effect.rs-#[derive(Debug)]
crates/causality-effects/src/domain_effect.rs-pub struct DomainTimeMapEffect {
--
crates/causality-effects/src/domain_effect.rs-    parameters: HashMap<String, String>,
crates/causality-effects/src/domain_effect.rs-}
crates/causality-effects/src/domain_effect.rs-
crates/causality-effects/src/domain_effect.rs-impl DomainTimeMapEffect {
crates/causality-effects/src/domain_effect.rs:    /// Create a new domain time map effect
crates/causality-effects/src/domain_effect.rs-    pub fn new(domain_id: DomainId) -> Self {
--
crates/causality-effects/src/domain_effect.rs-            id: EffectId::new(),
crates/causality-effects/src/domain_effect.rs-            domain_id,
crates/causality-effects/src/domain_effect.rs-            height: None,
--
crates/causality-effects/src/domain_effect.rs:    /// With specific block height
crates/causality-effects/src/domain_effect.rs-    pub fn with_height(mut self, height: BlockHeight) -> Self {
crates/causality-effects/src/domain_effect.rs-        self.height = Some(height);
crates/causality-effects/src/domain_effect.rs-        self
crates/causality-effects/src/domain_effect.rs-    }
crates/causality-effects/src/domain_effect.rs-    
crates/causality-effects/src/domain_effect.rs:    /// Add a parameter
crates/causality-effects/src/domain_effect.rs-    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
--
crates/causality-effects/src/domain_effect.rs-    }
crates/causality-effects/src/domain_effect.rs-}
--
crates/causality-effects/src/domain_effect.rs:/// Domain capability effect for checking domain capabilities
crates/causality-effects/src/domain_effect.rs-#[derive(Debug)]
crates/causality-effects/src/domain_effect.rs-pub struct DomainCapabilityEffect {
--
crates/causality-effects/src/domain_effect.rs-    parameters: HashMap<String, String>,
crates/causality-effects/src/domain_effect.rs-}
crates/causality-effects/src/domain_effect.rs-
crates/causality-effects/src/domain_effect.rs-impl DomainCapabilityEffect {
crates/causality-effects/src/domain_effect.rs:    /// Create a new domain capability effect
crates/causality-effects/src/domain_effect.rs-    pub fn new(domain_id: DomainId, capability: impl Into<String>) -> Self {
--
crates/causality-effects/src/domain_effect.rs-            id: EffectId::new(),
crates/causality-effects/src/domain_effect.rs-            domain_id,
crates/causality-effects/src/domain_effect.rs-            capability: capability.into(),
--
crates/causality-effects/src/domain_effect.rs:    /// Add a parameter
crates/causality-effects/src/domain_effect.rs-    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect.rs-        self.parameters.insert(key.into(), value.into());
crates/causality-effects/src/domain_effect.rs-        self
crates/causality-effects/src/domain_effect.rs-    }
crates/causality-effects/src/domain_effect.rs-    
crates/causality-effects/src/domain_effect.rs:    /// Get the capability
crates/causality-effects/src/domain_effect.rs-    pub fn capability(&self) -> &str {
--
crates/causality-effects/src/domain_effect.rs-    }
crates/causality-effects/src/domain_effect.rs-}
crates/causality-effects/src/domain_effect.rs-
--
crates/causality-effects/src/domain_effect.rs:/// Create a domain query effect
crates/causality-effects/src/domain_effect.rs-pub fn query_domain_fact(domain_id: DomainId, fact_type: impl Into<String>) -> DomainQueryEffect {
--
crates/causality-effects/src/domain_effect.rs-        domain_id: domain_id.clone(),
crates/causality-effects/src/domain_effect.rs-        fact_type: fact_type.into(),
crates/causality-effects/src/domain_effect.rs-        parameters: HashMap::new(),
--
crates/causality-effects/src/domain_effect.rs:/// Create a domain transaction effect
crates/causality-effects/src/domain_effect.rs-pub fn submit_domain_transaction(domain_id: DomainId, tx_type: impl Into<String>) -> DomainTransactionEffect {
--
crates/causality-effects/src/domain_effect.rs-        domain_id: domain_id.clone(),
crates/causality-effects/src/domain_effect.rs-        tx_type: tx_type.into(),
crates/causality-effects/src/domain_effect.rs-        sender: None,
--
crates/causality-effects/src/domain_effect.rs:/// Create a domain time map effect
crates/causality-effects/src/domain_effect.rs-pub fn get_domain_time_map(domain_id: DomainId) -> DomainTimeMapEffect {
crates/causality-effects/src/domain_effect.rs-    DomainTimeMapEffect::new(domain_id)
crates/causality-effects/src/domain_effect.rs-}
crates/causality-effects/src/domain_effect.rs-
crates/causality-effects/src/domain_effect.rs:/// Create a domain capability check effect
crates/causality-effects/src/domain_effect.rs-pub fn check_domain_capability(domain_id: DomainId, capability: impl Into<String>) -> DomainCapabilityEffect {
--
crates/causality-effects/src/domain_effect.rs-
crates/causality-effects/src/domain_effect.rs-// TODO: Implement domain registry integration with effect system 
--
crates/causality-effects/src/repository.rs:/// Entry in the code repository
crates/causality-effects/src/repository.rs-#[derive(Debug, Clone, Serialize, Deserialize)]
crates/causality-effects/src/repository.rs-pub struct CodeEntry {
crates/causality-effects/src/repository.rs:    /// The code definition
crates/causality-effects/src/repository.rs-    pub definition: CodeDefinition,
crates/causality-effects/src/repository.rs:    /// Metadata about this entry
crates/causality-effects/src/repository.rs-    pub metadata: CodeMetadata,
crates/causality-effects/src/repository.rs-}
crates/causality-effects/src/repository.rs-
crates/causality-effects/src/repository.rs:/// Metadata about a code entry
crates/causality-effects/src/repository.rs-#[derive(Debug, Clone, Serialize, Deserialize)]
crates/causality-effects/src/repository.rs-pub struct CodeMetadata {
crates/causality-effects/src/repository.rs:    /// When the code was added to the repository
crates/causality-effects/src/repository.rs-    pub added_at: chrono::DateTime<chrono::Utc>,
crates/causality-effects/src/repository.rs:    /// Tags for this code
crates/causality-effects/src/repository.rs-    pub tags: Vec<String>,
crates/causality-effects/src/repository.rs:    /// Versions available
crates/causality-effects/src/repository.rs-    pub versions: Vec<String>,
crates/causality-effects/src/repository.rs:    /// Additional properties
crates/causality-effects/src/repository.rs-    pub properties: HashMap<String, serde_json::Value>,
crates/causality-effects/src/repository.rs-}
crates/causality-effects/src/repository.rs-
crates/causality-effects/src/repository.rs-impl CodeMetadata {
crates/causality-effects/src/repository.rs:    /// Create new metadata
crates/causality-effects/src/repository.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/repository.rs-            added_at: chrono::Utc::now(),
crates/causality-effects/src/repository.rs-            tags: Vec::new(),
crates/causality-effects/src/repository.rs-            versions: Vec::new(),
--
crates/causality-effects/src/repository.rs:    /// Add a tag
crates/causality-effects/src/repository.rs-    pub fn with_tag(mut self, tag: &str) -> Self {
crates/causality-effects/src/repository.rs-        self.tags.push(tag.to_string());
crates/causality-effects/src/repository.rs-        self
crates/causality-effects/src/repository.rs-    }
crates/causality-effects/src/repository.rs-    
crates/causality-effects/src/repository.rs:    /// Add a version
crates/causality-effects/src/repository.rs-    pub fn with_version(mut self, version: &str) -> Self {
crates/causality-effects/src/repository.rs-        self.versions.push(version.to_string());
crates/causality-effects/src/repository.rs-        self
crates/causality-effects/src/repository.rs-    }
crates/causality-effects/src/repository.rs-    
crates/causality-effects/src/repository.rs:    /// Add a property
crates/causality-effects/src/repository.rs-    pub fn with_property(mut self, key: &str, value: serde_json::Value) -> Self {
--
crates/causality-effects/src/repository.rs-    }
crates/causality-effects/src/repository.rs-}
--
crates/causality-effects/src/repository.rs:/// Repository for content-addressable code
crates/causality-effects/src/repository.rs-#[async_trait]
crates/causality-effects/src/repository.rs-pub trait CodeRepository: Send + Sync {
--
crates/causality-effects/src/repository.rs:    /// Find code by name
crates/causality-effects/src/repository.rs-    async fn find_by_name(&self, name: &str) -> Result<Vec<CodeEntry>>;
crates/causality-effects/src/repository.rs-}
crates/causality-effects/src/repository.rs-
crates/causality-effects/src/repository.rs:/// In-memory repository implementation
crates/causality-effects/src/repository.rs-pub struct InMemoryCodeRepository {
crates/causality-effects/src/repository.rs-    entries: RwLock<HashMap<ContentHash, CodeEntry>>,
crates/causality-effects/src/repository.rs-}
crates/causality-effects/src/repository.rs-
crates/causality-effects/src/repository.rs-impl InMemoryCodeRepository {
crates/causality-effects/src/repository.rs:    /// Create a new in-memory repository
crates/causality-effects/src/repository.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/repository.rs-            entries: RwLock::new(HashMap::new()),
crates/causality-effects/src/repository.rs-        }
crates/causality-effects/src/repository.rs-    }
--
crates/causality-effects/src/repository.rs:/// File-based repository implementation
crates/causality-effects/src/repository.rs-pub struct FileCodeRepository {
--
crates/causality-effects/src/repository.rs-    index: RwLock<HashMap<ContentHash, PathBuf>>,
crates/causality-effects/src/repository.rs-}
crates/causality-effects/src/repository.rs-
--
crates/causality-effects/src/repository.rs:    /// Create a new file-based repository
crates/causality-effects/src/repository.rs-    pub fn new<P: AsRef<Path>>(base_path: P) -> Result<Self> {
--
crates/causality-effects/src/repository.rs-        let index_path = self.base_path.join("index.json");
crates/causality-effects/src/repository.rs-        fs::write(index_path, index_data)?;
--
crates/causality-effects/src/templates/relationship_validation.rs:/// A validation effect that ensures resource operations don't violate relationship constraints
crates/causality-effects/src/templates/relationship_validation.rs-#[derive(Debug)]
crates/causality-effects/src/templates/relationship_validation.rs-pub struct RelationshipStateValidationEffect {
crates/causality-effects/src/templates/relationship_validation.rs-    id: EffectId,
crates/causality-effects/src/templates/relationship_validation.rs-    resource_id: ContentId,
crates/causality-effects/src/templates/relationship_validation.rs-    operation_type: RegisterOperationType,
--
crates/causality-effects/src/templates/relationship_validation.rs:    /// Create a new validation effect
crates/causality-effects/src/templates/relationship_validation.rs-    pub fn new(
--
crates/causality-effects/src/templates/relationship_validation.rs-        operation_type: RegisterOperationType,
crates/causality-effects/src/templates/relationship_validation.rs-        domain_id: DomainId,
crates/causality-effects/src/templates/relationship_validation.rs-        inner_effect: Arc<dyn Effect>,
--
crates/causality-effects/src/templates/relationship_validation.rs:    /// Wrap an existing effect with relationship validation
crates/causality-effects/src/templates/relationship_validation.rs-    pub fn wrap(
--
crates/causality-effects/src/templates/relationship_validation.rs-        operation_type: RegisterOperationType,
crates/causality-effects/src/templates/relationship_validation.rs-        domain_id: DomainId,
crates/causality-effects/src/templates/relationship_validation.rs-        inner_effect: Arc<dyn Effect>,
--
crates/causality-effects/src/templates/state_transition.rs:/// Filter for querying relationships
crates/causality-effects/src/templates/state_transition.rs-pub struct RelationshipFilter {
crates/causality-effects/src/templates/state_transition.rs:    /// Types of relationships to include (None = all types)
crates/causality-effects/src/templates/state_transition.rs-    pub relationship_types: Option<Vec<RelationshipType>>,
crates/causality-effects/src/templates/state_transition.rs:    /// Maximum number of results to return
crates/causality-effects/src/templates/state_transition.rs-    pub max_results: Option<usize>,
crates/causality-effects/src/templates/state_transition.rs:    /// Whether to include deleted relationships
crates/causality-effects/src/templates/state_transition.rs-    pub include_deleted: bool,
crates/causality-effects/src/templates/state_transition.rs-}
crates/causality-effects/src/templates/state_transition.rs-
crates/causality-effects/src/templates/state_transition.rs:/// Helper struct to validate state transitions against relationship constraints
crates/causality-effects/src/templates/state_transition.rs-pub struct ResourceStateTransitionHelper {
--
crates/causality-effects/src/templates/state_transition.rs-    relationship_tracker: Arc<RelationshipTracker>,
crates/causality-effects/src/templates/state_transition.rs-}
crates/causality-effects/src/templates/state_transition.rs-
crates/causality-effects/src/templates/state_transition.rs-impl ResourceStateTransitionHelper {
crates/causality-effects/src/templates/state_transition.rs:    /// Create a new helper with a resource lifecycle manager and relationship tracker
crates/causality-effects/src/templates/state_transition.rs-    pub fn new(
--
crates/causality-effects/src/templates/state_transition.rs-        relationship_tracker: Arc<RelationshipTracker>,
crates/causality-effects/src/templates/state_transition.rs-    ) -> Self {
crates/causality-effects/src/templates/state_transition.rs-        Self {
--
crates/causality-effects/src/templates/state_transition.rs:    /// Get the lifecycle manager
crates/causality-effects/src/templates/state_transition.rs-    pub fn get_lifecycle_manager(&self) -> Option<&Arc<ResourceRegisterLifecycleManager>> {
crates/causality-effects/src/templates/state_transition.rs-        self.lifecycle_manager.as_ref()
crates/causality-effects/src/templates/state_transition.rs-    }
crates/causality-effects/src/templates/state_transition.rs-    
crates/causality-effects/src/templates/state_transition.rs:    /// Set the lifecycle manager
crates/causality-effects/src/templates/state_transition.rs-    pub fn set_lifecycle_manager(&mut self, lifecycle_manager: Arc<ResourceRegisterLifecycleManager>) {
crates/causality-effects/src/templates/state_transition.rs-        self.lifecycle_manager = Some(lifecycle_manager);
crates/causality-effects/src/templates/state_transition.rs-    }
crates/causality-effects/src/templates/state_transition.rs-    
crates/causality-effects/src/templates/state_transition.rs:    /// Validate that a state transition doesn't violate relationship constraints
crates/causality-effects/src/templates/state_transition.rs-    pub async fn validate_relationships_for_transition(
--
crates/causality-effects/src/templates/state_transition.rs-        resource_id: &ContentId,
crates/causality-effects/src/templates/state_transition.rs-        from_state: &str,
crates/causality-effects/src/templates/state_transition.rs-        to_state: &str,
--
crates/causality-effects/src/templates/state_transition.rs:    /// Update relationships after a state transition
crates/causality-effects/src/templates/state_transition.rs-    pub async fn update_relationships_after_transition(
--
crates/causality-effects/src/templates/state_transition.rs-        from_state: &str,
crates/causality-effects/src/templates/state_transition.rs-        to_state: &str,
--
crates/causality-effects/src/storage.rs:/// Result of a storage operation
crates/causality-effects/src/storage.rs-#[derive(Debug, Clone)]
crates/causality-effects/src/storage.rs-pub enum StoreResult {
--
crates/causality-effects/src/storage.rs-    Failure { reason: String },
crates/causality-effects/src/storage.rs-}
crates/causality-effects/src/storage.rs-
crates/causality-effects/src/storage.rs:/// Result of a read operation
crates/causality-effects/src/storage.rs-#[derive(Debug, Clone)]
crates/causality-effects/src/storage.rs-pub enum ReadResult {
--
crates/causality-effects/src/storage.rs:    /// Read failed
crates/causality-effects/src/storage.rs-    Failure { reason: String },
crates/causality-effects/src/storage.rs-}
crates/causality-effects/src/storage.rs-
crates/causality-effects/src/storage.rs:/// Effect for storing a register on-chain
crates/causality-effects/src/storage.rs-pub struct StoreOnChainEffect {
--
crates/causality-effects/src/storage.rs-    fields: HashSet<String>,
crates/causality-effects/src/storage.rs-    domain_id: DomainId,
crates/causality-effects/src/storage.rs-    invoker: Address,
--
crates/causality-effects/src/storage.rs:    /// Create a new effect to store a register on-chain
crates/causality-effects/src/storage.rs-    pub fn new(
--
crates/causality-effects/src/storage.rs-        fields: HashSet<String>,
crates/causality-effects/src/storage.rs-        domain_id: DomainId,
crates/causality-effects/src/storage.rs-        invoker: Address,
--
crates/causality-effects/src/storage.rs:    /// Create from a legacy ContentId (for backward compatibility)
crates/causality-effects/src/storage.rs-    pub fn from_resource_id(
--
crates/causality-effects/src/storage.rs-        fields: HashSet<String>,
crates/causality-effects/src/storage.rs-        domain_id: DomainId,
crates/causality-effects/src/storage.rs-        invoker: Address,
--
crates/causality-effects/src/storage.rs:/// Effect for reading a register from the chain
crates/causality-effects/src/storage.rs-pub struct ReadFromChainEffect {
--
crates/causality-effects/src/storage.rs-    fields: HashSet<String>,
crates/causality-effects/src/storage.rs-    domain_id: DomainId,
crates/causality-effects/src/storage.rs-    invoker: Address,
--
crates/causality-effects/src/storage.rs:    /// Create a new effect to read a register from the chain
crates/causality-effects/src/storage.rs-    pub fn new(
--
crates/causality-effects/src/storage.rs-        fields: HashSet<String>,
crates/causality-effects/src/storage.rs-        domain_id: DomainId,
crates/causality-effects/src/storage.rs-        invoker: Address,
--
crates/causality-effects/src/storage.rs:    /// Create from a legacy ContentId (for backward compatibility)
crates/causality-effects/src/storage.rs-    pub fn from_resource_id(
--
crates/causality-effects/src/storage.rs-        fields: HashSet<String>,
crates/causality-effects/src/storage.rs-        domain_id: DomainId,
crates/causality-effects/src/storage.rs-        invoker: Address,
--
crates/causality-effects/src/storage.rs:/// Effect for storing a commitment on-chain
crates/causality-effects/src/storage.rs-pub struct StoreCommitmentEffect {
--
crates/causality-effects/src/storage.rs-    commitment: Commitment,
crates/causality-effects/src/storage.rs-    domain_id: DomainId,
crates/causality-effects/src/storage.rs-    invoker: Address,
--
crates/causality-effects/src/storage.rs:    /// Create a new effect to store a commitment on-chain
crates/causality-effects/src/storage.rs-    pub fn new(
--
crates/causality-effects/src/storage.rs-        commitment: Commitment,
crates/causality-effects/src/storage.rs-        domain_id: DomainId,
crates/causality-effects/src/storage.rs-        invoker: Address,
--
crates/causality-effects/src/storage.rs:    /// Create from a legacy ContentId (for backward compatibility)
crates/causality-effects/src/storage.rs-    pub fn from_resource_id(
--
crates/causality-effects/src/storage.rs-        commitment: Commitment,
crates/causality-effects/src/storage.rs-        domain_id: DomainId,
crates/causality-effects/src/storage.rs-        invoker: Address,
--
crates/causality-effects/src/storage.rs:/// Effect for storing a nullifier on-chain
crates/causality-effects/src/storage.rs-pub struct StoreNullifierEffect {
--
crates/causality-effects/src/storage.rs-    nullifier: NullifierId,
crates/causality-effects/src/storage.rs-    domain_id: DomainId,
crates/causality-effects/src/storage.rs-    invoker: Address,
--
crates/causality-effects/src/storage.rs:    /// Create a new effect to store a nullifier on-chain
crates/causality-effects/src/storage.rs-    pub fn new(
--
crates/causality-effects/src/storage.rs-        nullifier: NullifierId,
crates/causality-effects/src/storage.rs-        domain_id: DomainId,
crates/causality-effects/src/storage.rs-        invoker: Address,
--
crates/causality-effects/src/storage.rs:    /// Create from a legacy ContentId (for backward compatibility)
crates/causality-effects/src/storage.rs-    pub fn from_resource_id(
--
crates/causality-effects/src/storage.rs-        nullifier: NullifierId,
crates/causality-effects/src/storage.rs-        domain_id: DomainId,
crates/causality-effects/src/storage.rs-        invoker: Address,
--
crates/causality-effects/src/storage.rs:/// Effect for transferring a ResourceRegister across domains
crates/causality-effects/src/storage.rs-pub struct CrossDomainTransferEffect {
--
crates/causality-effects/src/storage.rs-    target_domain_id: DomainId,
crates/causality-effects/src/storage.rs-    controller_label: Option<String>,
crates/causality-effects/src/storage.rs-    source_domain_id: DomainId,
--
crates/causality-effects/src/storage.rs:    /// Create a new effect to transfer a ResourceRegister across domains
crates/causality-effects/src/storage.rs-    pub fn new(
--
crates/causality-effects/src/storage.rs-        source_domain_id: DomainId,
--
crates/causality-effects/src/storage.rs:/// Create factory functions for constructing storage effects
crates/causality-effects/src/storage.rs-
crates/causality-effects/src/storage.rs:/// Create a store on-chain effect for a ResourceRegister using ContentId
crates/causality-effects/src/storage.rs-pub fn create_store_on_chain_effect(
--
crates/causality-effects/src/storage.rs-    fields: HashSet<String>,
crates/causality-effects/src/storage.rs-    domain_id: DomainId,
crates/causality-effects/src/storage.rs-    invoker: Address,
--
crates/causality-effects/src/storage.rs:/// Create a read from chain effect for a ResourceRegister using ContentId
crates/causality-effects/src/storage.rs-pub fn create_read_from_chain_effect(
--
crates/causality-effects/src/storage.rs-    fields: HashSet<String>,
crates/causality-effects/src/storage.rs-    domain_id: DomainId,
crates/causality-effects/src/storage.rs-    invoker: Address,
--
crates/causality-effects/src/storage.rs:/// Create a store commitment effect for a ResourceRegister using ContentId
crates/causality-effects/src/storage.rs-pub fn create_store_commitment_effect(
--
crates/causality-effects/src/storage.rs-    commitment: Commitment,
crates/causality-effects/src/storage.rs-    domain_id: DomainId,
crates/causality-effects/src/storage.rs-    invoker: Address,
--
crates/causality-effects/src/storage.rs:/// Create a store nullifier effect for a ResourceRegister using ContentId
crates/causality-effects/src/storage.rs-pub fn create_store_nullifier_effect(
--
crates/causality-effects/src/storage.rs-    nullifier: NullifierId,
crates/causality-effects/src/storage.rs-    domain_id: DomainId,
crates/causality-effects/src/storage.rs-    invoker: Address,
--
crates/causality-effects/src/storage.rs:/// Backward compatibility: Create a store on-chain effect for a ContentId
crates/causality-effects/src/storage.rs-pub fn create_store_on_chain_effect_from_resource_id(
--
crates/causality-effects/src/storage.rs-    fields: HashSet<String>,
crates/causality-effects/src/storage.rs-    domain_id: DomainId,
crates/causality-effects/src/storage.rs-    invoker: Address,
--
crates/causality-effects/src/storage.rs:/// Backward compatibility: Create a read from chain effect for a ContentId
crates/causality-effects/src/storage.rs-pub fn create_read_from_chain_effect_from_resource_id(
--
crates/causality-effects/src/storage.rs-    fields: HashSet<String>,
crates/causality-effects/src/storage.rs-    domain_id: DomainId,
crates/causality-effects/src/storage.rs-    invoker: Address,
--
crates/causality-effects/src/storage.rs:/// Create a domain-specific storage effect for storing a register on-chain
crates/causality-effects/src/storage.rs-pub fn create_domain_specific_store_effect(
--
crates/causality-effects/src/storage.rs-    fields: HashSet<String>,
crates/causality-effects/src/storage.rs-    domain_id: DomainId,
crates/causality-effects/src/storage.rs-    invoker: Address,
--
crates/causality-effects/src/storage.rs:/// Create a domain-specific storage effect for storing a commitment on-chain
crates/causality-effects/src/storage.rs-pub fn create_domain_specific_commitment_effect(
--
crates/causality-effects/src/storage.rs-    commitment: Commitment,
crates/causality-effects/src/storage.rs-    domain_id: DomainId,
crates/causality-effects/src/storage.rs-    invoker: Address,
--
crates/causality-effects/src/storage.rs:/// Factory function to create a cross-domain transfer effect
crates/causality-effects/src/storage.rs-pub fn create_cross_domain_transfer_effect(
--
--
crates/causality-effects/src/domain_effect/handler.rs:/// Handler for domain effects
crates/causality-effects/src/domain_effect/handler.rs-///
crates/causality-effects/src/domain_effect/handler.rs:/// This handler provides integration between the Effect System's handler
crates/causality-effects/src/domain_effect/handler.rs:/// framework and domain-specific effects.
crates/causality-effects/src/domain_effect/handler.rs-pub struct DomainEffectHandlerAdapter {
--
crates/causality-effects/src/domain_effect/handler.rs-    registry: Arc<EffectDomainRegistry>,
crates/causality-effects/src/domain_effect/handler.rs-}
crates/causality-effects/src/domain_effect/handler.rs-
crates/causality-effects/src/domain_effect/handler.rs-impl DomainEffectHandlerAdapter {
crates/causality-effects/src/domain_effect/handler.rs:    /// Create a new domain effect handler adapter
crates/causality-effects/src/domain_effect/handler.rs-    pub fn new(registry: Arc<EffectDomainRegistry>) -> Self {
--
crates/causality-effects/src/domain_effect/handler.rs-            registry,
crates/causality-effects/src/domain_effect/handler.rs-        }
crates/causality-effects/src/domain_effect/handler.rs-    }
--
crates/causality-effects/src/domain_effect/handler.rs:    /// Get the domain registry
crates/causality-effects/src/domain_effect/handler.rs-    pub fn registry(&self) -> &EffectDomainRegistry {
--
crates/causality-effects/src/domain_effect/handler.rs-    }
crates/causality-effects/src/domain_effect/handler.rs-}
crates/causality-effects/src/domain_effect/handler.rs-
--
crates/causality-effects/src/domain_effect/handler.rs:/// Create a domain effect handler adapter
crates/causality-effects/src/domain_effect/handler.rs-pub fn create_domain_handler(registry: Arc<EffectDomainRegistry>) -> DomainEffectHandlerAdapter {
crates/causality-effects/src/domain_effect/handler.rs-    DomainEffectHandlerAdapter::new(registry)
crates/causality-effects/src/domain_effect/handler.rs-}
crates/causality-effects/src/domain_effect/handler.rs-
crates/causality-effects/src/domain_effect/handler.rs:/// Create a domain effect handler adapter with a new registry
crates/causality-effects/src/domain_effect/handler.rs-pub fn create_domain_handler_with_new_registry() -> (Arc<EffectDomainRegistry>, DomainEffectHandlerAdapter) {
--
--
crates/causality-effects/src/domain_effect/evm_effects.rs:/// EVM Contract Call Effect
crates/causality-effects/src/domain_effect/evm_effects.rs-///
crates/causality-effects/src/domain_effect/evm_effects.rs:/// This effect represents a call to a smart contract on an EVM-compatible blockchain.
crates/causality-effects/src/domain_effect/evm_effects.rs-#[derive(Debug)]
crates/causality-effects/src/domain_effect/evm_effects.rs-pub struct EvmContractCallEffect {
--
crates/causality-effects/src/domain_effect/evm_effects.rs-    is_view: bool,
crates/causality-effects/src/domain_effect/evm_effects.rs-}
crates/causality-effects/src/domain_effect/evm_effects.rs-
crates/causality-effects/src/domain_effect/evm_effects.rs-impl EvmContractCallEffect {
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Create a new EVM contract view (read-only) call effect
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn new_view_call(
--
crates/causality-effects/src/domain_effect/evm_effects.rs-        contract_address: impl Into<String>,
crates/causality-effects/src/domain_effect/evm_effects.rs-        function_name: impl Into<String>,
crates/causality-effects/src/domain_effect/evm_effects.rs-        args: Vec<String>
--
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Create a new EVM contract transaction (state-changing) call effect
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn new_transaction_call(
--
crates/causality-effects/src/domain_effect/evm_effects.rs-        contract_address: impl Into<String>,
crates/causality-effects/src/domain_effect/evm_effects.rs-        function_name: impl Into<String>,
crates/causality-effects/src/domain_effect/evm_effects.rs-        args: Vec<String>
--
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Add a parameter
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs-        self.parameters.insert(key.into(), value.into());
crates/causality-effects/src/domain_effect/evm_effects.rs-        self
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Set gas limit parameter
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn with_gas_limit(self, gas_limit: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs-        self.with_parameter("gas_limit", gas_limit)
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Set gas price parameter
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn with_gas_price(self, gas_price: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs-        self.with_parameter("gas_price", gas_price)
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Set value parameter (amount of native currency to send with the call)
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn with_value(self, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs-        self.with_parameter("value", value)
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Get the domain ID
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/evm_effects.rs-        &self.domain_id
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Get the contract address
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn contract_address(&self) -> &str {
crates/causality-effects/src/domain_effect/evm_effects.rs-        &self.contract_address
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Get the function name
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn function_name(&self) -> &str {
crates/causality-effects/src/domain_effect/evm_effects.rs-        &self.function_name
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Get the function arguments
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn args(&self) -> &[String] {
crates/causality-effects/src/domain_effect/evm_effects.rs-        &self.args
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Check if this is a view call
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn is_view(&self) -> bool {
crates/causality-effects/src/domain_effect/evm_effects.rs-        self.is_view
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Create a domain context from an effect context
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/evm_effects.rs-        DomainContext::new(context)
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Map the domain result to an effect outcome
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn map_outcome(&self, result: DomainResult<String>) -> EffectResult<EffectOutcome> {
--
--
crates/causality-effects/src/domain_effect/evm_effects.rs:/// EVM State Query Effect
crates/causality-effects/src/domain_effect/evm_effects.rs-///
crates/causality-effects/src/domain_effect/evm_effects.rs:/// This effect represents a query for state data on an EVM-compatible blockchain.
crates/causality-effects/src/domain_effect/evm_effects.rs-#[derive(Debug)]
crates/causality-effects/src/domain_effect/evm_effects.rs-pub struct EvmStateQueryEffect {
--
crates/causality-effects/src/domain_effect/evm_effects.rs-    parameters: HashMap<String, String>,
crates/causality-effects/src/domain_effect/evm_effects.rs-}
crates/causality-effects/src/domain_effect/evm_effects.rs-
crates/causality-effects/src/domain_effect/evm_effects.rs:/// Type of EVM state query
crates/causality-effects/src/domain_effect/evm_effects.rs-#[derive(Debug, Clone)]
crates/causality-effects/src/domain_effect/evm_effects.rs-pub enum EvmStateQueryType {
--
crates/causality-effects/src/domain_effect/evm_effects.rs-    ChainId,
crates/causality-effects/src/domain_effect/evm_effects.rs-}
crates/causality-effects/src/domain_effect/evm_effects.rs-
crates/causality-effects/src/domain_effect/evm_effects.rs-impl EvmStateQueryEffect {
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Create a new EVM state query effect
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn new(domain_id: impl Into<String>, query_type: EvmStateQueryType) -> Self {
--
crates/causality-effects/src/domain_effect/evm_effects.rs-            id: EffectId::new(),
crates/causality-effects/src/domain_effect/evm_effects.rs-            domain_id: domain_id.into(),
crates/causality-effects/src/domain_effect/evm_effects.rs-            query_type,
--
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Create a balance query
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn balance(domain_id: impl Into<String>, address: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs-        Self::new(domain_id, EvmStateQueryType::Balance(address.into()))
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Create a storage query
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn storage(
--
crates/causality-effects/src/domain_effect/evm_effects.rs-        address: impl Into<String>, 
crates/causality-effects/src/domain_effect/evm_effects.rs-        slot: impl Into<String>
crates/causality-effects/src/domain_effect/evm_effects.rs-    ) -> Self {
--
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Create a code query
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn code(domain_id: impl Into<String>, address: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs-        Self::new(domain_id, EvmStateQueryType::Code(address.into()))
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Create a nonce query
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn nonce(domain_id: impl Into<String>, address: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs-        Self::new(domain_id, EvmStateQueryType::Nonce(address.into()))
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Create a block query
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn block(domain_id: impl Into<String>, block_id: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs-        Self::new(domain_id, EvmStateQueryType::Block(block_id.into()))
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Create a transaction query
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn transaction(domain_id: impl Into<String>, tx_hash: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs-        Self::new(domain_id, EvmStateQueryType::Transaction(tx_hash.into()))
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Create a receipt query
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn receipt(domain_id: impl Into<String>, tx_hash: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs-        Self::new(domain_id, EvmStateQueryType::Receipt(tx_hash.into()))
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Create a gas price query
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn gas_price(domain_id: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs-        Self::new(domain_id, EvmStateQueryType::GasPrice)
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Create a gas limit query
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn gas_limit(domain_id: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs-        Self::new(domain_id, EvmStateQueryType::GasLimit)
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Create a chain ID query
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn chain_id(domain_id: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs-        Self::new(domain_id, EvmStateQueryType::ChainId)
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Add a parameter
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs-        self.parameters.insert(key.into(), value.into());
crates/causality-effects/src/domain_effect/evm_effects.rs-        self
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Specify a block number
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn at_block(self, block_number: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs-        self.with_parameter("block_number", block_number)
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Get the domain ID
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/evm_effects.rs-        &self.domain_id
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Get the query type
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn query_type(&self) -> &EvmStateQueryType {
crates/causality-effects/src/domain_effect/evm_effects.rs-        &self.query_type
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Create a domain context from an effect context
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/evm_effects.rs-        DomainContext::new(context)
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Map the domain result to an effect outcome
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn map_outcome(&self, result: DomainResult<String>) -> EffectResult<EffectOutcome> {
--
--
crates/causality-effects/src/domain_effect/evm_effects.rs:/// EVM Gas Estimation Effect
crates/causality-effects/src/domain_effect/evm_effects.rs-///
crates/causality-effects/src/domain_effect/evm_effects.rs:/// This effect represents a gas estimation for a transaction on an EVM-compatible blockchain.
crates/causality-effects/src/domain_effect/evm_effects.rs-#[derive(Debug)]
crates/causality-effects/src/domain_effect/evm_effects.rs-pub struct EvmGasEstimationEffect {
--
crates/causality-effects/src/domain_effect/evm_effects.rs-    parameters: HashMap<String, String>,
crates/causality-effects/src/domain_effect/evm_effects.rs-}
crates/causality-effects/src/domain_effect/evm_effects.rs-
crates/causality-effects/src/domain_effect/evm_effects.rs-impl EvmGasEstimationEffect {
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Create a new EVM gas estimation effect
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn new(
--
crates/causality-effects/src/domain_effect/evm_effects.rs-        contract_address: impl Into<String>,
crates/causality-effects/src/domain_effect/evm_effects.rs-        function_name: impl Into<String>,
crates/causality-effects/src/domain_effect/evm_effects.rs-        args: Vec<String>
--
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Add a parameter
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs-        self.parameters.insert(key.into(), value.into());
crates/causality-effects/src/domain_effect/evm_effects.rs-        self
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Set value parameter (amount of native currency to send with the call)
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn with_value(self, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs-        self.with_parameter("value", value)
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Specify a caller address
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn with_from(self, from: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs-        self.with_parameter("from", from)
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Get the domain ID
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/evm_effects.rs-        &self.domain_id
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Get the contract address
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn contract_address(&self) -> &str {
crates/causality-effects/src/domain_effect/evm_effects.rs-        &self.contract_address
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Get the function name
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn function_name(&self) -> &str {
crates/causality-effects/src/domain_effect/evm_effects.rs-        &self.function_name
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Get the function arguments
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn args(&self) -> &[String] {
crates/causality-effects/src/domain_effect/evm_effects.rs-        &self.args
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Create a domain context from an effect context
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/evm_effects.rs-        DomainContext::new(context)
crates/causality-effects/src/domain_effect/evm_effects.rs-    }
crates/causality-effects/src/domain_effect/evm_effects.rs-    
crates/causality-effects/src/domain_effect/evm_effects.rs:    /// Map the domain result to an effect outcome
crates/causality-effects/src/domain_effect/evm_effects.rs-    pub fn map_outcome(&self, result: DomainResult<u64>) -> EffectResult<EffectOutcome> {
--
crates/causality-effects/src/domain_effect/evm_effects.rs-            Ok(gas) => {
crates/causality-effects/src/domain_effect/evm_effects.rs-                let mut outcome = EffectOutcome::success(self.id.clone());
crates/causality-effects/src/domain_effect/evm_effects.rs-                outcome = outcome.with_data("gas_estimate", gas.to_string());
--
crates/causality-effects/src/domain_effect/evm_effects.rs:/// Create a new EVM contract view call effect
crates/causality-effects/src/domain_effect/evm_effects.rs-pub fn evm_view_call(
--
crates/causality-effects/src/domain_effect/evm_effects.rs-    contract_address: impl Into<String>,
crates/causality-effects/src/domain_effect/evm_effects.rs-    function_name: impl Into<String>,
crates/causality-effects/src/domain_effect/evm_effects.rs-    args: Vec<String>
--
crates/causality-effects/src/domain_effect/evm_effects.rs:/// Create a new EVM contract transaction call effect
crates/causality-effects/src/domain_effect/evm_effects.rs-pub fn evm_transaction_call(
--
crates/causality-effects/src/domain_effect/evm_effects.rs-    contract_address: impl Into<String>,
crates/causality-effects/src/domain_effect/evm_effects.rs-    function_name: impl Into<String>,
crates/causality-effects/src/domain_effect/evm_effects.rs-    args: Vec<String>
--
crates/causality-effects/src/domain_effect/evm_effects.rs:/// Query EVM account balance
crates/causality-effects/src/domain_effect/evm_effects.rs-pub fn evm_balance(domain_id: impl Into<String>, address: impl Into<String>) -> EvmStateQueryEffect {
crates/causality-effects/src/domain_effect/evm_effects.rs-    EvmStateQueryEffect::balance(domain_id, address)
crates/causality-effects/src/domain_effect/evm_effects.rs-}
crates/causality-effects/src/domain_effect/evm_effects.rs-
crates/causality-effects/src/domain_effect/evm_effects.rs:/// Query EVM storage
crates/causality-effects/src/domain_effect/evm_effects.rs-pub fn evm_storage(
--
crates/causality-effects/src/domain_effect/evm_effects.rs-    address: impl Into<String>, 
crates/causality-effects/src/domain_effect/evm_effects.rs-    slot: impl Into<String>
crates/causality-effects/src/domain_effect/evm_effects.rs-) -> EvmStateQueryEffect {
--
crates/causality-effects/src/domain_effect/evm_effects.rs:/// Query EVM account code
crates/causality-effects/src/domain_effect/evm_effects.rs-pub fn evm_code(domain_id: impl Into<String>, address: impl Into<String>) -> EvmStateQueryEffect {
crates/causality-effects/src/domain_effect/evm_effects.rs-    EvmStateQueryEffect::code(domain_id, address)
crates/causality-effects/src/domain_effect/evm_effects.rs-}
crates/causality-effects/src/domain_effect/evm_effects.rs-
crates/causality-effects/src/domain_effect/evm_effects.rs:/// Query EVM transaction
crates/causality-effects/src/domain_effect/evm_effects.rs-pub fn evm_transaction(domain_id: impl Into<String>, tx_hash: impl Into<String>) -> EvmStateQueryEffect {
crates/causality-effects/src/domain_effect/evm_effects.rs-    EvmStateQueryEffect::transaction(domain_id, tx_hash)
crates/causality-effects/src/domain_effect/evm_effects.rs-}
crates/causality-effects/src/domain_effect/evm_effects.rs-
crates/causality-effects/src/domain_effect/evm_effects.rs:/// Query EVM block
crates/causality-effects/src/domain_effect/evm_effects.rs-pub fn evm_block(domain_id: impl Into<String>, block_id: impl Into<String>) -> EvmStateQueryEffect {
crates/causality-effects/src/domain_effect/evm_effects.rs-    EvmStateQueryEffect::block(domain_id, block_id)
crates/causality-effects/src/domain_effect/evm_effects.rs-}
crates/causality-effects/src/domain_effect/evm_effects.rs-
crates/causality-effects/src/domain_effect/evm_effects.rs:/// Estimate gas for an EVM transaction
crates/causality-effects/src/domain_effect/evm_effects.rs-pub fn evm_estimate_gas(
--
crates/causality-effects/src/domain_effect/domain_registry.rs-///
crates/causality-effects/src/domain_effect/domain_registry.rs:/// This registry implements both the DomainAdapterRegistry trait from the
crates/causality-effects/src/domain_effect/domain_registry.rs:/// Domain module and connects to the Effect System to enable bidirectional
crates/causality-effects/src/domain_effect/domain_registry.rs:/// integration.
crates/causality-effects/src/domain_effect/domain_registry.rs-#[derive(Debug)]
crates/causality-effects/src/domain_effect/domain_registry.rs-pub struct EffectDomainRegistry {
--
crates/causality-effects/src/domain_effect/domain_registry.rs-    adapters: RwLock<HashMap<DomainId, Arc<dyn DomainAdapter>>>,
crates/causality-effects/src/domain_effect/domain_registry.rs-}
crates/causality-effects/src/domain_effect/domain_registry.rs-
crates/causality-effects/src/domain_effect/domain_registry.rs-impl EffectDomainRegistry {
crates/causality-effects/src/domain_effect/domain_registry.rs:    /// Create a new domain registry
crates/causality-effects/src/domain_effect/domain_registry.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/domain_effect/domain_registry.rs-            factories: RwLock::new(Vec::new()),
crates/causality-effects/src/domain_effect/domain_registry.rs-            adapters: RwLock::new(HashMap::new()),
crates/causality-effects/src/domain_effect/domain_registry.rs-        }
--
crates/causality-effects/src/domain_effect/domain_registry.rs:    /// Execute a domain query effect
crates/causality-effects/src/domain_effect/domain_registry.rs-    pub async fn execute_query(&self, effect: &DomainQueryEffect, context: &EffectContext) -> EffectResult<EffectOutcome> {
--
crates/causality-effects/src/domain_effect/domain_registry.rs-        let domain_id = effect.domain_id();
crates/causality-effects/src/domain_effect/domain_registry.rs-        
crates/causality-effects/src/domain_effect/domain_registry.rs-        // Get the domain adapter
--
crates/causality-effects/src/domain_effect/domain_registry.rs:    /// Execute a domain transaction effect
crates/causality-effects/src/domain_effect/domain_registry.rs-    pub async fn execute_transaction(&self, effect: &DomainTransactionEffect, context: &EffectContext) -> EffectResult<EffectOutcome> {
--
crates/causality-effects/src/domain_effect/domain_registry.rs-        let domain_id = effect.domain_id();
crates/causality-effects/src/domain_effect/domain_registry.rs-        
crates/causality-effects/src/domain_effect/domain_registry.rs-        // Get the domain adapter
--
crates/causality-effects/src/domain_effect/domain_registry.rs:    /// Execute a domain time map effect
crates/causality-effects/src/domain_effect/domain_registry.rs-    pub async fn execute_time_map(&self, effect: &DomainTimeMapEffect, context: &EffectContext) -> EffectResult<EffectOutcome> {
--
crates/causality-effects/src/domain_effect/domain_registry.rs-        let domain_id = effect.domain_id();
crates/causality-effects/src/domain_effect/domain_registry.rs-        
crates/causality-effects/src/domain_effect/domain_registry.rs-        // Get the domain adapter
--
crates/causality-effects/src/domain_effect/domain_registry.rs:    /// Execute a domain capability effect
crates/causality-effects/src/domain_effect/domain_registry.rs-    pub async fn execute_capability(&self, effect: &DomainCapabilityEffect, context: &EffectContext) -> EffectResult<EffectOutcome> {
--
crates/causality-effects/src/domain_effect/domain_registry.rs-        let domain_id = effect.domain_id();
crates/causality-effects/src/domain_effect/domain_registry.rs-        
crates/causality-effects/src/domain_effect/domain_registry.rs-        // Get the domain adapter
--
crates/causality-effects/src/domain_effect/domain_registry.rs:    /// Execute a domain selection effect
crates/causality-effects/src/domain_effect/domain_registry.rs-    pub async fn execute_selection(&self, effect: &DomainSelectionEffect, context: &EffectContext) -> EffectResult<EffectOutcome> {
crates/causality-effects/src/domain_effect/domain_registry.rs-        // Use the DomainSelectionHandler trait implementation
crates/causality-effects/src/domain_effect/domain_registry.rs-        self.execute_domain_selection(effect, context).await
crates/causality-effects/src/domain_effect/domain_registry.rs-    }
crates/causality-effects/src/domain_effect/domain_registry.rs-    
crates/causality-effects/src/domain_effect/domain_registry.rs:    /// Get all adapter instances
crates/causality-effects/src/domain_effect/domain_registry.rs-    pub async fn get_all_adapters(&self) -> Vec<Arc<dyn DomainAdapter>> {
--
crates/causality-effects/src/domain_effect/domain_registry.rs-        let factories = self.factories.read().unwrap();
crates/causality-effects/src/domain_effect/domain_registry.rs-        let mut domain_types = Vec::new();
crates/causality-effects/src/domain_effect/domain_registry.rs-        
--
crates/causality-effects/src/domain_effect/domain_registry.rs:    /// Get adapter for domain ID
crates/causality-effects/src/domain_effect/domain_registry.rs-    pub async fn get_adapter(&self, domain_id: &DomainId) -> DomainResult<Arc<dyn DomainAdapter>> {
--
crates/causality-effects/src/domain_effect/domain_registry.rs-            let adapters = self.adapters.read().unwrap();
crates/causality-effects/src/domain_effect/domain_registry.rs-            if let Some(adapter) = adapters.get(domain_id) {
--
crates/causality-effects/src/domain_effect/domain_registry.rs:/// Extension trait for domain effect handling
crates/causality-effects/src/domain_effect/domain_registry.rs-#[async_trait]
crates/causality-effects/src/domain_effect/domain_registry.rs-pub trait DomainEffectHandler {
--
crates/causality-effects/src/domain_effect/domain_registry.rs-
crates/causality-effects/src/domain_effect/domain_registry.rs-#[async_trait]
crates/causality-effects/src/domain_effect/domain_registry.rs-impl DomainEffectHandler for EffectDomainRegistry {
--
crates/causality-effects/src/domain_effect/domain_registry.rs:/// Factory for creating effect-integrated domain adapters
crates/causality-effects/src/domain_effect/domain_registry.rs-pub struct EffectDomainAdapterFactory<F>
--
crates/causality-effects/src/domain_effect/domain_registry.rs-    F: DomainAdapterFactory + Send + Sync + 'static,
crates/causality-effects/src/domain_effect/domain_registry.rs-{
crates/causality-effects/src/domain_effect/domain_registry.rs-    inner_factory: Arc<F>,
--
crates/causality-effects/src/domain_effect/domain_registry.rs:    /// Create a new effect-integrated domain adapter factory
crates/causality-effects/src/domain_effect/domain_registry.rs-    pub fn new(inner_factory: F) -> Self {
--
crates/causality-effects/src/domain_effect/domain_registry.rs-            inner_factory: Arc::new(inner_factory),
crates/causality-effects/src/domain_effect/domain_registry.rs-        }
crates/causality-effects/src/domain_effect/domain_registry.rs-    }
--
crates/causality-effects/src/domain_effect/domain_registry.rs:/// Create a domain registry
crates/causality-effects/src/domain_effect/domain_registry.rs-pub fn create_domain_registry() -> EffectDomainRegistry {
--
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:/// CosmWasm Contract Execute Effect
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-///
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:/// This effect represents an execution of a smart contract on a CosmWasm-compatible blockchain.
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-#[derive(Debug)]
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-pub struct CosmWasmExecuteEffect {
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    parameters: HashMap<String, String>,
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-}
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-impl CosmWasmExecuteEffect {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Create a new CosmWasm contract execute effect
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn new(
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        contract_address: impl Into<String>,
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        msg: impl Into<String>,
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    ) -> Self {
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Add funds to send with the execution
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn with_funds(mut self, denom: impl Into<String>, amount: u128) -> Self {
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        funds.push((denom.into(), amount));
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Add a parameter
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self.parameters.insert(key.into(), value.into());
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Set the sender address
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn with_sender(self, sender: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self.with_parameter("sender", sender)
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Set the gas limit parameter
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn with_gas_limit(self, gas_limit: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self.with_parameter("gas_limit", gas_limit)
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Set the fee amount
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn with_fee(self, fee_amount: impl Into<String>, fee_denom: impl Into<String>) -> Self {
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        result = result.with_parameter("fee_denom", fee_denom);
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        result
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Get the domain ID
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        &self.domain_id
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Get the contract address
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn contract_address(&self) -> &str {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        &self.contract_address
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Get the execute message
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn msg(&self) -> &str {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        &self.msg
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Get the funds to send with execution
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn funds(&self) -> Option<&Vec<(String, u128)>> {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self.funds.as_ref()
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Create a domain context from an effect context
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        DomainContext::new(context)
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Map the domain result to an effect outcome
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn map_outcome(&self, result: DomainResult<String>) -> EffectResult<EffectOutcome> {
--
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:/// CosmWasm Contract Query Effect
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-///
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:/// This effect represents a query to a smart contract on a CosmWasm-compatible blockchain.
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-#[derive(Debug)]
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-pub struct CosmWasmQueryEffect {
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    parameters: HashMap<String, String>,
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-}
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-impl CosmWasmQueryEffect {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Create a new CosmWasm contract query effect
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn new(
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        contract_address: impl Into<String>,
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        query: impl Into<String>,
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    ) -> Self {
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Add a parameter
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self.parameters.insert(key.into(), value.into());
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Specify a block height to query at
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn at_height(self, height: u64) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self.with_parameter("height", height.to_string())
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Get the domain ID
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        &self.domain_id
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Get the contract address
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn contract_address(&self) -> &str {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        &self.contract_address
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Get the query message
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn query(&self) -> &str {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        &self.query
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Create a domain context from an effect context
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        DomainContext::new(context)
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Map the domain result to an effect outcome
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn map_outcome(&self, result: DomainResult<String>) -> EffectResult<EffectOutcome> {
--
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:/// CosmWasm Contract Instantiate Effect
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-///
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:/// This effect represents instantiation of a new smart contract on a CosmWasm-compatible blockchain.
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-#[derive(Debug)]
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-pub struct CosmWasmInstantiateEffect {
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    parameters: HashMap<String, String>,
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-}
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-impl CosmWasmInstantiateEffect {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Create a new CosmWasm contract instantiate effect
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn new(
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        code_id: u64,
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        msg: impl Into<String>,
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        label: impl Into<String>,
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Add funds to send with the instantiation
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn with_funds(mut self, denom: impl Into<String>, amount: u128) -> Self {
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        funds.push((denom.into(), amount));
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Add a parameter
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self.parameters.insert(key.into(), value.into());
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Set the sender address
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn with_sender(self, sender: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self.with_parameter("sender", sender)
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Set the admin address
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn with_admin(self, admin: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self.with_parameter("admin", admin)
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Set the gas limit parameter
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn with_gas_limit(self, gas_limit: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self.with_parameter("gas_limit", gas_limit)
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Set the fee amount
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn with_fee(self, fee_amount: impl Into<String>, fee_denom: impl Into<String>) -> Self {
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        result = result.with_parameter("fee_denom", fee_denom);
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        result
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Get the domain ID
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        &self.domain_id
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Get the code ID
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn code_id(&self) -> u64 {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self.code_id
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Get the instantiate message
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn msg(&self) -> &str {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        &self.msg
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Get the contract label
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn label(&self) -> &str {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        &self.label
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Get the funds to send with instantiation
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn funds(&self) -> Option<&Vec<(String, u128)>> {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self.funds.as_ref()
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Create a domain context from an effect context
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        DomainContext::new(context)
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Map the domain result to an effect outcome
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn map_outcome(&self, result: DomainResult<(String, String)>) -> EffectResult<EffectOutcome> {
--
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:/// CosmWasm Code Upload Effect
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-///
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:/// This effect represents uploading new Wasm code to a CosmWasm-compatible blockchain.
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-#[derive(Debug)]
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-pub struct CosmWasmCodeUploadEffect {
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    parameters: HashMap<String, String>,
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-}
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-impl CosmWasmCodeUploadEffect {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Create a new CosmWasm code upload effect
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn new(
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        wasm_bytecode: impl Into<String>,
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    ) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        Self {
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Add a parameter
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self.parameters.insert(key.into(), value.into());
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Set the sender address
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn with_sender(self, sender: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self.with_parameter("sender", sender)
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Set the gas limit parameter
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn with_gas_limit(self, gas_limit: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        self.with_parameter("gas_limit", gas_limit)
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Set the fee amount
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn with_fee(self, fee_amount: impl Into<String>, fee_denom: impl Into<String>) -> Self {
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        result = result.with_parameter("fee_denom", fee_denom);
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        result
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Get the domain ID
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        &self.domain_id
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Get the Wasm bytecode
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn wasm_bytecode(&self) -> &str {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        &self.wasm_bytecode
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Create a domain context from an effect context
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-        DomainContext::new(context)
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    }
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    /// Map the domain result to an effect outcome
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    pub fn map_outcome(&self, result: DomainResult<(String, u64)>) -> EffectResult<EffectOutcome> {
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-            Ok((tx_hash, code_id)) => {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-                let mut outcome = EffectOutcome::success(self.id.clone());
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-                outcome = outcome.with_data("tx_hash", tx_hash);
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:/// Create a new CosmWasm contract execute effect
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-pub fn cosmwasm_execute(
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    contract_address: impl Into<String>,
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    msg: impl Into<String>,
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-) -> CosmWasmExecuteEffect {
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:/// Create a new CosmWasm contract query effect
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-pub fn cosmwasm_query(
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    contract_address: impl Into<String>,
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    query: impl Into<String>,
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-) -> CosmWasmQueryEffect {
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:/// Create a new CosmWasm contract instantiate effect
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-pub fn cosmwasm_instantiate(
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    code_id: u64,
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    msg: impl Into<String>,
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    label: impl Into<String>,
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:/// Create a new CosmWasm code upload effect
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-pub fn cosmwasm_upload(
--
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-) -> CosmWasmCodeUploadEffect {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs-    CosmWasmCodeUploadEffect::new(domain_id, wasm_bytecode)
--
crates/causality-effects/src/domain_effect/domain_selection.rs:/// Criteria for domain selection
crates/causality-effects/src/domain_effect/domain_selection.rs-#[derive(Debug, Clone)]
crates/causality-effects/src/domain_effect/domain_selection.rs-pub enum SelectionCriteria {
--
crates/causality-effects/src/domain_effect/domain_selection.rs-    Custom(String), // The string is a serialized representation of selection criteria
crates/causality-effects/src/domain_effect/domain_selection.rs-}
crates/causality-effects/src/domain_effect/domain_selection.rs-
crates/causality-effects/src/domain_effect/domain_selection.rs:/// Domain selection effect
crates/causality-effects/src/domain_effect/domain_selection.rs-#[derive(Debug)]
crates/causality-effects/src/domain_effect/domain_selection.rs-pub struct DomainSelectionEffect {
--
crates/causality-effects/src/domain_effect/domain_selection.rs-    parameters: HashMap<String, String>,
crates/causality-effects/src/domain_effect/domain_selection.rs-}
crates/causality-effects/src/domain_effect/domain_selection.rs-
crates/causality-effects/src/domain_effect/domain_selection.rs-impl DomainSelectionEffect {
crates/causality-effects/src/domain_effect/domain_selection.rs:    /// Create a new domain selection effect
crates/causality-effects/src/domain_effect/domain_selection.rs-    pub fn new(criteria: SelectionCriteria) -> Self {
--
crates/causality-effects/src/domain_effect/domain_selection.rs-            id: EffectId::new(),
crates/causality-effects/src/domain_effect/domain_selection.rs-            criteria,
crates/causality-effects/src/domain_effect/domain_selection.rs-            limit: None,
--
crates/causality-effects/src/domain_effect/domain_selection.rs:    /// Set the maximum number of results to return
crates/causality-effects/src/domain_effect/domain_selection.rs-    pub fn with_limit(mut self, limit: usize) -> Self {
crates/causality-effects/src/domain_effect/domain_selection.rs-        self.limit = Some(limit);
crates/causality-effects/src/domain_effect/domain_selection.rs-        self
crates/causality-effects/src/domain_effect/domain_selection.rs-    }
crates/causality-effects/src/domain_effect/domain_selection.rs-    
crates/causality-effects/src/domain_effect/domain_selection.rs:    /// Add a parameter
crates/causality-effects/src/domain_effect/domain_selection.rs-    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/domain_selection.rs-        self.parameters.insert(key.into(), value.into());
crates/causality-effects/src/domain_effect/domain_selection.rs-        self
crates/causality-effects/src/domain_effect/domain_selection.rs-    }
crates/causality-effects/src/domain_effect/domain_selection.rs-    
crates/causality-effects/src/domain_effect/domain_selection.rs:    /// Get the selection criteria
crates/causality-effects/src/domain_effect/domain_selection.rs-    pub fn criteria(&self) -> &SelectionCriteria {
--
crates/causality-effects/src/domain_effect/domain_selection.rs:/// Handler for domain selection effects
crates/causality-effects/src/domain_effect/domain_selection.rs-///
crates/causality-effects/src/domain_effect/domain_selection.rs:/// This trait extends the DomainEffectHandler to add methods
crates/causality-effects/src/domain_effect/domain_selection.rs:/// for executing domain selection effects.
crates/causality-effects/src/domain_effect/domain_selection.rs-#[async_trait]
crates/causality-effects/src/domain_effect/domain_selection.rs-pub trait DomainSelectionHandler {
--
crates/causality-effects/src/domain_effect/domain_selection.rs-where 
crates/causality-effects/src/domain_effect/domain_selection.rs-    T: DomainAdapterRegistry + Send + Sync + 'static
crates/causality-effects/src/domain_effect/domain_selection.rs-{
--
crates/causality-effects/src/domain_effect/domain_selection.rs:/// Select domains by type
crates/causality-effects/src/domain_effect/domain_selection.rs-pub fn select_domains_by_type(domain_type: impl Into<String>) -> DomainSelectionEffect {
crates/causality-effects/src/domain_effect/domain_selection.rs-    DomainSelectionEffect::new(SelectionCriteria::DomainType(domain_type.into()))
crates/causality-effects/src/domain_effect/domain_selection.rs-}
crates/causality-effects/src/domain_effect/domain_selection.rs-
crates/causality-effects/src/domain_effect/domain_selection.rs:/// Select domains by capability
crates/causality-effects/src/domain_effect/domain_selection.rs-pub fn select_domains_by_capability(capability: impl Into<String>) -> DomainSelectionEffect {
crates/causality-effects/src/domain_effect/domain_selection.rs-    DomainSelectionEffect::new(SelectionCriteria::Capability(capability.into()))
crates/causality-effects/src/domain_effect/domain_selection.rs-}
crates/causality-effects/src/domain_effect/domain_selection.rs-
crates/causality-effects/src/domain_effect/domain_selection.rs:/// Select domains by both type and capability
crates/causality-effects/src/domain_effect/domain_selection.rs-pub fn select_domains_by_type_and_capability(
--
crates/causality-effects/src/domain_effect/domain_selection.rs-    capability: impl Into<String>
crates/causality-effects/src/domain_effect/domain_selection.rs-) -> DomainSelectionEffect {
crates/causality-effects/src/domain_effect/domain_selection.rs-    DomainSelectionEffect::new(SelectionCriteria::TypeAndCapability(
--
crates/causality-effects/src/domain_effect/domain_selection.rs:/// Select domains by name pattern
crates/causality-effects/src/domain_effect/domain_selection.rs-pub fn select_domains_by_name(pattern: impl Into<String>) -> DomainSelectionEffect {
crates/causality-effects/src/domain_effect/domain_selection.rs-    DomainSelectionEffect::new(SelectionCriteria::NamePattern(pattern.into()))
crates/causality-effects/src/domain_effect/domain_selection.rs-}
crates/causality-effects/src/domain_effect/domain_selection.rs-
crates/causality-effects/src/domain_effect/domain_selection.rs:/// Select domains by custom criteria
crates/causality-effects/src/domain_effect/domain_selection.rs-pub fn select_domains_custom(criteria: impl Into<String>) -> DomainSelectionEffect {
--
--
crates/causality-effects/src/domain_effect/zk_effects.rs:/// ZK Proof Verification Effect
crates/causality-effects/src/domain_effect/zk_effects.rs-///
crates/causality-effects/src/domain_effect/zk_effects.rs:/// Represents an effect for verifying a zero-knowledge proof
crates/causality-effects/src/domain_effect/zk_effects.rs-#[derive(Debug)]
crates/causality-effects/src/domain_effect/zk_effects.rs-pub struct ZkProveEffect {
--
crates/causality-effects/src/domain_effect/zk_effects.rs-    parameters: HashMap<String, String>,
crates/causality-effects/src/domain_effect/zk_effects.rs-}
crates/causality-effects/src/domain_effect/zk_effects.rs-
crates/causality-effects/src/domain_effect/zk_effects.rs-impl ZkProveEffect {
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Create a new ZK proof generation effect
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn new(
--
crates/causality-effects/src/domain_effect/zk_effects.rs-        circuit_id: impl Into<String>,
crates/causality-effects/src/domain_effect/zk_effects.rs-        private_inputs: impl Into<String>,
crates/causality-effects/src/domain_effect/zk_effects.rs-    ) -> Self {
--
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Add a public input
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn with_public_input(mut self, input: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/zk_effects.rs-        self.public_inputs.push(input.into());
crates/causality-effects/src/domain_effect/zk_effects.rs-        self
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Add multiple public inputs
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn with_public_inputs(mut self, inputs: Vec<impl Into<String>>) -> Self {
--
crates/causality-effects/src/domain_effect/zk_effects.rs-            self.public_inputs.push(input.into());
crates/causality-effects/src/domain_effect/zk_effects.rs-        }
crates/causality-effects/src/domain_effect/zk_effects.rs-        self
--
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Add a parameter
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/zk_effects.rs-        self.parameters.insert(key.into(), value.into());
crates/causality-effects/src/domain_effect/zk_effects.rs-        self
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Get the domain ID
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/zk_effects.rs-        &self.domain_id
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Get the circuit ID
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn circuit_id(&self) -> &str {
crates/causality-effects/src/domain_effect/zk_effects.rs-        &self.circuit_id
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Get the private inputs
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn private_inputs(&self) -> &str {
crates/causality-effects/src/domain_effect/zk_effects.rs-        &self.private_inputs
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Get the public inputs
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn public_inputs(&self) -> &[String] {
crates/causality-effects/src/domain_effect/zk_effects.rs-        &self.public_inputs
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Create a domain context from an effect context
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/zk_effects.rs-        DomainContext::new(context, &self.domain_id)
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Map a domain result to an effect outcome
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn map_outcome(&self, result: DomainResult<String>) -> EffectResult<EffectOutcome> {
--
--
crates/causality-effects/src/domain_effect/zk_effects.rs:/// ZK Proof Verification Effect
crates/causality-effects/src/domain_effect/zk_effects.rs-///
crates/causality-effects/src/domain_effect/zk_effects.rs:/// Represents an effect for verifying a zero-knowledge proof
crates/causality-effects/src/domain_effect/zk_effects.rs-#[derive(Debug)]
crates/causality-effects/src/domain_effect/zk_effects.rs-pub struct ZkVerifyEffect {
--
crates/causality-effects/src/domain_effect/zk_effects.rs-    parameters: HashMap<String, String>,
crates/causality-effects/src/domain_effect/zk_effects.rs-}
crates/causality-effects/src/domain_effect/zk_effects.rs-
crates/causality-effects/src/domain_effect/zk_effects.rs-impl ZkVerifyEffect {
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Create a new ZK proof verification effect
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn new(
--
crates/causality-effects/src/domain_effect/zk_effects.rs-        verification_key_id: impl Into<String>,
crates/causality-effects/src/domain_effect/zk_effects.rs-        proof: impl Into<String>,
crates/causality-effects/src/domain_effect/zk_effects.rs-    ) -> Self {
--
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Add a public input
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn with_public_input(mut self, input: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/zk_effects.rs-        self.public_inputs.push(input.into());
crates/causality-effects/src/domain_effect/zk_effects.rs-        self
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Add multiple public inputs
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn with_public_inputs(mut self, inputs: Vec<impl Into<String>>) -> Self {
--
crates/causality-effects/src/domain_effect/zk_effects.rs-            self.public_inputs.push(input.into());
crates/causality-effects/src/domain_effect/zk_effects.rs-        }
crates/causality-effects/src/domain_effect/zk_effects.rs-        self
--
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Add a parameter
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/zk_effects.rs-        self.parameters.insert(key.into(), value.into());
crates/causality-effects/src/domain_effect/zk_effects.rs-        self
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Get the domain ID
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/zk_effects.rs-        &self.domain_id
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Get the verification key ID
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn verification_key_id(&self) -> &str {
crates/causality-effects/src/domain_effect/zk_effects.rs-        &self.verification_key_id
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Get the proof
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn proof(&self) -> &str {
crates/causality-effects/src/domain_effect/zk_effects.rs-        &self.proof
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Get the public inputs
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn public_inputs(&self) -> &[String] {
crates/causality-effects/src/domain_effect/zk_effects.rs-        &self.public_inputs
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Create a domain context from an effect context
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/zk_effects.rs-        DomainContext::new(context, &self.domain_id)
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Map a domain result to an effect outcome
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn map_outcome(&self, result: DomainResult<bool>) -> EffectResult<EffectOutcome> {
--
--
crates/causality-effects/src/domain_effect/zk_effects.rs:/// ZK Witness Creation Effect
crates/causality-effects/src/domain_effect/zk_effects.rs-///
crates/causality-effects/src/domain_effect/zk_effects.rs:/// Represents an effect for creating a witness for a ZK circuit
crates/causality-effects/src/domain_effect/zk_effects.rs-#[derive(Debug)]
crates/causality-effects/src/domain_effect/zk_effects.rs-pub struct ZkWitnessEffect {
--
crates/causality-effects/src/domain_effect/zk_effects.rs-    parameters: HashMap<String, String>,
crates/causality-effects/src/domain_effect/zk_effects.rs-}
crates/causality-effects/src/domain_effect/zk_effects.rs-
crates/causality-effects/src/domain_effect/zk_effects.rs-impl ZkWitnessEffect {
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Create a new ZK witness creation effect
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn new(
--
crates/causality-effects/src/domain_effect/zk_effects.rs-        circuit_id: impl Into<String>,
crates/causality-effects/src/domain_effect/zk_effects.rs-        witness_data: impl Into<String>,
crates/causality-effects/src/domain_effect/zk_effects.rs-    ) -> Self {
--
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Add a parameter
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/zk_effects.rs-        self.parameters.insert(key.into(), value.into());
crates/causality-effects/src/domain_effect/zk_effects.rs-        self
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Get the domain ID
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/zk_effects.rs-        &self.domain_id
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Get the circuit ID
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn circuit_id(&self) -> &str {
crates/causality-effects/src/domain_effect/zk_effects.rs-        &self.circuit_id
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Get the witness data
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn witness_data(&self) -> &str {
crates/causality-effects/src/domain_effect/zk_effects.rs-        &self.witness_data
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Create a domain context from an effect context
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/zk_effects.rs-        DomainContext::new(context, &self.domain_id)
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Map a domain result to an effect outcome
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn map_outcome(&self, result: DomainResult<String>) -> EffectResult<EffectOutcome> {
--
--
crates/causality-effects/src/domain_effect/zk_effects.rs:/// ZK Proof Composition Effect
crates/causality-effects/src/domain_effect/zk_effects.rs-///
crates/causality-effects/src/domain_effect/zk_effects.rs:/// Represents an effect for composing multiple ZK proofs into a single proof
crates/causality-effects/src/domain_effect/zk_effects.rs-#[derive(Debug)]
crates/causality-effects/src/domain_effect/zk_effects.rs-pub struct ZkProofCompositionEffect {
--
crates/causality-effects/src/domain_effect/zk_effects.rs-    parameters: HashMap<String, String>,
crates/causality-effects/src/domain_effect/zk_effects.rs-}
crates/causality-effects/src/domain_effect/zk_effects.rs-
crates/causality-effects/src/domain_effect/zk_effects.rs-impl ZkProofCompositionEffect {
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Create a new ZK proof composition effect
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn new(
--
crates/causality-effects/src/domain_effect/zk_effects.rs-        composition_circuit_id: impl Into<String>,
crates/causality-effects/src/domain_effect/zk_effects.rs-    ) -> Self {
crates/causality-effects/src/domain_effect/zk_effects.rs-        Self {
--
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Add a source proof hash
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn with_source_proof_hash(mut self, hash: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/zk_effects.rs-        self.source_proof_hashes.push(hash.into());
crates/causality-effects/src/domain_effect/zk_effects.rs-        self
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Add multiple source proof hashes
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn with_source_proof_hashes(mut self, hashes: Vec<impl Into<String>>) -> Self {
--
crates/causality-effects/src/domain_effect/zk_effects.rs-            self.source_proof_hashes.push(hash.into());
crates/causality-effects/src/domain_effect/zk_effects.rs-        }
crates/causality-effects/src/domain_effect/zk_effects.rs-        self
--
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Add a parameter
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/zk_effects.rs-        self.parameters.insert(key.into(), value.into());
crates/causality-effects/src/domain_effect/zk_effects.rs-        self
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Get the domain ID
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/zk_effects.rs-        &self.domain_id
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Get the composition circuit ID
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn composition_circuit_id(&self) -> &str {
crates/causality-effects/src/domain_effect/zk_effects.rs-        &self.composition_circuit_id
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Get the source proof hashes
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn source_proof_hashes(&self) -> &[String] {
crates/causality-effects/src/domain_effect/zk_effects.rs-        &self.source_proof_hashes
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Create a domain context from an effect context
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/zk_effects.rs-        DomainContext::new(context, &self.domain_id)
crates/causality-effects/src/domain_effect/zk_effects.rs-    }
crates/causality-effects/src/domain_effect/zk_effects.rs-    
crates/causality-effects/src/domain_effect/zk_effects.rs:    /// Map a domain result to an effect outcome
crates/causality-effects/src/domain_effect/zk_effects.rs-    pub fn map_outcome(&self, result: DomainResult<String>) -> EffectResult<EffectOutcome> {
--
crates/causality-effects/src/domain_effect/zk_effects.rs-            Ok(result_proof_hash) => {
crates/causality-effects/src/domain_effect/zk_effects.rs-                let outcome = EffectOutcome::success(self.id.clone())
crates/causality-effects/src/domain_effect/zk_effects.rs-                    .with_data("result_proof_hash", result_proof_hash);
--
crates/causality-effects/src/domain_effect/zk_effects.rs:/// Create a new ZK prove effect
crates/causality-effects/src/domain_effect/zk_effects.rs-pub fn zk_prove(
--
crates/causality-effects/src/domain_effect/zk_effects.rs-    circuit_id: impl Into<String>,
crates/causality-effects/src/domain_effect/zk_effects.rs-    private_inputs: impl Into<String>,
crates/causality-effects/src/domain_effect/zk_effects.rs-) -> ZkProveEffect {
--
crates/causality-effects/src/domain_effect/zk_effects.rs:/// Create a new ZK verify effect
crates/causality-effects/src/domain_effect/zk_effects.rs-pub fn zk_verify(
--
crates/causality-effects/src/domain_effect/zk_effects.rs-    verification_key_id: impl Into<String>,
crates/causality-effects/src/domain_effect/zk_effects.rs-    proof: impl Into<String>,
crates/causality-effects/src/domain_effect/zk_effects.rs-) -> ZkVerifyEffect {
--
crates/causality-effects/src/domain_effect/zk_effects.rs:/// Create a new ZK witness effect
crates/causality-effects/src/domain_effect/zk_effects.rs-pub fn zk_witness(
--
crates/causality-effects/src/domain_effect/zk_effects.rs-    circuit_id: impl Into<String>,
crates/causality-effects/src/domain_effect/zk_effects.rs-    witness_data: impl Into<String>,
crates/causality-effects/src/domain_effect/zk_effects.rs-) -> ZkWitnessEffect {
--
crates/causality-effects/src/domain_effect/zk_effects.rs:/// Create a new ZK proof composition effect
crates/causality-effects/src/domain_effect/zk_effects.rs-pub fn zk_compose(
--
crates/causality-effects/src/domain_effect/zk_effects.rs-    composition_circuit_id: impl Into<String>,
crates/causality-effects/src/domain_effect/zk_effects.rs-) -> ZkProofCompositionEffect {
crates/causality-effects/src/domain_effect/zk_effects.rs-    ZkProofCompositionEffect::new(domain_id, composition_circuit_id)
--
crates/causality-effects/src/domain_effect/examples.rs:/// Example showing how to query facts from a domain adapter
crates/causality-effects/src/domain_effect/examples.rs-pub async fn query_domain_example() {
--
crates/causality-effects/src/domain_effect/examples.rs-    use std::sync::Arc;
crates/causality-effects/src/domain_effect/examples.rs-    
crates/causality-effects/src/domain_effect/examples.rs-    use causality_domain::domain::DomainId;
--
crates/causality-effects/src/domain_effect/examples.rs:/// Example showing how to submit a transaction to a domain
crates/causality-effects/src/domain_effect/examples.rs-pub async fn submit_transaction_example() {
--
crates/causality-effects/src/domain_effect/examples.rs-    use std::sync::Arc;
crates/causality-effects/src/domain_effect/examples.rs-    
crates/causality-effects/src/domain_effect/examples.rs-    use causality_domain::domain::{DomainId, Transaction};
--
crates/causality-effects/src/domain_effect/examples.rs:/// Example showing how to check domain capabilities
crates/causality-effects/src/domain_effect/examples.rs-pub async fn check_capability_example() {
--
crates/causality-effects/src/domain_effect/examples.rs-    
crates/causality-effects/src/domain_effect/examples.rs-    use causality_domain::domain::DomainId;
crates/causality-effects/src/domain_effect/examples.rs-    
--
crates/causality-effects/src/domain_effect/examples.rs:/// Example showing how to integrate domain effects with your application
crates/causality-effects/src/domain_effect/examples.rs-pub async fn integration_example() {
--
crates/causality-effects/src/domain_effect/examples.rs-    
crates/causality-effects/src/domain_effect/examples.rs-    // Import types we need
crates/causality-effects/src/domain_effect/examples.rs-    use crate::effect::{EffectManager, EffectContext, EffectRegistry};
--
crates/causality-effects/src/domain_effect/examples.rs:/// Example showing how to use domain selection effects
crates/causality-effects/src/domain_effect/examples.rs-pub async fn domain_selection_example() {
--
crates/causality-effects/src/domain_effect/examples.rs-    
crates/causality-effects/src/domain_effect/examples.rs-    use crate::effect::EffectContext;
crates/causality-effects/src/domain_effect/examples.rs-    use crate::domain_effect::{
--
crates/causality-effects/src/domain_effect/examples.rs:/// Example showing how to use EVM-specific effects
crates/causality-effects/src/domain_effect/examples.rs-pub async fn evm_effects_example() {
--
crates/causality-effects/src/domain_effect/examples.rs-    
crates/causality-effects/src/domain_effect/examples.rs-    use crate::effect::EffectContext;
crates/causality-effects/src/domain_effect/examples.rs-    use crate::domain_effect::{
--
crates/causality-effects/src/domain_effect/examples.rs:/// Example showing how to use CosmWasm-specific effects
crates/causality-effects/src/domain_effect/examples.rs-pub async fn cosmwasm_effects_example() {
--
crates/causality-effects/src/domain_effect/examples.rs-    
crates/causality-effects/src/domain_effect/examples.rs-    use crate::effect::EffectContext;
crates/causality-effects/src/domain_effect/examples.rs-    use crate::domain_effect::{
--
crates/causality-effects/src/domain_effect/examples.rs:/// Example showing how to use ZK-specific effects
crates/causality-effects/src/domain_effect/examples.rs-pub async fn zk_effects_example() {
--
crates/causality-effects/src/domain_effect/examples.rs-    
crates/causality-effects/src/domain_effect/examples.rs-    // Define a domain ID for a ZK/Succinct chain
--
crates/causality-effects/src/resource/access.rs:/// Resource access type
crates/causality-effects/src/resource/access.rs-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
crates/causality-effects/src/resource/access.rs-pub enum ResourceAccessType {
--
crates/causality-effects/src/resource/access.rs-    Transfer,
crates/causality-effects/src/resource/access.rs-}
crates/causality-effects/src/resource/access.rs-
crates/causality-effects/src/resource/access.rs:/// Resource access record
crates/causality-effects/src/resource/access.rs-#[derive(Debug, Clone)]
crates/causality-effects/src/resource/access.rs-pub struct ResourceAccess {
crates/causality-effects/src/resource/access.rs:    /// Resource ID
crates/causality-effects/src/resource/access.rs-    pub resource_id: ContentId,
crates/causality-effects/src/resource/access.rs-    
crates/causality-effects/src/resource/access.rs:    /// Access type
crates/causality-effects/src/resource/access.rs-    pub access_type: ResourceAccessType,
crates/causality-effects/src/resource/access.rs-    
crates/causality-effects/src/resource/access.rs:    /// Domain ID where the resource is located
crates/causality-effects/src/resource/access.rs-    pub domain_id: Option<DomainId>,
crates/causality-effects/src/resource/access.rs-    
crates/causality-effects/src/resource/access.rs:    /// Effect ID that requested access
crates/causality-effects/src/resource/access.rs-    pub effect_id: EffectId,
crates/causality-effects/src/resource/access.rs-    
crates/causality-effects/src/resource/access.rs:    /// Whether the access was granted
crates/causality-effects/src/resource/access.rs-    pub granted: bool,
crates/causality-effects/src/resource/access.rs-    
crates/causality-effects/src/resource/access.rs:    /// Timestamp when the access was requested
crates/causality-effects/src/resource/access.rs-    pub timestamp: chrono::DateTime<chrono::Utc>,
crates/causality-effects/src/resource/access.rs-}
crates/causality-effects/src/resource/access.rs-
crates/causality-effects/src/resource/access.rs-impl ResourceAccess {
crates/causality-effects/src/resource/access.rs:    /// Create a new resource access record
crates/causality-effects/src/resource/access.rs-    pub fn new(
--
crates/causality-effects/src/resource/access.rs-        access_type: ResourceAccessType,
crates/causality-effects/src/resource/access.rs-        effect_id: EffectId,
crates/causality-effects/src/resource/access.rs-    ) -> Self {
--
crates/causality-effects/src/resource/access.rs:    /// Create a new resource access with domain
crates/causality-effects/src/resource/access.rs-    pub fn with_domain(
--
crates/causality-effects/src/resource/access.rs-        access_type: ResourceAccessType,
crates/causality-effects/src/resource/access.rs-        domain_id: DomainId,
crates/causality-effects/src/resource/access.rs-        effect_id: EffectId,
--
crates/causality-effects/src/resource/access.rs:    /// Mark the access as granted
crates/causality-effects/src/resource/access.rs-    pub fn grant(&mut self) {
--
crates/causality-effects/src/resource/access.rs-    }
crates/causality-effects/src/resource/access.rs-}
crates/causality-effects/src/resource/access.rs-
crates/causality-effects/src/resource/access.rs:/// Resource access tracker for effects
crates/causality-effects/src/resource/access.rs-#[derive(Debug, Default)]
crates/causality-effects/src/resource/access.rs-pub struct ResourceAccessTracker {
--
crates/causality-effects/src/resource/access.rs-    locks: RwLock<HashMap<ContentId, ResourceAccess>>,
crates/causality-effects/src/resource/access.rs-}
crates/causality-effects/src/resource/access.rs-
crates/causality-effects/src/resource/access.rs-impl ResourceAccessTracker {
crates/causality-effects/src/resource/access.rs:    /// Create a new resource access tracker
crates/causality-effects/src/resource/access.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/resource/access.rs-            accesses_by_resource: RwLock::new(HashMap::new()),
crates/causality-effects/src/resource/access.rs-            accesses_by_effect: RwLock::new(HashMap::new()),
crates/causality-effects/src/resource/access.rs-            accesses_by_domain: RwLock::new(HashMap::new()),
--
crates/causality-effects/src/resource/access.rs:    /// Record a resource access
crates/causality-effects/src/resource/access.rs-    pub fn record_access(&self, access: ResourceAccess) -> Result<()> {
--
crates/causality-effects/src/resource/access.rs-        {
crates/causality-effects/src/resource/access.rs-            let mut map = self.accesses_by_resource.write().unwrap();
crates/causality-effects/src/resource/access.rs-            map.entry(access.resource_id.clone())
--
crates/causality-effects/src/resource/access.rs:    /// Check if a resource is locked
crates/causality-effects/src/resource/access.rs-    pub fn is_resource_locked(&self, resource_id: &ContentId) -> bool {
crates/causality-effects/src/resource/access.rs-        let locks = self.locks.read().unwrap();
crates/causality-effects/src/resource/access.rs-        locks.contains_key(resource_id)
crates/causality-effects/src/resource/access.rs-    }
crates/causality-effects/src/resource/access.rs-    
crates/causality-effects/src/resource/access.rs:    /// Get the lock for a resource
crates/causality-effects/src/resource/access.rs-    pub fn get_resource_lock(&self, resource_id: &ContentId) -> Option<ResourceAccess> {
crates/causality-effects/src/resource/access.rs-        let locks = self.locks.read().unwrap();
crates/causality-effects/src/resource/access.rs-        locks.get(resource_id).cloned()
crates/causality-effects/src/resource/access.rs-    }
crates/causality-effects/src/resource/access.rs-    
crates/causality-effects/src/resource/access.rs:    /// Release a lock on a resource
crates/causality-effects/src/resource/access.rs-    pub fn release_lock(&self, resource_id: &ContentId, effect_id: &EffectId) -> Result<()> {
--
crates/causality-effects/src/resource/access.rs-        
crates/causality-effects/src/resource/access.rs-        // Check if the lock exists and is owned by the effect
crates/causality-effects/src/resource/access.rs-        if let Some(lock) = locks.get(resource_id) {
--
crates/causality-effects/src/resource/access.rs:    /// Get all accesses for a resource
crates/causality-effects/src/resource/access.rs-    pub fn get_resource_accesses(&self, resource_id: &ContentId) -> Vec<ResourceAccess> {
--
crates/causality-effects/src/resource/access.rs-        map.get(resource_id)
crates/causality-effects/src/resource/access.rs-            .cloned()
crates/causality-effects/src/resource/access.rs-            .unwrap_or_default()
--
crates/causality-effects/src/resource/access.rs:    /// Get all accesses for an effect
crates/causality-effects/src/resource/access.rs-    pub fn get_effect_accesses(&self, effect_id: &EffectId) -> Vec<ResourceAccess> {
--
crates/causality-effects/src/resource/access.rs-        map.get(effect_id)
crates/causality-effects/src/resource/access.rs-            .cloned()
crates/causality-effects/src/resource/access.rs-            .unwrap_or_default()
--
crates/causality-effects/src/resource/access.rs:    /// Get all accesses for a domain
crates/causality-effects/src/resource/access.rs-    pub fn get_domain_accesses(&self, domain_id: &DomainId) -> Vec<ResourceAccess> {
--
crates/causality-effects/src/resource/access.rs-        map.get(domain_id)
crates/causality-effects/src/resource/access.rs-            .cloned()
crates/causality-effects/src/resource/access.rs-            .unwrap_or_default()
--
crates/causality-effects/src/resource/access.rs:/// Effect trait extension for resource access tracking
crates/causality-effects/src/resource/access.rs-pub trait ResourceAccessTracking: Effect {
--
crates/causality-effects/src/resource/access.rs-        
crates/causality-effects/src/resource/access.rs-        for (resource_id, access_type) in resources {
crates/causality-effects/src/resource/access.rs-            let mut access = ResourceAccess::new(
--
crates/causality-effects/src/resource/access.rs:/// Resource access manager for coordinating access across effects and domains
crates/causality-effects/src/resource/access.rs-pub struct ResourceAccessManager {
--
crates/causality-effects/src/resource/access.rs-    in_use_resources: Mutex<HashMap<ContentId, HashSet<EffectId>>>,
crates/causality-effects/src/resource/access.rs-}
crates/causality-effects/src/resource/access.rs-
crates/causality-effects/src/resource/access.rs-impl ResourceAccessManager {
crates/causality-effects/src/resource/access.rs:    /// Create a new resource access manager
crates/causality-effects/src/resource/access.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/resource/access.rs-            tracker: Arc::new(ResourceAccessTracker::new()),
crates/causality-effects/src/resource/access.rs-            in_use_resources: Mutex::new(HashMap::new()),
crates/causality-effects/src/resource/access.rs-        }
--
crates/causality-effects/src/resource/access.rs:    /// Get the access tracker
crates/causality-effects/src/resource/access.rs-    pub fn tracker(&self) -> Arc<ResourceAccessTracker> {
crates/causality-effects/src/resource/access.rs-        Arc::clone(&self.tracker)
crates/causality-effects/src/resource/access.rs-    }
crates/causality-effects/src/resource/access.rs-    
crates/causality-effects/src/resource/access.rs:    /// Request access to a resource
crates/causality-effects/src/resource/access.rs-    pub async fn request_access(
--
crates/causality-effects/src/resource/access.rs-        resource_id: &ContentId,
crates/causality-effects/src/resource/access.rs-        access_type: ResourceAccessType,
crates/causality-effects/src/resource/access.rs-        effect: &dyn Effect,
--
crates/causality-effects/src/resource/access.rs:    /// Release access to a resource
crates/causality-effects/src/resource/access.rs-    pub fn release_access(
--
crates/causality-effects/src/resource/access.rs-        resource_id: &ContentId,
crates/causality-effects/src/resource/access.rs-        effect_id: &EffectId,
crates/causality-effects/src/resource/access.rs-    ) -> EffectResult<()> {
--
crates/causality-effects/src/resource/access.rs:    /// Check if a resource is in use
crates/causality-effects/src/resource/access.rs-    pub fn is_resource_in_use(&self, resource_id: &ContentId) -> bool {
crates/causality-effects/src/resource/access.rs-        let in_use = self.in_use_resources.lock().unwrap();
crates/causality-effects/src/resource/access.rs-        in_use.contains_key(resource_id)
crates/causality-effects/src/resource/access.rs-    }
crates/causality-effects/src/resource/access.rs-    
crates/causality-effects/src/resource/access.rs:    /// Get effects using a resource
crates/causality-effects/src/resource/access.rs-    pub fn get_effects_using_resource(&self, resource_id: &ContentId) -> HashSet<EffectId> {
--
crates/causality-effects/src/resource/access.rs-        in_use.get(resource_id)
crates/causality-effects/src/resource/access.rs-            .cloned()
crates/causality-effects/src/resource/access.rs-            .unwrap_or_default()
--
crates/causality-effects/src/resource/effects.rs:/// Effect for transferring a resource across domains
crates/causality-effects/src/resource/effects.rs-pub struct CrossDomainResourceTransferEffect {
--
crates/causality-effects/src/resource/effects.rs:    /// Resource managers
crates/causality-effects/src/resource/effects.rs-    resource_managers: CrossDomainResourceManagers,
crates/causality-effects/src/resource/effects.rs-}
crates/causality-effects/src/resource/effects.rs-
crates/causality-effects/src/resource/effects.rs:/// Structure holding references to resource managers
crates/causality-effects/src/resource/effects.rs-pub struct CrossDomainResourceManagers {
crates/causality-effects/src/resource/effects.rs:    /// Access manager
crates/causality-effects/src/resource/effects.rs-    pub access_manager: Arc<ResourceAccessManager>,
crates/causality-effects/src/resource/effects.rs-    
crates/causality-effects/src/resource/effects.rs:    /// Lifecycle manager
crates/causality-effects/src/resource/effects.rs-    pub lifecycle_manager: Arc<EffectResourceLifecycle>,
crates/causality-effects/src/resource/effects.rs-    
crates/causality-effects/src/resource/effects.rs:    /// Lock manager
crates/causality-effects/src/resource/effects.rs-    pub lock_manager: Arc<CrossDomainLockManager>,
crates/causality-effects/src/resource/effects.rs-    
crates/causality-effects/src/resource/effects.rs:    /// Dependency manager
crates/causality-effects/src/resource/effects.rs-    pub dependency_manager: Arc<ResourceDependencyManager>,
crates/causality-effects/src/resource/effects.rs-    
crates/causality-effects/src/resource/effects.rs:    /// Capability manager
crates/causality-effects/src/resource/effects.rs-    pub capability_manager: Arc<ResourceCapabilityManager>,
crates/causality-effects/src/resource/effects.rs-    
crates/causality-effects/src/resource/effects.rs:    /// Capability verifier
crates/causality-effects/src/resource/effects.rs-    pub capability_verifier: Arc<DefaultCapabilityVerifier>,
crates/causality-effects/src/resource/effects.rs-}
crates/causality-effects/src/resource/effects.rs-
crates/causality-effects/src/resource/effects.rs-impl CrossDomainResourceTransferEffect {
crates/causality-effects/src/resource/effects.rs:    /// Create a new cross-domain resource transfer effect
crates/causality-effects/src/resource/effects.rs-    pub fn new(
--
crates/causality-effects/src/resource/effects.rs-        source_domain_id: DomainId,
crates/causality-effects/src/resource/effects.rs-        target_domain_id: DomainId,
crates/causality-effects/src/resource/effects.rs-        resource_managers: CrossDomainResourceManagers,
--
crates/causality-effects/src/resource/effects.rs:    /// Set a timeout for the transfer operation
crates/causality-effects/src/resource/effects.rs-    pub fn with_timeout(mut self, timeout: Duration) -> Self {
crates/causality-effects/src/resource/effects.rs-        self.timeout = Some(timeout);
crates/causality-effects/src/resource/effects.rs-        self
crates/causality-effects/src/resource/effects.rs-    }
crates/causality-effects/src/resource/effects.rs-    
crates/causality-effects/src/resource/effects.rs:    /// Add metadata to the transfer
crates/causality-effects/src/resource/effects.rs-    pub fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
--
crates/causality-effects/src/resource/effects.rs-        if !context.has_cross_domain_capability(&CrossDomainCapability::TransferAssets) {
crates/causality-effects/src/resource/effects.rs-            return Err(EffectError::CapabilityError(
crates/causality-effects/src/resource/effects.rs-                "Missing TransferAssets capability".to_string()
--
crates/causality-effects/src/resource/effects.rs:/// Helper function to create a cross-domain resource transfer effect
crates/causality-effects/src/resource/effects.rs-pub fn transfer_resource(
--
crates/causality-effects/src/resource/effects.rs-    source_domain_id: DomainId,
crates/causality-effects/src/resource/effects.rs-    target_domain_id: DomainId,
crates/causality-effects/src/resource/effects.rs-    resource_managers: CrossDomainResourceManagers,
--
crates/causality-effects/src/resource/effects.rs:/// Effect for locking a resource across domains
crates/causality-effects/src/resource/effects.rs-pub struct CrossDomainResourceLockEffect {
--
crates/causality-effects/src/resource/effects.rs-    resource_managers: CrossDomainResourceManagers,
crates/causality-effects/src/resource/effects.rs-}
crates/causality-effects/src/resource/effects.rs-
crates/causality-effects/src/resource/effects.rs-impl CrossDomainResourceLockEffect {
crates/causality-effects/src/resource/effects.rs:    /// Create a new cross-domain resource lock effect
crates/causality-effects/src/resource/effects.rs-    pub fn new(
--
crates/causality-effects/src/resource/effects.rs-        lock_type: CrossDomainLockType,
crates/causality-effects/src/resource/effects.rs-        domain_ids: Vec<DomainId>,
crates/causality-effects/src/resource/effects.rs-        resource_managers: CrossDomainResourceManagers,
--
crates/causality-effects/src/resource/effects.rs:    /// Set a timeout for the lock operation
crates/causality-effects/src/resource/effects.rs-    pub fn with_timeout(mut self, timeout: Duration) -> Self {
crates/causality-effects/src/resource/effects.rs-        self.timeout = Some(timeout);
crates/causality-effects/src/resource/effects.rs-        self
crates/causality-effects/src/resource/effects.rs-    }
crates/causality-effects/src/resource/effects.rs-    
crates/causality-effects/src/resource/effects.rs:    /// Set a transaction ID for the lock operation
crates/causality-effects/src/resource/effects.rs-    pub fn with_transaction(mut self, transaction_id: String) -> Self {
--
crates/causality-effects/src/resource/effects.rs-        let lock_type_str = format!("{:?}", self.lock_type);
crates/causality-effects/src/resource/effects.rs-        let resource_locking_cap = CrossDomainCapability::ResourceLocking {
crates/causality-effects/src/resource/effects.rs-            lock_type: lock_type_str.clone()
--
crates/causality-effects/src/resource/effects.rs:/// Helper function to create a cross-domain resource lock effect
crates/causality-effects/src/resource/effects.rs-pub fn lock_resource_across_domains(
--
crates/causality-effects/src/resource/effects.rs-    lock_type: CrossDomainLockType,
crates/causality-effects/src/resource/effects.rs-    domain_ids: Vec<DomainId>,
crates/causality-effects/src/resource/effects.rs-    resource_managers: CrossDomainResourceManagers,
--
crates/causality-effects/src/resource/effects.rs:/// Effect for establishing a dependency between resources across domains
crates/causality-effects/src/resource/effects.rs-pub struct CrossDomainResourceDependencyEffect {
--
crates/causality-effects/src/resource/effects.rs-    resource_managers: CrossDomainResourceManagers,
crates/causality-effects/src/resource/effects.rs-}
crates/causality-effects/src/resource/effects.rs-
crates/causality-effects/src/resource/effects.rs-impl CrossDomainResourceDependencyEffect {
crates/causality-effects/src/resource/effects.rs:    /// Create a new cross-domain resource dependency effect
crates/causality-effects/src/resource/effects.rs-    pub fn new(
--
crates/causality-effects/src/resource/effects.rs-        source_domain_id: DomainId,
crates/causality-effects/src/resource/effects.rs-        target_id: ContentId,
crates/causality-effects/src/resource/effects.rs-        target_domain_id: DomainId,
--
crates/causality-effects/src/resource/effects.rs:    /// Add metadata to the dependency
crates/causality-effects/src/resource/effects.rs-    pub fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
--
crates/causality-effects/src/resource/effects.rs-        let dep_type_str = format!("{:?}", self.dependency_type);
crates/causality-effects/src/resource/effects.rs-        let resource_dependency_cap = CrossDomainCapability::ResourceDependency {
crates/causality-effects/src/resource/effects.rs-            dependency_type: dep_type_str.clone()
--
crates/causality-effects/src/resource/effects.rs:/// Helper function to create a cross-domain resource dependency effect
crates/causality-effects/src/resource/effects.rs-pub fn add_cross_domain_dependency(
--
crates/causality-effects/src/resource/effects.rs-    source_domain_id: DomainId,
crates/causality-effects/src/resource/effects.rs-    target_id: ContentId,
crates/causality-effects/src/resource/effects.rs-    target_domain_id: DomainId,
--
crates/causality-effects/src/resource/effects.rs:/// Example demonstrating cross-domain resource management
crates/causality-effects/src/resource/effects.rs-pub async fn cross_domain_resource_example() -> Result<()> {
--
crates/causality-effects/src/resource/effects.rs-    // Create resource IDs
crates/causality-effects/src/resource/effects.rs-    let resource_id = ContentId::from_string("example-resource");
--
crates/causality-effects/src/resource/dependency.rs:/// Resource dependency type
crates/causality-effects/src/resource/dependency.rs-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
crates/causality-effects/src/resource/dependency.rs-pub enum DependencyType {
--
crates/causality-effects/src/resource/dependency.rs-    Identity,
crates/causality-effects/src/resource/dependency.rs-}
crates/causality-effects/src/resource/dependency.rs-
crates/causality-effects/src/resource/dependency.rs:/// Resource dependency relationship
crates/causality-effects/src/resource/dependency.rs-#[derive(Debug, Clone)]
crates/causality-effects/src/resource/dependency.rs-pub struct ResourceDependency {
crates/causality-effects/src/resource/dependency.rs:    /// Source resource ID
crates/causality-effects/src/resource/dependency.rs-    pub source: ContentId,
crates/causality-effects/src/resource/dependency.rs-    
crates/causality-effects/src/resource/dependency.rs:    /// Target resource ID
crates/causality-effects/src/resource/dependency.rs-    pub target: ContentId,
crates/causality-effects/src/resource/dependency.rs-    
crates/causality-effects/src/resource/dependency.rs:    /// Dependency type
crates/causality-effects/src/resource/dependency.rs-    pub dependency_type: DependencyType,
crates/causality-effects/src/resource/dependency.rs-    
crates/causality-effects/src/resource/dependency.rs:    /// Domain ID of the source resource
crates/causality-effects/src/resource/dependency.rs-    pub source_domain: Option<DomainId>,
crates/causality-effects/src/resource/dependency.rs-    
crates/causality-effects/src/resource/dependency.rs:    /// Domain ID of the target resource
crates/causality-effects/src/resource/dependency.rs-    pub target_domain: Option<DomainId>,
crates/causality-effects/src/resource/dependency.rs-    
crates/causality-effects/src/resource/dependency.rs:    /// Effect ID that created this dependency
crates/causality-effects/src/resource/dependency.rs-    pub creator_effect: Option<EffectId>,
crates/causality-effects/src/resource/dependency.rs-    
crates/causality-effects/src/resource/dependency.rs:    /// Additional metadata
crates/causality-effects/src/resource/dependency.rs-    pub metadata: HashMap<String, String>,
--
crates/causality-effects/src/resource/dependency.rs:/// Resource dependency manager
crates/causality-effects/src/resource/dependency.rs:/// 
crates/causality-effects/src/resource/dependency.rs:/// This is a placeholder implementation that will be expanded in the future
crates/causality-effects/src/resource/dependency.rs:/// to provide full dependency tracking capabilities.
crates/causality-effects/src/resource/dependency.rs-#[derive(Debug)]
crates/causality-effects/src/resource/dependency.rs-pub struct ResourceDependencyManager {
--
crates/causality-effects/src/resource/dependency.rs-    dependencies_by_target: RwLock<HashMap<ContentId, HashSet<ResourceDependency>>>,
crates/causality-effects/src/resource/dependency.rs-}
crates/causality-effects/src/resource/dependency.rs-
crates/causality-effects/src/resource/dependency.rs-impl ResourceDependencyManager {
crates/causality-effects/src/resource/dependency.rs:    /// Create a new resource dependency manager
crates/causality-effects/src/resource/dependency.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/resource/dependency.rs-            dependencies_by_source: RwLock::new(HashMap::new()),
crates/causality-effects/src/resource/dependency.rs-            dependencies_by_target: RwLock::new(HashMap::new()),
crates/causality-effects/src/resource/dependency.rs-        }
--
crates/causality-effects/src/resource/dependency.rs:    /// Add a dependency between resources
crates/causality-effects/src/resource/dependency.rs-    pub fn add_dependency(&self, dependency: ResourceDependency) -> Result<()> {
--
crates/causality-effects/src/resource/dependency.rs-        {
crates/causality-effects/src/resource/dependency.rs-            let mut map = self.dependencies_by_source.write().unwrap();
crates/causality-effects/src/resource/dependency.rs-            map.entry(dependency.source.clone())
--
crates/causality-effects/src/resource/dependency.rs:    /// Get dependencies for a source resource
crates/causality-effects/src/resource/dependency.rs-    pub fn get_dependencies_for_source(&self, source: &ContentId) -> HashSet<ResourceDependency> {
--
crates/causality-effects/src/resource/dependency.rs-        map.get(source)
crates/causality-effects/src/resource/dependency.rs-            .cloned()
crates/causality-effects/src/resource/dependency.rs-            .unwrap_or_default()
--
crates/causality-effects/src/resource/dependency.rs:    /// Get dependencies for a target resource
crates/causality-effects/src/resource/dependency.rs-    pub fn get_dependencies_for_target(&self, target: &ContentId) -> HashSet<ResourceDependency> {
--
crates/causality-effects/src/resource/dependency.rs-        map.get(target)
crates/causality-effects/src/resource/dependency.rs-            .cloned()
crates/causality-effects/src/resource/dependency.rs-            .unwrap_or_default()
--
crates/causality-effects/src/resource/dependency.rs:    /// Check if a resource has dependencies
crates/causality-effects/src/resource/dependency.rs-    pub fn has_dependencies(&self, resource_id: &ContentId) -> bool {
--
crates/causality-effects/src/resource/dependency.rs-        let target_map = self.dependencies_by_target.read().unwrap();
crates/causality-effects/src/resource/dependency.rs-        
crates/causality-effects/src/resource/dependency.rs-        source_map.contains_key(resource_id) || target_map.contains_key(resource_id)
--
crates/causality-effects/src/resource/dependency.rs:    /// Remove all dependencies for a resource
crates/causality-effects/src/resource/dependency.rs-    pub fn remove_dependencies(&self, resource_id: &ContentId) -> Result<()> {
--
crates/causality-effects/src/resource/dependency.rs-        {
crates/causality-effects/src/resource/dependency.rs-            let mut source_map = self.dependencies_by_source.write().unwrap();
crates/causality-effects/src/resource/dependency.rs-            source_map.remove(resource_id);
--
crates/causality-effects/src/resource/implementation.rs:/// Implementation of resource traits for effect handlers
crates/causality-effects/src/resource/implementation.rs-pub struct EffectResourceImplementation {
--
crates/causality-effects/src/resource/implementation.rs-    dependency_manager: Arc<ResourceDependencyManager>,
crates/causality-effects/src/resource/implementation.rs-}
crates/causality-effects/src/resource/implementation.rs-
crates/causality-effects/src/resource/implementation.rs-impl EffectResourceImplementation {
crates/causality-effects/src/resource/implementation.rs:    /// Create a new effect resource implementation
crates/causality-effects/src/resource/implementation.rs-    pub fn new(
--
crates/causality-effects/src/resource/implementation.rs-        access_manager: Arc<ResourceAccessManager>,
crates/causality-effects/src/resource/implementation.rs-        lifecycle_manager: Arc<EffectResourceLifecycle>,
crates/causality-effects/src/resource/implementation.rs-        lock_manager: Arc<CrossDomainLockManager>,
--
crates/causality-effects/src/resource/implementation.rs:    /// Create a new effect resource implementation with default components
crates/causality-effects/src/resource/implementation.rs-    pub fn new_default(effect_registry: Arc<EffectRegistry>) -> Self {
--
crates/causality-effects/src/resource/implementation.rs-            Some(id) => id.clone(),
crates/causality-effects/src/resource/implementation.rs-            None => return Err(anyhow::anyhow!("Resource context missing effect ID")),
crates/causality-effects/src/resource/implementation.rs-        };
--
crates/causality-effects/src/resource/implementation.rs:/// Helper function to create effect resource context from basic context
crates/causality-effects/src/resource/implementation.rs-pub fn create_effect_context(
--
crates/causality-effects/src/resource/implementation.rs-    context_id: Option<ContentId>,
crates/causality-effects/src/resource/implementation.rs-) -> BasicResourceContext {
crates/causality-effects/src/resource/implementation.rs-    let context_id = context_id.unwrap_or_else(|| ContentId::from_string("effect-context").unwrap_or_default());
--
crates/causality-effects/src/resource/examples.rs:/// Example of using the resource access system
crates/causality-effects/src/resource/examples.rs-pub fn resource_access_example() -> Result<()> {
--
crates/causality-effects/src/resource/examples.rs-    
crates/causality-effects/src/resource/examples.rs-    // Create resource IDs
crates/causality-effects/src/resource/examples.rs-    let resource_id = ContentId::from_string("example-resource-1");
--
crates/causality-effects/src/resource/examples.rs:/// Example of using the resource lifecycle system
crates/causality-effects/src/resource/examples.rs-pub fn resource_lifecycle_example() -> Result<()> {
--
crates/causality-effects/src/resource/examples.rs-    
crates/causality-effects/src/resource/examples.rs-    // Create resource IDs
crates/causality-effects/src/resource/examples.rs-    let resource_id = ContentId::from_string("example-resource-2");
--
crates/causality-effects/src/resource/examples.rs:/// Example of using the cross-domain locking system
crates/causality-effects/src/resource/examples.rs-pub fn resource_locking_example() -> Result<()> {
--
crates/causality-effects/src/resource/examples.rs-    
crates/causality-effects/src/resource/examples.rs-    // Create resource IDs
crates/causality-effects/src/resource/examples.rs-    let resource_id = ContentId::from_string("example-resource-3");
--
crates/causality-effects/src/resource/examples.rs:/// Example of using the resource dependency system
crates/causality-effects/src/resource/examples.rs-pub fn resource_dependency_example() -> Result<()> {
--
crates/causality-effects/src/resource/examples.rs-    
crates/causality-effects/src/resource/examples.rs-    // Create resource IDs
crates/causality-effects/src/resource/examples.rs-    let source_id = ContentId::from_string("source-resource");
--
crates/causality-effects/src/resource/examples.rs:/// Example of coordinating all resource management systems
crates/causality-effects/src/resource/examples.rs-pub fn integrated_resource_management_example() -> Result<()> {
--
crates/causality-effects/src/resource/examples.rs-    
crates/causality-effects/src/resource/examples.rs-    // Create resource IDs
crates/causality-effects/src/resource/examples.rs-    let resource_id = ContentId::from_string("example-resource-5");
--
crates/causality-effects/src/resource/examples.rs:/// Runs all resource management examples
crates/causality-effects/src/resource/examples.rs-pub fn run_all_examples() -> Result<()> {
--
crates/causality-effects/src/resource/examples.rs-    resource_access_example()?;
crates/causality-effects/src/resource/examples.rs-    println!("\n--------------------------------\n");
--
crates/causality-effects/src/resource/lifecycle.rs:/// Resource lifecycle event types
crates/causality-effects/src/resource/lifecycle.rs-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
crates/causality-effects/src/resource/lifecycle.rs-pub enum ResourceLifecycleEvent {
--
crates/causality-effects/src/resource/lifecycle.rs-    Updated,
crates/causality-effects/src/resource/lifecycle.rs-}
crates/causality-effects/src/resource/lifecycle.rs-
crates/causality-effects/src/resource/lifecycle.rs:/// Resource lifecycle event
crates/causality-effects/src/resource/lifecycle.rs-#[derive(Debug, Clone)]
crates/causality-effects/src/resource/lifecycle.rs-pub struct LifecycleEvent {
crates/causality-effects/src/resource/lifecycle.rs:    /// Resource ID
crates/causality-effects/src/resource/lifecycle.rs-    pub resource_id: ContentId,
crates/causality-effects/src/resource/lifecycle.rs-    
crates/causality-effects/src/resource/lifecycle.rs:    /// Event type
crates/causality-effects/src/resource/lifecycle.rs-    pub event_type: ResourceLifecycleEvent,
crates/causality-effects/src/resource/lifecycle.rs-    
crates/causality-effects/src/resource/lifecycle.rs:    /// Effect ID that triggered the event
crates/causality-effects/src/resource/lifecycle.rs-    pub effect_id: EffectId,
crates/causality-effects/src/resource/lifecycle.rs-    
crates/causality-effects/src/resource/lifecycle.rs:    /// Domain ID where the resource is located
crates/causality-effects/src/resource/lifecycle.rs-    pub domain_id: Option<DomainId>,
crates/causality-effects/src/resource/lifecycle.rs-    
crates/causality-effects/src/resource/lifecycle.rs:    /// Timestamp when the event occurred
crates/causality-effects/src/resource/lifecycle.rs-    pub timestamp: chrono::DateTime<chrono::Utc>,
crates/causality-effects/src/resource/lifecycle.rs-    
crates/causality-effects/src/resource/lifecycle.rs:    /// Additional metadata
crates/causality-effects/src/resource/lifecycle.rs-    pub metadata: HashMap<String, String>,
crates/causality-effects/src/resource/lifecycle.rs-}
crates/causality-effects/src/resource/lifecycle.rs-
crates/causality-effects/src/resource/lifecycle.rs-impl LifecycleEvent {
crates/causality-effects/src/resource/lifecycle.rs:    /// Create a new lifecycle event
crates/causality-effects/src/resource/lifecycle.rs-    pub fn new(
--
crates/causality-effects/src/resource/lifecycle.rs-        event_type: ResourceLifecycleEvent,
crates/causality-effects/src/resource/lifecycle.rs-        effect_id: EffectId,
crates/causality-effects/src/resource/lifecycle.rs-    ) -> Self {
--
crates/causality-effects/src/resource/lifecycle.rs:    /// Create a lifecycle event with domain
crates/causality-effects/src/resource/lifecycle.rs-    pub fn with_domain(
--
crates/causality-effects/src/resource/lifecycle.rs-        event_type: ResourceLifecycleEvent,
crates/causality-effects/src/resource/lifecycle.rs-        effect_id: EffectId,
crates/causality-effects/src/resource/lifecycle.rs-        domain_id: DomainId,
--
crates/causality-effects/src/resource/lifecycle.rs:    /// Add metadata
crates/causality-effects/src/resource/lifecycle.rs-    pub fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
--
crates/causality-effects/src/resource/lifecycle.rs-        self
crates/causality-effects/src/resource/lifecycle.rs-    }
crates/causality-effects/src/resource/lifecycle.rs-}
--
crates/causality-effects/src/resource/lifecycle.rs:/// Resource lifecycle manager for effects
crates/causality-effects/src/resource/lifecycle.rs-pub struct EffectResourceLifecycle {
--
crates/causality-effects/src/resource/lifecycle.rs-    event_handlers: Mutex<Vec<Box<dyn Fn(&LifecycleEvent) + Send + Sync>>>,
crates/causality-effects/src/resource/lifecycle.rs-}
crates/causality-effects/src/resource/lifecycle.rs-
crates/causality-effects/src/resource/lifecycle.rs-impl EffectResourceLifecycle {
crates/causality-effects/src/resource/lifecycle.rs:    /// Create a new effect resource lifecycle
crates/causality-effects/src/resource/lifecycle.rs-    pub fn new(lifecycle: Arc<ResourceLifecycle>) -> Self {
--
crates/causality-effects/src/resource/lifecycle.rs-            lifecycle,
crates/causality-effects/src/resource/lifecycle.rs-            pending_events: RwLock::new(Vec::new()),
crates/causality-effects/src/resource/lifecycle.rs-            resource_states: RwLock::new(HashMap::new()),
--
crates/causality-effects/src/resource/lifecycle.rs:    /// Get the underlying resource lifecycle
crates/causality-effects/src/resource/lifecycle.rs-    pub fn resource_lifecycle(&self) -> Arc<ResourceLifecycle> {
crates/causality-effects/src/resource/lifecycle.rs-        Arc::clone(&self.lifecycle)
crates/causality-effects/src/resource/lifecycle.rs-    }
crates/causality-effects/src/resource/lifecycle.rs-    
crates/causality-effects/src/resource/lifecycle.rs:    /// Register a resource
crates/causality-effects/src/resource/lifecycle.rs-    pub fn register_resource(
--
crates/causality-effects/src/resource/lifecycle.rs-        resource: &ResourceRegister,
crates/causality-effects/src/resource/lifecycle.rs-        effect_id: &EffectId,
crates/causality-effects/src/resource/lifecycle.rs-        domain_id: Option<&DomainId>,
--
crates/causality-effects/src/resource/lifecycle.rs:    /// Update resource state
crates/causality-effects/src/resource/lifecycle.rs-    pub fn update_resource_state(
--
crates/causality-effects/src/resource/lifecycle.rs-        resource_id: &ContentId,
crates/causality-effects/src/resource/lifecycle.rs-        new_state: RegisterState,
crates/causality-effects/src/resource/lifecycle.rs-        effect_id: &EffectId,
--
crates/causality-effects/src/resource/lifecycle.rs:    /// Activate a resource
crates/causality-effects/src/resource/lifecycle.rs-    pub fn activate_resource(
--
crates/causality-effects/src/resource/lifecycle.rs-        resource: &mut ResourceRegister,
crates/causality-effects/src/resource/lifecycle.rs-        effect_id: &EffectId,
crates/causality-effects/src/resource/lifecycle.rs-    ) -> Result<()> {
--
crates/causality-effects/src/resource/lifecycle.rs:    /// Lock a resource
crates/causality-effects/src/resource/lifecycle.rs-    pub fn lock_resource(
--
crates/causality-effects/src/resource/lifecycle.rs-        resource: &mut ResourceRegister,
crates/causality-effects/src/resource/lifecycle.rs-        effect_id: &EffectId,
crates/causality-effects/src/resource/lifecycle.rs-        locker_id: Option<&ContentId>,
--
crates/causality-effects/src/resource/lifecycle.rs:    /// Unlock a resource
crates/causality-effects/src/resource/lifecycle.rs-    pub fn unlock_resource(
--
crates/causality-effects/src/resource/lifecycle.rs-        resource: &mut ResourceRegister,
crates/causality-effects/src/resource/lifecycle.rs-        effect_id: &EffectId,
crates/causality-effects/src/resource/lifecycle.rs-        unlocker_id: Option<&ContentId>,
--
crates/causality-effects/src/resource/lifecycle.rs:    /// Consume a resource
crates/causality-effects/src/resource/lifecycle.rs-    pub fn consume_resource(
--
crates/causality-effects/src/resource/lifecycle.rs-        resource: &mut ResourceRegister,
crates/causality-effects/src/resource/lifecycle.rs-        effect_id: &EffectId,
crates/causality-effects/src/resource/lifecycle.rs-    ) -> Result<()> {
--
crates/causality-effects/src/resource/lifecycle.rs:    /// Get the current state of a resource
crates/causality-effects/src/resource/lifecycle.rs-    pub fn get_resource_state(&self, resource_id: &ContentId) -> Option<RegisterState> {
crates/causality-effects/src/resource/lifecycle.rs-        let states = self.resource_states.read().unwrap();
crates/causality-effects/src/resource/lifecycle.rs-        states.get(resource_id).cloned()
crates/causality-effects/src/resource/lifecycle.rs-    }
crates/causality-effects/src/resource/lifecycle.rs-    
crates/causality-effects/src/resource/lifecycle.rs:    /// Check if a resource can perform an operation
crates/causality-effects/src/resource/lifecycle.rs-    pub fn can_perform_operation(
--
crates/causality-effects/src/resource/lifecycle.rs-        resource: &ResourceRegister,
crates/causality-effects/src/resource/lifecycle.rs-        operation: ResourceOperation,
crates/causality-effects/src/resource/lifecycle.rs-    ) -> Result<bool> {
--
crates/causality-effects/src/resource/lifecycle.rs:    /// Register an event handler
crates/causality-effects/src/resource/lifecycle.rs-    pub fn register_event_handler<F>(&self, handler: F)
--
crates/causality-effects/src/resource/lifecycle.rs-        {
crates/causality-effects/src/resource/lifecycle.rs-            let mut events = self.pending_events.write().unwrap();
crates/causality-effects/src/resource/lifecycle.rs-            events.push(event.clone());
--
crates/causality-effects/src/resource/lifecycle.rs:    /// Get all pending lifecycle events
crates/causality-effects/src/resource/lifecycle.rs-    pub fn get_pending_events(&self) -> Vec<LifecycleEvent> {
crates/causality-effects/src/resource/lifecycle.rs-        let events = self.pending_events.read().unwrap();
crates/causality-effects/src/resource/lifecycle.rs-        events.clone()
crates/causality-effects/src/resource/lifecycle.rs-    }
crates/causality-effects/src/resource/lifecycle.rs-    
crates/causality-effects/src/resource/lifecycle.rs:    /// Clear pending events
crates/causality-effects/src/resource/lifecycle.rs-    pub fn clear_pending_events(&self) {
--
crates/causality-effects/src/resource/lifecycle.rs-    }
crates/causality-effects/src/resource/lifecycle.rs-}
--
crates/causality-effects/src/resource/lifecycle.rs:/// Effect for managing resource lifecycle
crates/causality-effects/src/resource/lifecycle.rs-#[derive(Debug)]
crates/causality-effects/src/resource/lifecycle.rs-pub struct ResourceLifecycleEffect {
--
crates/causality-effects/src/resource/lifecycle.rs-    reason: TransitionReason,
crates/causality-effects/src/resource/lifecycle.rs-}
crates/causality-effects/src/resource/lifecycle.rs-
crates/causality-effects/src/resource/lifecycle.rs-impl ResourceLifecycleEffect {
crates/causality-effects/src/resource/lifecycle.rs:    /// Create a new resource lifecycle effect
crates/causality-effects/src/resource/lifecycle.rs-    pub fn new(
--
crates/causality-effects/src/resource/lifecycle.rs-        operation: ResourceOperation,
crates/causality-effects/src/resource/lifecycle.rs-    ) -> Self {
crates/causality-effects/src/resource/lifecycle.rs-        Self {
--
crates/causality-effects/src/resource/lifecycle.rs:    /// Set the domain ID
crates/causality-effects/src/resource/lifecycle.rs-    pub fn with_domain(mut self, domain_id: DomainId) -> Self {
crates/causality-effects/src/resource/lifecycle.rs-        self.domain_id = Some(domain_id);
crates/causality-effects/src/resource/lifecycle.rs-        self
crates/causality-effects/src/resource/lifecycle.rs-    }
crates/causality-effects/src/resource/lifecycle.rs-    
crates/causality-effects/src/resource/lifecycle.rs:    /// Set the controller ID
crates/causality-effects/src/resource/lifecycle.rs-    pub fn with_controller(mut self, controller_id: ContentId) -> Self {
crates/causality-effects/src/resource/lifecycle.rs-        self.controller_id = Some(controller_id);
crates/causality-effects/src/resource/lifecycle.rs-        self
crates/causality-effects/src/resource/lifecycle.rs-    }
crates/causality-effects/src/resource/lifecycle.rs-    
crates/causality-effects/src/resource/lifecycle.rs:    /// Set the transition reason
crates/causality-effects/src/resource/lifecycle.rs-    pub fn with_reason(mut self, reason: TransitionReason) -> Self {
crates/causality-effects/src/resource/lifecycle.rs-        self.reason = reason;
crates/causality-effects/src/resource/lifecycle.rs-        self
crates/causality-effects/src/resource/lifecycle.rs-    }
crates/causality-effects/src/resource/lifecycle.rs-    
crates/causality-effects/src/resource/lifecycle.rs:    /// Get the resource ID
crates/causality-effects/src/resource/lifecycle.rs-    pub fn resource_id(&self) -> &ContentId {
crates/causality-effects/src/resource/lifecycle.rs-        &self.resource_id
crates/causality-effects/src/resource/lifecycle.rs-    }
crates/causality-effects/src/resource/lifecycle.rs-    
crates/causality-effects/src/resource/lifecycle.rs:    /// Get the operation
crates/causality-effects/src/resource/lifecycle.rs-    pub fn operation(&self) -> ResourceOperation {
crates/causality-effects/src/resource/lifecycle.rs-        self.operation
crates/causality-effects/src/resource/lifecycle.rs-    }
crates/causality-effects/src/resource/lifecycle.rs-    
crates/causality-effects/src/resource/lifecycle.rs:    /// Get the domain ID
crates/causality-effects/src/resource/lifecycle.rs-    pub fn domain_id(&self) -> Option<&DomainId> {
crates/causality-effects/src/resource/lifecycle.rs-        self.domain_id.as_ref()
crates/causality-effects/src/resource/lifecycle.rs-    }
crates/causality-effects/src/resource/lifecycle.rs-}
crates/causality-effects/src/resource/lifecycle.rs-
crates/causality-effects/src/resource/lifecycle.rs:/// Factory functions for creating common resource lifecycle effects
crates/causality-effects/src/resource/lifecycle.rs-pub mod effects {
crates/causality-effects/src/resource/lifecycle.rs-    use super::*;
crates/causality-effects/src/resource/lifecycle.rs-    
crates/causality-effects/src/resource/lifecycle.rs:    /// Create an effect to activate a resource
crates/causality-effects/src/resource/lifecycle.rs-    pub fn activate_resource(resource_id: ContentId) -> ResourceLifecycleEffect {
crates/causality-effects/src/resource/lifecycle.rs-        ResourceLifecycleEffect::new(resource_id, ResourceOperation::Update)
crates/causality-effects/src/resource/lifecycle.rs-            .with_reason(TransitionReason::UserRequested)
crates/causality-effects/src/resource/lifecycle.rs-    }
crates/causality-effects/src/resource/lifecycle.rs-    
crates/causality-effects/src/resource/lifecycle.rs:    /// Create an effect to lock a resource
crates/causality-effects/src/resource/lifecycle.rs-    pub fn lock_resource(resource_id: ContentId, locker_id: Option<ContentId>) -> ResourceLifecycleEffect {
--
crates/causality-effects/src/resource/lifecycle.rs-            .with_reason(TransitionReason::UserRequested);
crates/causality-effects/src/resource/lifecycle.rs-            
crates/causality-effects/src/resource/lifecycle.rs-        if let Some(locker_id) = locker_id {
--
crates/causality-effects/src/resource/lifecycle.rs:    /// Create an effect to unlock a resource
crates/causality-effects/src/resource/lifecycle.rs-    pub fn unlock_resource(resource_id: ContentId, unlocker_id: Option<ContentId>) -> ResourceLifecycleEffect {
--
crates/causality-effects/src/resource/lifecycle.rs-            .with_reason(TransitionReason::UserRequested);
crates/causality-effects/src/resource/lifecycle.rs-            
crates/causality-effects/src/resource/lifecycle.rs-        if let Some(unlocker_id) = unlocker_id {
--
crates/causality-effects/src/resource/lifecycle.rs:    /// Create an effect to consume a resource
crates/causality-effects/src/resource/lifecycle.rs-    pub fn consume_resource(resource_id: ContentId) -> ResourceLifecycleEffect {
crates/causality-effects/src/resource/lifecycle.rs-        ResourceLifecycleEffect::new(resource_id, ResourceOperation::Consume)
crates/causality-effects/src/resource/lifecycle.rs-            .with_reason(TransitionReason::UserRequested)
crates/causality-effects/src/resource/lifecycle.rs-    }
crates/causality-effects/src/resource/lifecycle.rs-    
crates/causality-effects/src/resource/lifecycle.rs:    /// Create an effect to archive a resource
crates/causality-effects/src/resource/lifecycle.rs-    pub fn archive_resource(resource_id: ContentId) -> ResourceLifecycleEffect {
--
crates/causality-effects/src/resource/lifecycle.rs-    }
crates/causality-effects/src/resource/lifecycle.rs-} 
--
crates/causality-effects/src/resource/locking.rs:/// Lock acquisition status
crates/causality-effects/src/resource/locking.rs-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
crates/causality-effects/src/resource/locking.rs-pub enum LockStatus {
--
crates/causality-effects/src/resource/locking.rs-    TimedOut,
crates/causality-effects/src/resource/locking.rs-}
crates/causality-effects/src/resource/locking.rs-
crates/causality-effects/src/resource/locking.rs:/// Cross-domain lock type
crates/causality-effects/src/resource/locking.rs-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
crates/causality-effects/src/resource/locking.rs-pub enum CrossDomainLockType {
--
crates/causality-effects/src/resource/locking.rs-    Intent,
crates/causality-effects/src/resource/locking.rs-}
crates/causality-effects/src/resource/locking.rs-
crates/causality-effects/src/resource/locking.rs:/// Resource lock info
crates/causality-effects/src/resource/locking.rs-#[derive(Debug, Clone)]
crates/causality-effects/src/resource/locking.rs-pub struct ResourceLock {
crates/causality-effects/src/resource/locking.rs:    /// Resource ID
crates/causality-effects/src/resource/locking.rs-    pub resource_id: ContentId,
crates/causality-effects/src/resource/locking.rs-    
crates/causality-effects/src/resource/locking.rs:    /// Lock type
crates/causality-effects/src/resource/locking.rs-    pub lock_type: CrossDomainLockType,
crates/causality-effects/src/resource/locking.rs-    
crates/causality-effects/src/resource/locking.rs:    /// Domain ID where the resource is located
crates/causality-effects/src/resource/locking.rs-    pub domain_id: Option<DomainId>,
crates/causality-effects/src/resource/locking.rs-    
crates/causality-effects/src/resource/locking.rs:    /// Effect ID that holds the lock
crates/causality-effects/src/resource/locking.rs-    pub holder_id: EffectId,
crates/causality-effects/src/resource/locking.rs-    
crates/causality-effects/src/resource/locking.rs:    /// When the lock was acquired
crates/causality-effects/src/resource/locking.rs-    pub acquired_at: chrono::DateTime<chrono::Utc>,
crates/causality-effects/src/resource/locking.rs-    
crates/causality-effects/src/resource/locking.rs:    /// Lock timeout (if any)
crates/causality-effects/src/resource/locking.rs-    pub timeout: Option<Duration>,
crates/causality-effects/src/resource/locking.rs-    
crates/causality-effects/src/resource/locking.rs:    /// Transaction ID (if this lock is part of a transaction)
crates/causality-effects/src/resource/locking.rs-    pub transaction_id: Option<String>,
crates/causality-effects/src/resource/locking.rs-}
crates/causality-effects/src/resource/locking.rs-
crates/causality-effects/src/resource/locking.rs-impl ResourceLock {
crates/causality-effects/src/resource/locking.rs:    /// Create a new resource lock
crates/causality-effects/src/resource/locking.rs-    pub fn new(
--
crates/causality-effects/src/resource/locking.rs-        lock_type: CrossDomainLockType,
crates/causality-effects/src/resource/locking.rs-        holder_id: EffectId,
crates/causality-effects/src/resource/locking.rs-    ) -> Self {
--
crates/causality-effects/src/resource/locking.rs:    /// Create a resource lock with domain
crates/causality-effects/src/resource/locking.rs-    pub fn with_domain(
--
crates/causality-effects/src/resource/locking.rs-        lock_type: CrossDomainLockType,
crates/causality-effects/src/resource/locking.rs-        domain_id: DomainId,
crates/causality-effects/src/resource/locking.rs-        holder_id: EffectId,
--
crates/causality-effects/src/resource/locking.rs:    /// Set a timeout for the lock
crates/causality-effects/src/resource/locking.rs-    pub fn with_timeout(mut self, timeout: Duration) -> Self {
crates/causality-effects/src/resource/locking.rs-        self.timeout = Some(timeout);
crates/causality-effects/src/resource/locking.rs-        self
crates/causality-effects/src/resource/locking.rs-    }
crates/causality-effects/src/resource/locking.rs-    
crates/causality-effects/src/resource/locking.rs:    /// Associate the lock with a transaction
crates/causality-effects/src/resource/locking.rs-    pub fn with_transaction(mut self, transaction_id: String) -> Self {
crates/causality-effects/src/resource/locking.rs-        self.transaction_id = Some(transaction_id);
crates/causality-effects/src/resource/locking.rs-        self
crates/causality-effects/src/resource/locking.rs-    }
crates/causality-effects/src/resource/locking.rs-    
crates/causality-effects/src/resource/locking.rs:    /// Check if the lock has expired
crates/causality-effects/src/resource/locking.rs-    pub fn is_expired(&self) -> bool {
--
crates/causality-effects/src/resource/locking.rs-            let elapsed = chrono::Utc::now()
crates/causality-effects/src/resource/locking.rs-                .signed_duration_since(self.acquired_at)
crates/causality-effects/src/resource/locking.rs-                .to_std()
--
crates/causality-effects/src/resource/locking.rs:/// Lock manager for cross-domain operations
crates/causality-effects/src/resource/locking.rs-pub struct CrossDomainLockManager {
--
crates/causality-effects/src/resource/locking.rs-    timeout_handlers: Mutex<HashMap<ContentId, Box<dyn Fn(ResourceLock) + Send + Sync>>>,
crates/causality-effects/src/resource/locking.rs-}
crates/causality-effects/src/resource/locking.rs-
crates/causality-effects/src/resource/locking.rs-impl CrossDomainLockManager {
crates/causality-effects/src/resource/locking.rs:    /// Create a new cross-domain lock manager
crates/causality-effects/src/resource/locking.rs-    pub fn new(access_tracker: Arc<ResourceAccessTracker>) -> Self {
--
crates/causality-effects/src/resource/locking.rs-            locks: RwLock::new(HashMap::new()),
crates/causality-effects/src/resource/locking.rs-            locks_by_domain: RwLock::new(HashMap::new()),
crates/causality-effects/src/resource/locking.rs-            locks_by_effect: RwLock::new(HashMap::new()),
--
crates/causality-effects/src/resource/locking.rs:    /// Try to acquire a lock on a resource
crates/causality-effects/src/resource/locking.rs-    pub fn try_acquire_lock(
--
crates/causality-effects/src/resource/locking.rs-        resource_id: &ContentId,
crates/causality-effects/src/resource/locking.rs-        lock_type: CrossDomainLockType,
crates/causality-effects/src/resource/locking.rs-        holder_id: &EffectId,
--
crates/causality-effects/src/resource/locking.rs:    /// Acquire a lock with timeout
crates/causality-effects/src/resource/locking.rs-    pub async fn acquire_lock_with_timeout(
--
crates/causality-effects/src/resource/locking.rs-        resource_id: &ContentId,
crates/causality-effects/src/resource/locking.rs-        lock_type: CrossDomainLockType,
crates/causality-effects/src/resource/locking.rs-        holder_id: &EffectId,
--
crates/causality-effects/src/resource/locking.rs:    /// Release a lock
crates/causality-effects/src/resource/locking.rs-    pub fn release_lock(
--
crates/causality-effects/src/resource/locking.rs-        resource_id: &ContentId,
crates/causality-effects/src/resource/locking.rs-        holder_id: &EffectId,
crates/causality-effects/src/resource/locking.rs-    ) -> Result<()> {
--
crates/causality-effects/src/resource/locking.rs:    /// Check if a lock is held by a specific effect
crates/causality-effects/src/resource/locking.rs-    pub fn is_lock_held(
--
crates/causality-effects/src/resource/locking.rs-        resource_id: &ContentId,
crates/causality-effects/src/resource/locking.rs-        holder_id: &EffectId,
crates/causality-effects/src/resource/locking.rs-    ) -> bool {
--
crates/causality-effects/src/resource/locking.rs:    /// Check if a lock can be acquired
crates/causality-effects/src/resource/locking.rs-    pub fn can_acquire_lock(
--
crates/causality-effects/src/resource/locking.rs-        resource_id: &ContentId,
crates/causality-effects/src/resource/locking.rs-        lock_type: CrossDomainLockType,
crates/causality-effects/src/resource/locking.rs-        holder_id: &EffectId,
--
crates/causality-effects/src/resource/locking.rs:    /// Get all locks for a resource
crates/causality-effects/src/resource/locking.rs-    pub fn get_locks(&self, resource_id: &ContentId) -> Vec<ResourceLock> {
--
crates/causality-effects/src/resource/locking.rs-        
crates/causality-effects/src/resource/locking.rs-        locks.get(resource_id)
crates/causality-effects/src/resource/locking.rs-            .cloned()
--
crates/causality-effects/src/resource/locking.rs:    /// Get all locks held by an effect
crates/causality-effects/src/resource/locking.rs-    pub fn get_locks_by_effect(&self, effect_id: &EffectId) -> Vec<ResourceLock> {
--
crates/causality-effects/src/resource/locking.rs-        
crates/causality-effects/src/resource/locking.rs-        if let Some(resources) = effect_locks.get(effect_id) {
crates/causality-effects/src/resource/locking.rs-            let locks = self.locks.read().unwrap();
--
crates/causality-effects/src/resource/locking.rs:    /// Get all locks for a domain
crates/causality-effects/src/resource/locking.rs-    pub fn get_locks_by_domain(&self, domain_id: &DomainId) -> Vec<ResourceLock> {
--
crates/causality-effects/src/resource/locking.rs-        
crates/causality-effects/src/resource/locking.rs-        if let Some(resources) = domain_locks.get(domain_id) {
crates/causality-effects/src/resource/locking.rs-            let locks = self.locks.read().unwrap();
--
crates/causality-effects/src/resource/locking.rs:    /// Get all locks for a transaction
crates/causality-effects/src/resource/locking.rs-    pub fn get_locks_by_transaction(&self, transaction_id: &str) -> Vec<ResourceLock> {
--
crates/causality-effects/src/resource/locking.rs-        
crates/causality-effects/src/resource/locking.rs-        if let Some(resources) = transaction_locks.get(transaction_id) {
crates/causality-effects/src/resource/locking.rs-            let locks = self.locks.read().unwrap();
--
crates/causality-effects/src/resource/locking.rs:    /// Register a timeout handler
crates/causality-effects/src/resource/locking.rs-    pub fn register_timeout_handler<F>(
--
crates/causality-effects/src/resource/locking.rs-        resource_id: ContentId,
crates/causality-effects/src/resource/locking.rs-        handler: F,
crates/causality-effects/src/resource/locking.rs-    ) where
--
crates/causality-effects/src/resource/locking.rs:    /// Check for expired locks and handle them
crates/causality-effects/src/resource/locking.rs-    pub fn handle_expired_locks(&self) -> Result<usize> {
--
crates/causality-effects/src/resource/locking.rs-        
crates/causality-effects/src/resource/locking.rs-        // Get timeout handlers
--
crates/causality-effects/src/resource/locking.rs:/// Effect for acquiring a cross-domain resource lock
crates/causality-effects/src/resource/locking.rs-#[derive(Debug)]
crates/causality-effects/src/resource/locking.rs-pub struct AcquireLockEffect {
--
crates/causality-effects/src/resource/locking.rs-    transaction_id: Option<String>,
crates/causality-effects/src/resource/locking.rs-}
crates/causality-effects/src/resource/locking.rs-
crates/causality-effects/src/resource/locking.rs-impl AcquireLockEffect {
crates/causality-effects/src/resource/locking.rs:    /// Create a new acquire lock effect
crates/causality-effects/src/resource/locking.rs-    pub fn new(
--
crates/causality-effects/src/resource/locking.rs-        lock_type: CrossDomainLockType,
crates/causality-effects/src/resource/locking.rs-    ) -> Self {
crates/causality-effects/src/resource/locking.rs-        Self {
--
crates/causality-effects/src/resource/locking.rs:    /// Set the domain ID
crates/causality-effects/src/resource/locking.rs-    pub fn with_domain(mut self, domain_id: DomainId) -> Self {
crates/causality-effects/src/resource/locking.rs-        self.domain_id = Some(domain_id);
crates/causality-effects/src/resource/locking.rs-        self
crates/causality-effects/src/resource/locking.rs-    }
crates/causality-effects/src/resource/locking.rs-    
crates/causality-effects/src/resource/locking.rs:    /// Set a timeout
crates/causality-effects/src/resource/locking.rs-    pub fn with_timeout(mut self, timeout: Duration) -> Self {
crates/causality-effects/src/resource/locking.rs-        self.timeout = Some(timeout);
crates/causality-effects/src/resource/locking.rs-        self
crates/causality-effects/src/resource/locking.rs-    }
crates/causality-effects/src/resource/locking.rs-    
crates/causality-effects/src/resource/locking.rs:    /// Associate with a transaction
crates/causality-effects/src/resource/locking.rs-    pub fn with_transaction(mut self, transaction_id: String) -> Self {
crates/causality-effects/src/resource/locking.rs-        self.transaction_id = Some(transaction_id);
crates/causality-effects/src/resource/locking.rs-        self
crates/causality-effects/src/resource/locking.rs-    }
crates/causality-effects/src/resource/locking.rs-    
crates/causality-effects/src/resource/locking.rs:    /// Get the resource ID
crates/causality-effects/src/resource/locking.rs-    pub fn resource_id(&self) -> &ContentId {
crates/causality-effects/src/resource/locking.rs-        &self.resource_id
crates/causality-effects/src/resource/locking.rs-    }
crates/causality-effects/src/resource/locking.rs-    
crates/causality-effects/src/resource/locking.rs:    /// Get the lock type
crates/causality-effects/src/resource/locking.rs-    pub fn lock_type(&self) -> CrossDomainLockType {
crates/causality-effects/src/resource/locking.rs-        self.lock_type
crates/causality-effects/src/resource/locking.rs-    }
crates/causality-effects/src/resource/locking.rs-    
crates/causality-effects/src/resource/locking.rs:    /// Get the domain ID
crates/causality-effects/src/resource/locking.rs-    pub fn domain_id(&self) -> Option<&DomainId> {
--
crates/causality-effects/src/resource/locking.rs-    }
crates/causality-effects/src/resource/locking.rs-}
crates/causality-effects/src/resource/locking.rs-
crates/causality-effects/src/resource/locking.rs:/// Effect for releasing a cross-domain resource lock
crates/causality-effects/src/resource/locking.rs-#[derive(Debug)]
crates/causality-effects/src/resource/locking.rs-pub struct ReleaseLockEffect {
--
crates/causality-effects/src/resource/locking.rs-    domain_id: Option<DomainId>,
crates/causality-effects/src/resource/locking.rs-}
crates/causality-effects/src/resource/locking.rs-
crates/causality-effects/src/resource/locking.rs-impl ReleaseLockEffect {
crates/causality-effects/src/resource/locking.rs:    /// Create a new release lock effect
crates/causality-effects/src/resource/locking.rs-    pub fn new(resource_id: ContentId) -> Self {
--
crates/causality-effects/src/resource/locking.rs-            id: EffectId::new(),
crates/causality-effects/src/resource/locking.rs-            resource_id,
crates/causality-effects/src/resource/locking.rs-            domain_id: None,
--
crates/causality-effects/src/resource/locking.rs:    /// Set the domain ID
crates/causality-effects/src/resource/locking.rs-    pub fn with_domain(mut self, domain_id: DomainId) -> Self {
crates/causality-effects/src/resource/locking.rs-        self.domain_id = Some(domain_id);
crates/causality-effects/src/resource/locking.rs-        self
crates/causality-effects/src/resource/locking.rs-    }
crates/causality-effects/src/resource/locking.rs-    
crates/causality-effects/src/resource/locking.rs:    /// Get the resource ID
crates/causality-effects/src/resource/locking.rs-    pub fn resource_id(&self) -> &ContentId {
crates/causality-effects/src/resource/locking.rs-        &self.resource_id
crates/causality-effects/src/resource/locking.rs-    }
crates/causality-effects/src/resource/locking.rs-    
crates/causality-effects/src/resource/locking.rs:    /// Get the domain ID
crates/causality-effects/src/resource/locking.rs-    pub fn domain_id(&self) -> Option<&DomainId> {
--
crates/causality-effects/src/resource/locking.rs-    }
crates/causality-effects/src/resource/locking.rs-} 
--
crates/causality-effects/src/resource/capability.rs:/// Resource-specific capability types that extend the unified capability system
crates/causality-effects/src/resource/capability.rs-#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
crates/causality-effects/src/resource/capability.rs-pub enum ResourceCapability {
--
crates/causality-effects/src/resource/capability.rs-    AccessResource(ResourceAccessType),
crates/causality-effects/src/resource/capability.rs-    
--
crates/causality-effects/src/resource/capability.rs:/// Resource lifecycle-specific capabilities
crates/causality-effects/src/resource/capability.rs-#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
crates/causality-effects/src/resource/capability.rs-pub enum ResourceLifecycleCapability {
--
crates/causality-effects/src/resource/capability.rs-        match cap {
crates/causality-effects/src/resource/capability.rs-            ResourceCapability::AccessResource(access_type) => {
crates/causality-effects/src/resource/capability.rs-                match access_type {
--
crates/causality-effects/src/resource/capability.rs:/// Resource capability manager that coordinates capabilities with resource operations
crates/causality-effects/src/resource/capability.rs-pub struct ResourceCapabilityManager {
--
crates/causality-effects/src/resource/capability.rs-    capability_cache: RwLock<HashMap<(ContentId, ResourceCapability), bool>>,
crates/causality-effects/src/resource/capability.rs-}
crates/causality-effects/src/resource/capability.rs-
crates/causality-effects/src/resource/capability.rs-impl ResourceCapabilityManager {
crates/causality-effects/src/resource/capability.rs:    /// Create a new resource capability manager
crates/causality-effects/src/resource/capability.rs-    pub fn new(
--
crates/causality-effects/src/resource/capability.rs-        access_manager: Arc<ResourceAccessManager>,
crates/causality-effects/src/resource/capability.rs-        lifecycle_manager: Arc<EffectResourceLifecycle>,
crates/causality-effects/src/resource/capability.rs-        lock_manager: Arc<CrossDomainLockManager>,
--
crates/causality-effects/src/resource/capability.rs:    /// Check if a capability for a resource operation is granted
crates/causality-effects/src/resource/capability.rs-    pub async fn check_resource_capability(
--
crates/causality-effects/src/resource/capability.rs-        resource_id: &ContentId,
crates/causality-effects/src/resource/capability.rs-        capability: ResourceCapability,
crates/causality-effects/src/resource/capability.rs-        effect_id: Option<&EffectId>,
--
crates/causality-effects/src/resource/capability.rs:    /// Check if an access operation is allowed for a resource
crates/causality-effects/src/resource/capability.rs-    pub async fn check_access_capability(
--
crates/causality-effects/src/resource/capability.rs-        resource_id: &ContentId,
crates/causality-effects/src/resource/capability.rs-        access_type: ResourceAccessType,
crates/causality-effects/src/resource/capability.rs-        effect_id: Option<&EffectId>,
--
crates/causality-effects/src/resource/capability.rs:    /// Check if a lifecycle operation is allowed for a resource
crates/causality-effects/src/resource/capability.rs-    pub async fn check_lifecycle_capability(
--
crates/causality-effects/src/resource/capability.rs-        resource_id: &ContentId,
crates/causality-effects/src/resource/capability.rs-        lifecycle_cap: ResourceLifecycleCapability,
crates/causality-effects/src/resource/capability.rs-        effect_id: Option<&EffectId>,
--
crates/causality-effects/src/resource/capability.rs:    /// Check if a locking operation is allowed for a resource
crates/causality-effects/src/resource/capability.rs-    pub async fn check_lock_capability(
--
crates/causality-effects/src/resource/capability.rs-        resource_id: &ContentId,
crates/causality-effects/src/resource/capability.rs-        lock_type: CrossDomainLockType,
crates/causality-effects/src/resource/capability.rs-        effect_id: Option<&EffectId>,
--
crates/causality-effects/src/resource/capability.rs:    /// Check if a dependency operation is allowed for a resource
crates/causality-effects/src/resource/capability.rs-    pub async fn check_dependency_capability(
--
crates/causality-effects/src/resource/capability.rs-        resource_id: &ContentId,
crates/causality-effects/src/resource/capability.rs-        dependency_type: DependencyType,
crates/causality-effects/src/resource/capability.rs-        effect_id: Option<&EffectId>,
--
crates/causality-effects/src/resource/capability.rs:    /// Check if full resource control is granted
crates/causality-effects/src/resource/capability.rs-    pub async fn check_full_control(
--
crates/causality-effects/src/resource/capability.rs-        resource_id: &ContentId,
crates/causality-effects/src/resource/capability.rs-        effect_id: Option<&EffectId>,
crates/causality-effects/src/resource/capability.rs-        domain_id: Option<&DomainId>,
--
crates/causality-effects/src/resource/capability.rs:    /// Clear cached capability checks
crates/causality-effects/src/resource/capability.rs-    pub fn clear_cache(&self) {
crates/causality-effects/src/resource/capability.rs-        let mut cache = self.capability_cache.write().unwrap();
crates/causality-effects/src/resource/capability.rs-        cache.clear();
crates/causality-effects/src/resource/capability.rs-    }
crates/causality-effects/src/resource/capability.rs-    
crates/causality-effects/src/resource/capability.rs:    /// Clear cached capability checks for a specific resource
crates/causality-effects/src/resource/capability.rs-    pub fn clear_cache_for_resource(&self, resource_id: &ContentId) {
--
crates/causality-effects/src/resource/capability.rs-    }
crates/causality-effects/src/resource/capability.rs-} 
--
crates/causality-effects/src/transfer.rs:/// Parameters for the TransferEffect
crates/causality-effects/src/transfer.rs-#[derive(Debug, Clone, Serialize, Deserialize)]
crates/causality-effects/src/transfer.rs-pub struct TransferParams {
crates/causality-effects/src/transfer.rs:    /// The source resource to transfer from
crates/causality-effects/src/transfer.rs-    pub source_resource_id: ContentId,
crates/causality-effects/src/transfer.rs-    
crates/causality-effects/src/transfer.rs:    /// The destination resource to transfer to
crates/causality-effects/src/transfer.rs-    pub destination_resource_id: ContentId,
crates/causality-effects/src/transfer.rs-    
crates/causality-effects/src/transfer.rs:    /// The amount to transfer (for fungible resources)
crates/causality-effects/src/transfer.rs-    pub amount: Option<u64>,
crates/causality-effects/src/transfer.rs-    
crates/causality-effects/src/transfer.rs:    /// Additional parameters for the transfer
crates/causality-effects/src/transfer.rs-    pub additional_params: HashMap<String, String>,
crates/causality-effects/src/transfer.rs-}
crates/causality-effects/src/transfer.rs-
crates/causality-effects/src/transfer.rs:/// The TransferEffect handles transferring resources between accounts
crates/causality-effects/src/transfer.rs-#[derive(Debug, Clone)]
crates/causality-effects/src/transfer.rs-pub struct TransferEffect {
--
crates/causality-effects/src/transfer.rs-    fact_dependencies: Vec<FactDependency>,
crates/causality-effects/src/transfer.rs-}
crates/causality-effects/src/transfer.rs-
crates/causality-effects/src/transfer.rs-impl TransferEffect {
crates/causality-effects/src/transfer.rs:    /// Create a new transfer effect
crates/causality-effects/src/transfer.rs-    pub fn new(
--
crates/causality-effects/src/transfer.rs-        params: TransferParams,
crates/causality-effects/src/transfer.rs-    ) -> Self {
crates/causality-effects/src/transfer.rs-        TransferEffect {
--
crates/causality-effects/src/transfer.rs:    /// Factory method to create a new transfer effect
crates/causality-effects/src/transfer.rs-    pub fn create_transfer(resource_api: Arc<dyn ResourceAPI>, params: TransferParams) -> Arc<dyn Effect> {
--
crates/causality-effects/src/transfer.rs-            .find(|cap| {
crates/causality-effects/src/transfer.rs-                let cap_obj = cap.capability();
--
crates/causality-effects/src/transfer.rs:/// Implementation of a transfer effect
crates/causality-effects/src/transfer.rs-#[derive(Debug)]
crates/causality-effects/src/transfer.rs-pub struct TransferEffectImpl {
crates/causality-effects/src/transfer.rs-    // ... existing fields ...
crates/causality-effects/src/transfer.rs-}
crates/causality-effects/src/transfer.rs-
crates/causality-effects/src/transfer.rs:/// Factory function to create a new transfer effect
crates/causality-effects/src/transfer.rs-pub fn create_transfer_effect(
--
crates/causality-effects/src/transfer.rs-    // ... existing implementation ...
crates/causality-effects/src/transfer.rs-}
--
crates/causality-effects/src/content.rs:/// The type of hash algorithm used
crates/causality-effects/src/content.rs-#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
crates/causality-effects/src/content.rs-pub enum HashAlgorithm {
--
crates/causality-effects/src/content.rs-}
crates/causality-effects/src/content.rs-
crates/causality-effects/src/content.rs-impl std::hash::Hash for HashAlgorithm {
--
crates/causality-effects/src/content.rs:    /// Get the digest size of the algorithm in bytes
crates/causality-effects/src/content.rs-    pub fn digest_size(&self) -> usize {
--
crates/causality-effects/src/content.rs-            HashAlgorithm::Blake3 => 32, // 256 bits
crates/causality-effects/src/content.rs-            HashAlgorithm::Poseidon => 32, // 256 bits
crates/causality-effects/src/content.rs-        }
--
crates/causality-effects/src/content.rs:    /// Convert to a string representation
crates/causality-effects/src/content.rs-    pub fn as_str(&self) -> &'static str {
--
crates/causality-effects/src/content.rs-            HashAlgorithm::Poseidon => "poseidon",
crates/causality-effects/src/content.rs-        }
--
crates/causality-effects/src/content.rs:/// A content hash with algorithm information
crates/causality-effects/src/content.rs-#[derive(Clone, PartialEq, Eq)]
crates/causality-effects/src/content.rs-pub struct ContentHash {
crates/causality-effects/src/content.rs:    /// The hash algorithm used
crates/causality-effects/src/content.rs-    pub algorithm: HashAlgorithm,
crates/causality-effects/src/content.rs:    /// The hash bytes
crates/causality-effects/src/content.rs-    pub bytes: Vec<u8>,
crates/causality-effects/src/content.rs-}
crates/causality-effects/src/content.rs-
crates/causality-effects/src/content.rs-impl ContentHash {
crates/causality-effects/src/content.rs:    /// Create a new content hash with the given algorithm and bytes
crates/causality-effects/src/content.rs-    pub fn new(algorithm: HashAlgorithm, bytes: Vec<u8>) -> Self {
crates/causality-effects/src/content.rs-        Self { algorithm, bytes }
crates/causality-effects/src/content.rs-    }
crates/causality-effects/src/content.rs-    
crates/causality-effects/src/content.rs:    /// Create a Blake3 hash from bytes
crates/causality-effects/src/content.rs-    pub fn blake3(data: &[u8]) -> Self {
--
crates/causality-effects/src/content.rs-        hasher.update(data);
crates/causality-effects/src/content.rs-        let hash = hasher.finalize();
crates/causality-effects/src/content.rs-        
--
crates/causality-effects/src/content.rs:    /// Create a hash from a string using Blake3
crates/causality-effects/src/content.rs-    pub fn from_string(s: &str) -> Self {
crates/causality-effects/src/content.rs-        Self::blake3(s.as_bytes())
crates/causality-effects/src/content.rs-    }
crates/causality-effects/src/content.rs-    
crates/causality-effects/src/content.rs:    /// Convert the hash to a hex string
crates/causality-effects/src/content.rs-    pub fn to_hex(&self) -> String {
crates/causality-effects/src/content.rs-        hex::encode(&self.bytes)
crates/causality-effects/src/content.rs-    }
crates/causality-effects/src/content.rs-    
crates/causality-effects/src/content.rs:    /// Check if this is an empty/default hash
crates/causality-effects/src/content.rs-    pub fn is_empty(&self) -> bool {
--
crates/causality-effects/src/content.rs-}
crates/causality-effects/src/content.rs-
--
crates/causality-effects/src/content.rs:/// Represents the content of a code definition
crates/causality-effects/src/content.rs-#[derive(Debug, Clone, Serialize, Deserialize)]
crates/causality-effects/src/content.rs-pub enum CodeContent {
--
crates/causality-effects/src/content.rs-    Wasm(Vec<u8>),
crates/causality-effects/src/content.rs-}
crates/causality-effects/src/content.rs-
crates/causality-effects/src/content.rs:/// A code definition with its metadata
crates/causality-effects/src/content.rs-#[derive(Debug, Clone, Serialize, Deserialize)]
crates/causality-effects/src/content.rs-pub struct CodeDefinition {
crates/causality-effects/src/content.rs:    /// The content hash of this definition
crates/causality-effects/src/content.rs-    pub hash: ContentHash,
crates/causality-effects/src/content.rs:    /// The human-readable name (if any)
crates/causality-effects/src/content.rs-    pub name: Option<String>,
crates/causality-effects/src/content.rs:    /// The actual code representation (AST or bytecode)
crates/causality-effects/src/content.rs-    pub content: CodeContent,
crates/causality-effects/src/content.rs:    /// Dependencies of this code definition
crates/causality-effects/src/content.rs-    pub dependencies: Vec<ContentHash>,
crates/causality-effects/src/content.rs:    /// Additional metadata
crates/causality-effects/src/content.rs-    pub metadata: HashMap<String, serde_json::Value>,
crates/causality-effects/src/content.rs-}
crates/causality-effects/src/content.rs-
crates/causality-effects/src/content.rs-impl CodeDefinition {
crates/causality-effects/src/content.rs:    /// Create a new code definition builder
crates/causality-effects/src/content.rs-    pub fn builder() -> CodeDefinitionBuilder {
crates/causality-effects/src/content.rs-        CodeDefinitionBuilder::new()
crates/causality-effects/src/content.rs-    }
crates/causality-effects/src/content.rs-}
crates/causality-effects/src/content.rs-
crates/causality-effects/src/content.rs:/// Builder for code definitions
crates/causality-effects/src/content.rs-pub struct CodeDefinitionBuilder {
--
crates/causality-effects/src/content.rs-    content: Option<CodeContent>,
crates/causality-effects/src/content.rs-    dependencies: Vec<ContentHash>,
crates/causality-effects/src/content.rs-    metadata: HashMap<String, serde_json::Value>,
--
crates/causality-effects/src/content.rs:    /// Create a new builder
crates/causality-effects/src/content.rs-    pub fn new() -> Self {
--
crates/causality-effects/src/content.rs-            name: None,
crates/causality-effects/src/content.rs-            content: None,
crates/causality-effects/src/content.rs-            dependencies: Vec::new(),
--
crates/causality-effects/src/content.rs:    /// Set the name
crates/causality-effects/src/content.rs-    pub fn name(mut self, name: &str) -> Self {
crates/causality-effects/src/content.rs-        self.name = Some(name.to_string());
crates/causality-effects/src/content.rs-        self
crates/causality-effects/src/content.rs-    }
crates/causality-effects/src/content.rs-    
crates/causality-effects/src/content.rs:    /// Set the content
crates/causality-effects/src/content.rs-    pub fn content(mut self, content: CodeContent) -> Self {
crates/causality-effects/src/content.rs-        self.content = Some(content);
crates/causality-effects/src/content.rs-        self
crates/causality-effects/src/content.rs-    }
crates/causality-effects/src/content.rs-    
crates/causality-effects/src/content.rs:    /// Add a dependency
crates/causality-effects/src/content.rs-    pub fn dependency(mut self, hash: ContentHash) -> Self {
crates/causality-effects/src/content.rs-        self.dependencies.push(hash);
crates/causality-effects/src/content.rs-        self
crates/causality-effects/src/content.rs-    }
crates/causality-effects/src/content.rs-    
crates/causality-effects/src/content.rs:    /// Add dependencies
crates/causality-effects/src/content.rs-    pub fn dependencies(mut self, hashes: Vec<ContentHash>) -> Self {
crates/causality-effects/src/content.rs-        self.dependencies.extend(hashes);
crates/causality-effects/src/content.rs-        self
crates/causality-effects/src/content.rs-    }
crates/causality-effects/src/content.rs-    
crates/causality-effects/src/content.rs:    /// Add metadata
crates/causality-effects/src/content.rs-    pub fn metadata(mut self, key: &str, value: serde_json::Value) -> Self {
crates/causality-effects/src/content.rs-        self.metadata.insert(key.to_string(), value);
crates/causality-effects/src/content.rs-        self
crates/causality-effects/src/content.rs-    }
crates/causality-effects/src/content.rs-    
crates/causality-effects/src/content.rs:    /// Build the code definition
crates/causality-effects/src/content.rs-    pub fn build(self) -> Result<CodeDefinition, String> {
