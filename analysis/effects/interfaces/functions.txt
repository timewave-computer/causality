crates/causality-effects/tests/basic/mod.rs:    pub fn new(
crates/causality-effects/tests/basic/mod.rs:    pub fn new(
crates/causality-effects/tests/basic/mod.rs:    pub fn new(
crates/causality-effects/src/three_layer.rs:    pub fn new(
crates/causality-effects/src/three_layer.rs:    pub fn register_domain_adapter(&mut self, domain_id: DomainId, adapter: Arc<dyn DomainAdapter>) {
crates/causality-effects/src/three_layer.rs:    pub fn register_fallback_handler(&mut self, effect_type: &'static str, handler: Arc<dyn FallbackHandler>) {
crates/causality-effects/src/three_layer.rs:    pub fn new() -> Self {
crates/causality-effects/src/random.rs:    pub fn new() -> Self {
crates/causality-effects/src/random.rs:    pub fn with_seed(seed: u64) -> Self {
crates/causality-effects/src/random.rs:    pub fn new() -> Self {
crates/causality-effects/src/random.rs:    pub fn create_effect(random_type: RandomType) -> Box<dyn RandomEffect> {
crates/causality-effects/src/effect_id.rs:    pub fn new(id: String) -> Self {
crates/causality-effects/src/effect_id.rs:    pub fn new_unique() -> Self {
crates/causality-effects/src/effect_id.rs:    pub fn for_effect_type(effect_type: &str) -> Self {
crates/causality-effects/src/effect_id.rs:    pub fn as_str(&self) -> &str {
crates/causality-effects/src/constraints/validation.rs:    pub fn new(
crates/causality-effects/src/constraints/validation.rs:    pub fn new(validator: EffectValidator) -> Self {
crates/causality-effects/src/constraints/validation.rs:    pub fn new(
crates/causality-effects/src/constraints/validation.rs:    pub fn name(&self) -> &str {
crates/causality-effects/src/constraints/validation.rs:    pub fn description(&self) -> &str {
crates/causality-effects/src/constraints/validation.rs:    pub fn applies_to(&self, effect: &dyn Effect) -> bool {
crates/causality-effects/src/constraints/validation.rs:    pub fn verify(&self, effect: &dyn Effect) -> ConstraintVerificationResult {
crates/causality-effects/src/constraints/validation.rs:pub fn create_constraint(
crates/causality-effects/src/constraints/validation.rs:    pub fn new() -> Self {
crates/causality-effects/src/constraints/validation.rs:    pub fn register_constraint(&mut self, constraint: EffectConstraint) {
crates/causality-effects/src/constraints/validation.rs:    pub fn register_constraints(&mut self, constraints: Vec<EffectConstraint>) {
crates/causality-effects/src/constraints/validation.rs:    pub fn verify(&self, effect: &dyn Effect) -> Vec<(String, ConstraintVerificationResult)> {
crates/causality-effects/src/constraints/validation.rs:    pub fn verify_all_satisfied(&self, effect: &dyn Effect) -> Result<(), String> {
crates/causality-effects/src/handler.rs:    pub fn new(boundary: ExecutionBoundary) -> Self {
crates/causality-effects/src/handler.rs:    pub fn add_handler(&mut self, handler: Arc<dyn EffectHandler>) {
crates/causality-effects/src/handler.rs:    pub fn new() -> Self {
crates/causality-effects/src/handler.rs:    pub fn new() -> Self {
crates/causality-effects/src/handler.rs:    pub fn create(boundary: ExecutionBoundary) -> Box<dyn EffectHandler> {
crates/causality-effects/src/handler.rs:    pub fn create_composite(primary_boundary: ExecutionBoundary, 
crates/causality-effects/src/lib.rs:    pub fn success(id: EffectId) -> Self {
crates/causality-effects/src/lib.rs:    pub fn failure(id: EffectId, error: impl Into<String>) -> Self {
crates/causality-effects/src/lib.rs:    pub fn with_execution_id(mut self, execution_id: ContentId) -> Self {
crates/causality-effects/src/lib.rs:    pub fn with_data(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/lib.rs:    pub fn with_resource_change(mut self, change: ResourceChange) -> Self {
crates/causality-effects/src/lib.rs:    pub fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/lib.rs:    pub fn new() -> Self {
crates/causality-effects/src/lib.rs:    pub fn with_caller(caller: String) -> Self {
crates/causality-effects/src/lib.rs:    pub fn with_param(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/lib.rs:    pub fn new() -> Self {
crates/causality-effects/src/lib.rs:    pub fn register(&mut self, effect: Arc<dyn Effect>) {
crates/causality-effects/src/lib.rs:    pub fn get(&self, name: &str) -> Option<Arc<dyn Effect>> {
crates/causality-effects/src/lib.rs:    pub fn get_all(&self) -> Vec<Arc<dyn Effect>> {
crates/causality-effects/src/lib.rs:    pub fn get_for_boundary(&self, boundary: ExecutionBoundary) -> Vec<Arc<dyn Effect>> {
crates/causality-effects/src/lib.rs:    pub fn record_crossing<T>(&mut self, crossing: &boundary::BoundaryCrossing<T>, 
crates/causality-effects/src/lib.rs:    pub fn crossing_registry(&self) -> &boundary::BoundaryCrossingRegistry {
crates/causality-effects/src/lib.rs:    pub fn new() -> Self {
crates/causality-effects/src/lib.rs:    pub fn with_resource_api(resource_api: Arc<dyn resource_api>) -> Self {
crates/causality-effects/src/lib.rs:    pub fn register_effect(&mut self, effect: Arc<dyn Effect>) {
crates/causality-effects/src/lib.rs:    pub fn registry(&self) -> &EffectRegistry {
crates/causality-effects/src/lib.rs:    pub fn registry_mut(&mut self) -> &mut EffectRegistry {
crates/causality-effects/src/lib.rs:    pub fn new() -> Self {
crates/causality-effects/src/lib.rs:    pub fn with_name(name: impl Into<String>) -> Self {
crates/causality-effects/src/lib.rs:    pub fn with_description(description: impl Into<String>) -> Self {
crates/causality-effects/src/lib.rs:    pub fn with_boundary(boundary: ExecutionBoundary) -> Self {
crates/causality-effects/src/capability/conversion.rs:pub fn convert_domain_to_effect_capabilities(
crates/causality-effects/src/capability/conversion.rs:pub fn convert_effect_to_domain_capabilities(
crates/causality-effects/src/capability/conversion.rs:pub fn map_domain_to_effect_capability(domain_cap: &DomainCapability) -> Option<EffectCapability> {
crates/causality-effects/src/capability/conversion.rs:pub fn map_effect_to_domain_capability(effect_cap: &EffectCapability) -> Option<DomainCapability> {
crates/causality-effects/src/capability/conversion.rs:pub fn map_domain_to_cross_domain_capability(domain_cap: &DomainCapability) -> Option<CrossDomainCapability> {
crates/causality-effects/src/capability/conversion.rs:pub fn verify_domain_capabilities(
crates/causality-effects/src/capability/conversion.rs:pub fn create_inherited_capabilities(
crates/causality-effects/src/capability/verification.rs:    pub fn new() -> Self {
crates/causality-effects/src/capability/verification.rs:    pub fn register_required_domain_capabilities(
crates/causality-effects/src/capability/verification.rs:    pub fn register_required_effect_capabilities(
crates/causality-effects/src/capability/verification.rs:    pub fn register_required_cross_domain_capabilities(
crates/causality-effects/src/capability/verification.rs:    pub fn get_required_domain_capabilities(&self, effect_type: &str) -> Vec<DomainCapability> {
crates/causality-effects/src/capability/verification.rs:    pub fn get_required_effect_capabilities(&self, effect_type: &str) -> Vec<EffectCapability> {
crates/causality-effects/src/capability/verification.rs:    pub fn get_required_cross_domain_capabilities(&self, effect_type: &str) -> Vec<CrossDomainCapability> {
crates/causality-effects/src/capability/unified.rs:    pub fn to_string(&self) -> String {
crates/causality-effects/src/capability/unified.rs:    pub fn from_string(s: &str) -> Option<Self> {
crates/causality-effects/src/capability/unified.rs:    pub fn new() -> Self {
crates/causality-effects/src/capability/unified.rs:    pub fn from_effect_context(context: &EffectContext) -> Self {
crates/causality-effects/src/capability/unified.rs:    pub fn add_domain_capability(&mut self, domain_id: impl Into<String>, capability: DomainCapability) {
crates/causality-effects/src/capability/unified.rs:    pub fn add_effect_capability(&mut self, capability: EffectCapability) {
crates/causality-effects/src/capability/unified.rs:    pub fn add_cross_domain_capability(&mut self, capability: CrossDomainCapability) {
crates/causality-effects/src/capability/unified.rs:    pub fn has_domain_capability(&self, domain_id: &str, capability: &DomainCapability) -> bool {
crates/causality-effects/src/capability/unified.rs:    pub fn has_effect_capability(&self, capability: &EffectCapability) -> bool {
crates/causality-effects/src/capability/unified.rs:    pub fn has_cross_domain_capability(&self, capability: &CrossDomainCapability) -> bool {
crates/causality-effects/src/capability/unified.rs:    pub fn to_capability_strings(&self) -> Vec<String> {
crates/causality-effects/src/capability/unified.rs:    pub fn to_effect_context(&self, identity: String) -> EffectContext {
crates/causality-effects/src/capability/unified.rs:    pub fn new(domain_manager: Arc<DomainCapabilityManager>) -> Self {
crates/causality-effects/src/capability/unified.rs:    pub fn register_effect_capabilities(&self, identity: &str, capabilities: HashSet<EffectCapability>) -> Result<()> {
crates/causality-effects/src/capability/unified.rs:    pub fn register_cross_domain_capabilities(&self, identity: &str, capabilities: HashSet<CrossDomainCapability>) -> Result<()> {
crates/causality-effects/src/capability/unified.rs:    pub fn get_effect_capabilities(&self, identity: &str) -> Option<HashSet<EffectCapability>> {
crates/causality-effects/src/capability/unified.rs:    pub fn get_cross_domain_capabilities(&self, identity: &str) -> Option<HashSet<CrossDomainCapability>> {
crates/causality-effects/src/capability/unified.rs:    pub fn has_effect_capability(&self, identity: &str, capability: &EffectCapability) -> bool {
crates/causality-effects/src/capability/unified.rs:    pub fn has_cross_domain_capability(&self, identity: &str, capability: &CrossDomainCapability) -> bool {
crates/causality-effects/src/capability/unified.rs:    pub fn create_context(&self, identity: &str) -> Result<UnifiedCapabilityContext> {
crates/causality-effects/src/capability/unified.rs:    pub fn map_domain_to_effect_capability(&self, domain_cap: &DomainCapability) -> Option<EffectCapability> {
crates/causality-effects/src/capability/unified.rs:    pub fn map_effect_to_domain_capability(&self, effect_cap: &EffectCapability) -> Option<DomainCapability> {
crates/causality-effects/src/capability/unified.rs:    pub fn effect_requires_domain_capability(&self, effect_type: &EffectType, domain_id: &str) -> Option<DomainCapability> {
crates/causality-effects/src/empty_effect.rs:    pub fn new() -> Self {
crates/causality-effects/src/empty_effect.rs:    pub fn with_description(description: String) -> Self {
crates/causality-effects/src/boundary.rs:    pub fn new(boundary: ExecutionBoundary) -> Self {
crates/causality-effects/src/boundary.rs:    pub fn new_inside(invoker: Address) -> Self {
crates/causality-effects/src/boundary.rs:    pub fn new_outside(invoker: Address) -> Self {
crates/causality-effects/src/boundary.rs:    pub fn with_chain(mut self, chain: ChainBoundary) -> Self {
crates/causality-effects/src/boundary.rs:    pub fn with_capability(mut self, capability: CapabilityRef) -> Self {
crates/causality-effects/src/boundary.rs:    pub fn with_capabilities(mut self, capabilities: Vec<CapabilityRef>) -> Self {
crates/causality-effects/src/boundary.rs:    pub fn with_parameter(mut self, key: &str, value: &str) -> Self {
crates/causality-effects/src/boundary.rs:    pub fn new_outbound(context: EffectContext, payload: T) -> Self {
crates/causality-effects/src/boundary.rs:    pub fn new_inbound(context: EffectContext, payload: T) -> Self {
crates/causality-effects/src/boundary.rs:    pub fn with_auth(mut self, auth: BoundaryAuthentication) -> Self {
crates/causality-effects/src/boundary.rs:    pub fn serialize(&self) -> Result<Vec<u8>, serde_json::Error> {
crates/causality-effects/src/boundary.rs:    pub fn deserialize(data: &[u8]) -> Result<Self, serde_json::Error> {
crates/causality-effects/src/boundary.rs:    pub fn new() -> Self {
crates/causality-effects/src/boundary.rs:    pub fn record<T>(&mut self, crossing: &BoundaryCrossing<T>, direction: CrossingDirection, success: bool, error: Option<String>) 
crates/causality-effects/src/boundary.rs:    pub fn get(&self, id: &ContentId) -> Option<&BoundaryCrossingRecord> {
crates/causality-effects/src/boundary.rs:    pub fn get_all(&self) -> Vec<&BoundaryCrossingRecord> {
crates/causality-effects/src/boundary.rs:    pub fn get_by_direction(&self, direction: CrossingDirection) -> Vec<&BoundaryCrossingRecord> {
crates/causality-effects/src/boundary.rs:    pub fn get_by_invoker(&self, invoker: &Address) -> Vec<&BoundaryCrossingRecord> {
crates/causality-effects/src/effect.rs:    pub fn new(effect_type: EffectType) -> Self {
crates/causality-effects/src/effect.rs:    pub fn with_resource(effect_type: EffectType, resource_id: ContentId) -> Self {
crates/causality-effects/src/effect.rs:    pub fn effect_type(&self) -> &EffectType {
crates/causality-effects/src/effect.rs:    pub fn set_parameter(&mut self, key: impl Into<String>, value: impl Into<Vec<u8>>) {
crates/causality-effects/src/effect.rs:    pub fn get_parameter(&self, key: &str) -> Option<&[u8]> {
crates/causality-effects/src/effect.rs:    pub fn set_resource_id(&mut self, resource_id: ContentId) {
crates/causality-effects/src/effect.rs:    pub fn resource_id(&self) -> Option<&ContentId> {
crates/causality-effects/src/effect.rs:    pub fn success() -> Self {
crates/causality-effects/src/effect.rs:    pub fn with_result(result: Vec<u8>) -> Self {
crates/causality-effects/src/effect.rs:    pub fn failure(error: impl Into<String>) -> Self {
crates/causality-effects/src/effect.rs:    pub fn is_success(&self) -> bool {
crates/causality-effects/src/effect.rs:    pub fn result(&self) -> Option<&[u8]> {
crates/causality-effects/src/effect.rs:    pub fn error(&self) -> Option<&str> {
crates/causality-effects/src/effect.rs:    pub fn new() -> Self {
crates/causality-effects/src/effect.rs:    pub fn register(&mut self, effect: Effect) -> ContentId {
crates/causality-effects/src/effect.rs:    pub fn get(&self, content_id: &ContentId) -> Option<&Effect> {
crates/causality-effects/src/effect.rs:    pub fn remove(&mut self, content_id: &ContentId) -> Option<Effect> {
crates/causality-effects/src/effect.rs:    pub fn contains(&self, content_id: &ContentId) -> bool {
crates/causality-effects/src/effect.rs:    pub fn len(&self) -> usize {
crates/causality-effects/src/effect.rs:    pub fn is_empty(&self) -> bool {
crates/causality-effects/src/effect.rs:    pub fn iter(&self) -> impl Iterator<Item = (&ContentId, &Effect)> {
crates/causality-effects/src/executor.rs:    pub fn as_bool(&self) -> Option<bool> {
crates/causality-effects/src/executor.rs:    pub fn as_int(&self) -> Option<i64> {
crates/causality-effects/src/executor.rs:    pub fn as_float(&self) -> Option<f64> {
crates/causality-effects/src/executor.rs:    pub fn as_string(&self) -> Option<&str> {
crates/causality-effects/src/executor.rs:    pub fn as_bytes(&self) -> Option<&[u8]> {
crates/causality-effects/src/executor.rs:    pub fn as_array(&self) -> Option<&[Value]> {
crates/causality-effects/src/executor.rs:    pub fn as_map(&self) -> Option<&HashMap<String, Value>> {
crates/causality-effects/src/executor.rs:    pub fn is_null(&self) -> bool {
crates/causality-effects/src/executor.rs:    pub fn new() -> Self {
crates/causality-effects/src/executor.rs:    pub fn from_string(id: &str) -> Self {
crates/causality-effects/src/executor.rs:    pub fn with_creator(creator: &str) -> Self {
crates/causality-effects/src/executor.rs:    pub fn new() -> Self {
crates/causality-effects/src/executor.rs:    pub fn with_limits(max_execution_time: Duration, max_memory: u64) -> Self {
crates/causality-effects/src/executor.rs:    pub fn new(security: Arc<dyn SecuritySandbox>) -> Self {
crates/causality-effects/src/executor.rs:    pub fn set_event_listener<F>(&mut self, listener: F)
crates/causality-effects/src/executor.rs:    pub fn emit_event(&self, event: ExecutionEvent) {
crates/causality-effects/src/executor.rs:    pub fn get_variable(&self, name: &str) -> Option<&Value> {
crates/causality-effects/src/executor.rs:    pub fn set_variable(&mut self, name: &str, value: Value) {
crates/causality-effects/src/executor.rs:    pub fn push_call(&mut self, code_hash: ContentHash, name: Option<String>, args: Vec<Value>) {
crates/causality-effects/src/executor.rs:    pub fn pop_call(&mut self, result: Value) -> Duration {
crates/causality-effects/src/executor.rs:    pub fn check_timeout(&self) -> Result<()> {
crates/causality-effects/src/executor.rs:    pub fn check_operation(&self, operation: &str, args: &[Value]) -> Result<()> {
crates/causality-effects/src/executor.rs:    pub fn check_resource_access(&self, resource_id: &ContentId, access_type: &str) -> Result<()> {
crates/causality-effects/src/executor.rs:    pub fn new(repository: Arc<R>, security: Arc<dyn SecuritySandbox>) -> Self {
crates/causality-effects/src/domain_effect.rs:    pub fn new(domain_id: DomainId) -> Self {
crates/causality-effects/src/domain_effect.rs:    pub fn from_effect_context(domain_id: DomainId, context: &EffectContext) -> Self {
crates/causality-effects/src/domain_effect.rs:    pub fn with_caller(mut self, caller: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect.rs:    pub fn with_auth_token(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect.rs:    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect.rs:    pub fn new(domain_id: DomainId, query: FactQuery) -> Self {
crates/causality-effects/src/domain_effect.rs:    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect.rs:    pub fn query(&self) -> &FactQuery {
crates/causality-effects/src/domain_effect.rs:    pub fn new(domain_id: DomainId, transaction: Transaction) -> Self {
crates/causality-effects/src/domain_effect.rs:    pub fn with_confirmation(mut self, wait: bool) -> Self {
crates/causality-effects/src/domain_effect.rs:    pub fn with_max_wait(mut self, max_wait_ms: u64) -> Self {
crates/causality-effects/src/domain_effect.rs:    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect.rs:    pub fn transaction(&self) -> &Transaction {
crates/causality-effects/src/domain_effect.rs:    pub fn new(domain_id: DomainId) -> Self {
crates/causality-effects/src/domain_effect.rs:    pub fn with_height(mut self, height: BlockHeight) -> Self {
crates/causality-effects/src/domain_effect.rs:    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect.rs:    pub fn new(domain_id: DomainId, capability: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect.rs:    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect.rs:    pub fn capability(&self) -> &str {
crates/causality-effects/src/domain_effect.rs:pub fn query_domain_fact(domain_id: DomainId, fact_type: impl Into<String>) -> DomainQueryEffect {
crates/causality-effects/src/domain_effect.rs:pub fn submit_domain_transaction(domain_id: DomainId, tx_type: impl Into<String>) -> DomainTransactionEffect {
crates/causality-effects/src/domain_effect.rs:pub fn get_domain_time_map(domain_id: DomainId) -> DomainTimeMapEffect {
crates/causality-effects/src/domain_effect.rs:pub fn check_domain_capability(domain_id: DomainId, capability: impl Into<String>) -> DomainCapabilityEffect {
crates/causality-effects/src/repository.rs:    pub fn new() -> Self {
crates/causality-effects/src/repository.rs:    pub fn with_tag(mut self, tag: &str) -> Self {
crates/causality-effects/src/repository.rs:    pub fn with_version(mut self, version: &str) -> Self {
crates/causality-effects/src/repository.rs:    pub fn with_property(mut self, key: &str, value: serde_json::Value) -> Self {
crates/causality-effects/src/repository.rs:    pub fn new() -> Self {
crates/causality-effects/src/repository.rs:    pub fn new<P: AsRef<Path>>(base_path: P) -> Result<Self> {
crates/causality-effects/src/templates/relationship_validation.rs:    pub fn new(
crates/causality-effects/src/templates/relationship_validation.rs:    pub fn wrap(
crates/causality-effects/src/templates/state_transition.rs:    pub fn new(
crates/causality-effects/src/templates/state_transition.rs:    pub fn get_lifecycle_manager(&self) -> Option<&Arc<ResourceRegisterLifecycleManager>> {
crates/causality-effects/src/templates/state_transition.rs:    pub fn set_lifecycle_manager(&mut self, lifecycle_manager: Arc<ResourceRegisterLifecycleManager>) {
crates/causality-effects/src/storage.rs:    pub fn new(
crates/causality-effects/src/storage.rs:    pub fn from_resource_id(
crates/causality-effects/src/storage.rs:    pub fn new(
crates/causality-effects/src/storage.rs:    pub fn from_resource_id(
crates/causality-effects/src/storage.rs:    pub fn new(
crates/causality-effects/src/storage.rs:    pub fn from_resource_id(
crates/causality-effects/src/storage.rs:    pub fn new(
crates/causality-effects/src/storage.rs:    pub fn from_resource_id(
crates/causality-effects/src/storage.rs:    pub fn new(
crates/causality-effects/src/storage.rs:pub fn create_store_on_chain_effect(
crates/causality-effects/src/storage.rs:pub fn create_read_from_chain_effect(
crates/causality-effects/src/storage.rs:pub fn create_store_commitment_effect(
crates/causality-effects/src/storage.rs:pub fn create_store_nullifier_effect(
crates/causality-effects/src/storage.rs:pub fn create_store_on_chain_effect_from_resource_id(
crates/causality-effects/src/storage.rs:pub fn create_read_from_chain_effect_from_resource_id(
crates/causality-effects/src/storage.rs:pub fn create_domain_specific_store_effect(
crates/causality-effects/src/storage.rs:pub fn create_domain_specific_commitment_effect(
crates/causality-effects/src/storage.rs:pub fn create_cross_domain_transfer_effect(
crates/causality-effects/src/domain_effect/handler.rs:    pub fn new(registry: Arc<EffectDomainRegistry>) -> Self {
crates/causality-effects/src/domain_effect/handler.rs:    pub fn registry(&self) -> &EffectDomainRegistry {
crates/causality-effects/src/domain_effect/handler.rs:pub fn create_domain_handler(registry: Arc<EffectDomainRegistry>) -> DomainEffectHandlerAdapter {
crates/causality-effects/src/domain_effect/handler.rs:pub fn create_domain_handler_with_new_registry() -> (Arc<EffectDomainRegistry>, DomainEffectHandlerAdapter) {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn new_view_call(
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn new_transaction_call(
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn with_gas_limit(self, gas_limit: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn with_gas_price(self, gas_price: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn with_value(self, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn contract_address(&self) -> &str {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn function_name(&self) -> &str {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn args(&self) -> &[String] {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn is_view(&self) -> bool {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn map_outcome(&self, result: DomainResult<String>) -> EffectResult<EffectOutcome> {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn new(domain_id: impl Into<String>, query_type: EvmStateQueryType) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn balance(domain_id: impl Into<String>, address: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn storage(
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn code(domain_id: impl Into<String>, address: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn nonce(domain_id: impl Into<String>, address: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn block(domain_id: impl Into<String>, block_id: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn transaction(domain_id: impl Into<String>, tx_hash: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn receipt(domain_id: impl Into<String>, tx_hash: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn gas_price(domain_id: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn gas_limit(domain_id: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn chain_id(domain_id: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn at_block(self, block_number: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn query_type(&self) -> &EvmStateQueryType {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn map_outcome(&self, result: DomainResult<String>) -> EffectResult<EffectOutcome> {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn new(
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn with_value(self, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn with_from(self, from: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn contract_address(&self) -> &str {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn function_name(&self) -> &str {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn args(&self) -> &[String] {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/evm_effects.rs:    pub fn map_outcome(&self, result: DomainResult<u64>) -> EffectResult<EffectOutcome> {
crates/causality-effects/src/domain_effect/evm_effects.rs:pub fn evm_view_call(
crates/causality-effects/src/domain_effect/evm_effects.rs:pub fn evm_transaction_call(
crates/causality-effects/src/domain_effect/evm_effects.rs:pub fn evm_balance(domain_id: impl Into<String>, address: impl Into<String>) -> EvmStateQueryEffect {
crates/causality-effects/src/domain_effect/evm_effects.rs:pub fn evm_storage(
crates/causality-effects/src/domain_effect/evm_effects.rs:pub fn evm_code(domain_id: impl Into<String>, address: impl Into<String>) -> EvmStateQueryEffect {
crates/causality-effects/src/domain_effect/evm_effects.rs:pub fn evm_transaction(domain_id: impl Into<String>, tx_hash: impl Into<String>) -> EvmStateQueryEffect {
crates/causality-effects/src/domain_effect/evm_effects.rs:pub fn evm_block(domain_id: impl Into<String>, block_id: impl Into<String>) -> EvmStateQueryEffect {
crates/causality-effects/src/domain_effect/evm_effects.rs:pub fn evm_estimate_gas(
crates/causality-effects/src/domain_effect/domain_registry.rs:    pub fn new() -> Self {
crates/causality-effects/src/domain_effect/domain_registry.rs:    pub fn new(inner_factory: F) -> Self {
crates/causality-effects/src/domain_effect/domain_registry.rs:pub fn create_domain_registry() -> EffectDomainRegistry {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn new(
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn with_funds(mut self, denom: impl Into<String>, amount: u128) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn with_sender(self, sender: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn with_gas_limit(self, gas_limit: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn with_fee(self, fee_amount: impl Into<String>, fee_denom: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn contract_address(&self) -> &str {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn msg(&self) -> &str {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn funds(&self) -> Option<&Vec<(String, u128)>> {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn map_outcome(&self, result: DomainResult<String>) -> EffectResult<EffectOutcome> {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn new(
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn at_height(self, height: u64) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn contract_address(&self) -> &str {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn query(&self) -> &str {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn map_outcome(&self, result: DomainResult<String>) -> EffectResult<EffectOutcome> {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn new(
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn with_funds(mut self, denom: impl Into<String>, amount: u128) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn with_sender(self, sender: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn with_admin(self, admin: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn with_gas_limit(self, gas_limit: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn with_fee(self, fee_amount: impl Into<String>, fee_denom: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn code_id(&self) -> u64 {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn msg(&self) -> &str {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn label(&self) -> &str {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn funds(&self) -> Option<&Vec<(String, u128)>> {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn map_outcome(&self, result: DomainResult<(String, String)>) -> EffectResult<EffectOutcome> {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn new(
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn with_sender(self, sender: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn with_gas_limit(self, gas_limit: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn with_fee(self, fee_amount: impl Into<String>, fee_denom: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn wasm_bytecode(&self) -> &str {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:    pub fn map_outcome(&self, result: DomainResult<(String, u64)>) -> EffectResult<EffectOutcome> {
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:pub fn cosmwasm_execute(
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:pub fn cosmwasm_query(
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:pub fn cosmwasm_instantiate(
crates/causality-effects/src/domain_effect/cosmwasm_effects.rs:pub fn cosmwasm_upload(
crates/causality-effects/src/domain_effect/domain_selection.rs:    pub fn new(criteria: SelectionCriteria) -> Self {
crates/causality-effects/src/domain_effect/domain_selection.rs:    pub fn with_limit(mut self, limit: usize) -> Self {
crates/causality-effects/src/domain_effect/domain_selection.rs:    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/domain_selection.rs:    pub fn criteria(&self) -> &SelectionCriteria {
crates/causality-effects/src/domain_effect/domain_selection.rs:pub fn select_domains_by_type(domain_type: impl Into<String>) -> DomainSelectionEffect {
crates/causality-effects/src/domain_effect/domain_selection.rs:pub fn select_domains_by_capability(capability: impl Into<String>) -> DomainSelectionEffect {
crates/causality-effects/src/domain_effect/domain_selection.rs:pub fn select_domains_by_type_and_capability(
crates/causality-effects/src/domain_effect/domain_selection.rs:pub fn select_domains_by_name(pattern: impl Into<String>) -> DomainSelectionEffect {
crates/causality-effects/src/domain_effect/domain_selection.rs:pub fn select_domains_custom(criteria: impl Into<String>) -> DomainSelectionEffect {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn new(
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn with_public_input(mut self, input: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn with_public_inputs(mut self, inputs: Vec<impl Into<String>>) -> Self {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn circuit_id(&self) -> &str {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn private_inputs(&self) -> &str {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn public_inputs(&self) -> &[String] {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn map_outcome(&self, result: DomainResult<String>) -> EffectResult<EffectOutcome> {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn new(
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn with_public_input(mut self, input: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn with_public_inputs(mut self, inputs: Vec<impl Into<String>>) -> Self {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn verification_key_id(&self) -> &str {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn proof(&self) -> &str {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn public_inputs(&self) -> &[String] {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn map_outcome(&self, result: DomainResult<bool>) -> EffectResult<EffectOutcome> {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn new(
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn circuit_id(&self) -> &str {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn witness_data(&self) -> &str {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn map_outcome(&self, result: DomainResult<String>) -> EffectResult<EffectOutcome> {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn new(
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn with_source_proof_hash(mut self, hash: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn with_source_proof_hashes(mut self, hashes: Vec<impl Into<String>>) -> Self {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn with_parameter(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn domain_id(&self) -> &DomainId {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn composition_circuit_id(&self) -> &str {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn source_proof_hashes(&self) -> &[String] {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn create_domain_context<'a>(&self, context: &'a EffectContext) -> DomainContext<'a> {
crates/causality-effects/src/domain_effect/zk_effects.rs:    pub fn map_outcome(&self, result: DomainResult<String>) -> EffectResult<EffectOutcome> {
crates/causality-effects/src/domain_effect/zk_effects.rs:pub fn zk_prove(
crates/causality-effects/src/domain_effect/zk_effects.rs:pub fn zk_verify(
crates/causality-effects/src/domain_effect/zk_effects.rs:pub fn zk_witness(
crates/causality-effects/src/domain_effect/zk_effects.rs:pub fn zk_compose(
crates/causality-effects/src/resource/access.rs:    pub fn new(
crates/causality-effects/src/resource/access.rs:    pub fn with_domain(
crates/causality-effects/src/resource/access.rs:    pub fn grant(&mut self) {
crates/causality-effects/src/resource/access.rs:    pub fn new() -> Self {
crates/causality-effects/src/resource/access.rs:    pub fn record_access(&self, access: ResourceAccess) -> Result<()> {
crates/causality-effects/src/resource/access.rs:    pub fn is_resource_locked(&self, resource_id: &ContentId) -> bool {
crates/causality-effects/src/resource/access.rs:    pub fn get_resource_lock(&self, resource_id: &ContentId) -> Option<ResourceAccess> {
crates/causality-effects/src/resource/access.rs:    pub fn release_lock(&self, resource_id: &ContentId, effect_id: &EffectId) -> Result<()> {
crates/causality-effects/src/resource/access.rs:    pub fn get_resource_accesses(&self, resource_id: &ContentId) -> Vec<ResourceAccess> {
crates/causality-effects/src/resource/access.rs:    pub fn get_effect_accesses(&self, effect_id: &EffectId) -> Vec<ResourceAccess> {
crates/causality-effects/src/resource/access.rs:    pub fn get_domain_accesses(&self, domain_id: &DomainId) -> Vec<ResourceAccess> {
crates/causality-effects/src/resource/access.rs:    pub fn new() -> Self {
crates/causality-effects/src/resource/access.rs:    pub fn tracker(&self) -> Arc<ResourceAccessTracker> {
crates/causality-effects/src/resource/access.rs:    pub fn release_access(
crates/causality-effects/src/resource/access.rs:    pub fn is_resource_in_use(&self, resource_id: &ContentId) -> bool {
crates/causality-effects/src/resource/access.rs:    pub fn get_effects_using_resource(&self, resource_id: &ContentId) -> HashSet<EffectId> {
crates/causality-effects/src/resource/effects.rs:    pub fn new(
crates/causality-effects/src/resource/effects.rs:    pub fn with_timeout(mut self, timeout: Duration) -> Self {
crates/causality-effects/src/resource/effects.rs:    pub fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/resource/effects.rs:pub fn transfer_resource(
crates/causality-effects/src/resource/effects.rs:    pub fn new(
crates/causality-effects/src/resource/effects.rs:    pub fn with_timeout(mut self, timeout: Duration) -> Self {
crates/causality-effects/src/resource/effects.rs:    pub fn with_transaction(mut self, transaction_id: String) -> Self {
crates/causality-effects/src/resource/effects.rs:pub fn lock_resource_across_domains(
crates/causality-effects/src/resource/effects.rs:    pub fn new(
crates/causality-effects/src/resource/effects.rs:    pub fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/resource/effects.rs:pub fn add_cross_domain_dependency(
crates/causality-effects/src/resource/dependency.rs:    pub fn new() -> Self {
crates/causality-effects/src/resource/dependency.rs:    pub fn add_dependency(&self, dependency: ResourceDependency) -> Result<()> {
crates/causality-effects/src/resource/dependency.rs:    pub fn get_dependencies_for_source(&self, source: &ContentId) -> HashSet<ResourceDependency> {
crates/causality-effects/src/resource/dependency.rs:    pub fn get_dependencies_for_target(&self, target: &ContentId) -> HashSet<ResourceDependency> {
crates/causality-effects/src/resource/dependency.rs:    pub fn has_dependencies(&self, resource_id: &ContentId) -> bool {
crates/causality-effects/src/resource/dependency.rs:    pub fn remove_dependencies(&self, resource_id: &ContentId) -> Result<()> {
crates/causality-effects/src/resource/implementation.rs:    pub fn new(
crates/causality-effects/src/resource/implementation.rs:    pub fn new_default(effect_registry: Arc<EffectRegistry>) -> Self {
crates/causality-effects/src/resource/implementation.rs:pub fn create_effect_context(
crates/causality-effects/src/resource/examples.rs:pub fn resource_access_example() -> Result<()> {
crates/causality-effects/src/resource/examples.rs:pub fn resource_lifecycle_example() -> Result<()> {
crates/causality-effects/src/resource/examples.rs:pub fn resource_locking_example() -> Result<()> {
crates/causality-effects/src/resource/examples.rs:pub fn resource_dependency_example() -> Result<()> {
crates/causality-effects/src/resource/examples.rs:pub fn integrated_resource_management_example() -> Result<()> {
crates/causality-effects/src/resource/examples.rs:pub fn run_all_examples() -> Result<()> {
crates/causality-effects/src/resource/lifecycle.rs:    pub fn new(
crates/causality-effects/src/resource/lifecycle.rs:    pub fn with_domain(
crates/causality-effects/src/resource/lifecycle.rs:    pub fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
crates/causality-effects/src/resource/lifecycle.rs:    pub fn new(lifecycle: Arc<ResourceLifecycle>) -> Self {
crates/causality-effects/src/resource/lifecycle.rs:    pub fn resource_lifecycle(&self) -> Arc<ResourceLifecycle> {
crates/causality-effects/src/resource/lifecycle.rs:    pub fn register_resource(
crates/causality-effects/src/resource/lifecycle.rs:    pub fn update_resource_state(
crates/causality-effects/src/resource/lifecycle.rs:    pub fn activate_resource(
crates/causality-effects/src/resource/lifecycle.rs:    pub fn lock_resource(
crates/causality-effects/src/resource/lifecycle.rs:    pub fn unlock_resource(
crates/causality-effects/src/resource/lifecycle.rs:    pub fn consume_resource(
crates/causality-effects/src/resource/lifecycle.rs:    pub fn get_resource_state(&self, resource_id: &ContentId) -> Option<RegisterState> {
crates/causality-effects/src/resource/lifecycle.rs:    pub fn can_perform_operation(
crates/causality-effects/src/resource/lifecycle.rs:    pub fn register_event_handler<F>(&self, handler: F)
crates/causality-effects/src/resource/lifecycle.rs:    pub fn get_pending_events(&self) -> Vec<LifecycleEvent> {
crates/causality-effects/src/resource/lifecycle.rs:    pub fn clear_pending_events(&self) {
crates/causality-effects/src/resource/lifecycle.rs:    pub fn new(
crates/causality-effects/src/resource/lifecycle.rs:    pub fn with_domain(mut self, domain_id: DomainId) -> Self {
crates/causality-effects/src/resource/lifecycle.rs:    pub fn with_controller(mut self, controller_id: ContentId) -> Self {
crates/causality-effects/src/resource/lifecycle.rs:    pub fn with_reason(mut self, reason: TransitionReason) -> Self {
crates/causality-effects/src/resource/lifecycle.rs:    pub fn resource_id(&self) -> &ContentId {
crates/causality-effects/src/resource/lifecycle.rs:    pub fn operation(&self) -> ResourceOperation {
crates/causality-effects/src/resource/lifecycle.rs:    pub fn domain_id(&self) -> Option<&DomainId> {
crates/causality-effects/src/resource/lifecycle.rs:    pub fn activate_resource(resource_id: ContentId) -> ResourceLifecycleEffect {
crates/causality-effects/src/resource/lifecycle.rs:    pub fn lock_resource(resource_id: ContentId, locker_id: Option<ContentId>) -> ResourceLifecycleEffect {
crates/causality-effects/src/resource/lifecycle.rs:    pub fn unlock_resource(resource_id: ContentId, unlocker_id: Option<ContentId>) -> ResourceLifecycleEffect {
crates/causality-effects/src/resource/lifecycle.rs:    pub fn consume_resource(resource_id: ContentId) -> ResourceLifecycleEffect {
crates/causality-effects/src/resource/lifecycle.rs:    pub fn archive_resource(resource_id: ContentId) -> ResourceLifecycleEffect {
crates/causality-effects/src/resource/locking.rs:    pub fn new(
crates/causality-effects/src/resource/locking.rs:    pub fn with_domain(
crates/causality-effects/src/resource/locking.rs:    pub fn with_timeout(mut self, timeout: Duration) -> Self {
crates/causality-effects/src/resource/locking.rs:    pub fn with_transaction(mut self, transaction_id: String) -> Self {
crates/causality-effects/src/resource/locking.rs:    pub fn is_expired(&self) -> bool {
crates/causality-effects/src/resource/locking.rs:    pub fn new(access_tracker: Arc<ResourceAccessTracker>) -> Self {
crates/causality-effects/src/resource/locking.rs:    pub fn try_acquire_lock(
crates/causality-effects/src/resource/locking.rs:    pub fn release_lock(
crates/causality-effects/src/resource/locking.rs:    pub fn is_lock_held(
crates/causality-effects/src/resource/locking.rs:    pub fn can_acquire_lock(
crates/causality-effects/src/resource/locking.rs:    pub fn get_locks(&self, resource_id: &ContentId) -> Vec<ResourceLock> {
crates/causality-effects/src/resource/locking.rs:    pub fn get_locks_by_effect(&self, effect_id: &EffectId) -> Vec<ResourceLock> {
crates/causality-effects/src/resource/locking.rs:    pub fn get_locks_by_domain(&self, domain_id: &DomainId) -> Vec<ResourceLock> {
crates/causality-effects/src/resource/locking.rs:    pub fn get_locks_by_transaction(&self, transaction_id: &str) -> Vec<ResourceLock> {
crates/causality-effects/src/resource/locking.rs:    pub fn register_timeout_handler<F>(
crates/causality-effects/src/resource/locking.rs:    pub fn handle_expired_locks(&self) -> Result<usize> {
crates/causality-effects/src/resource/locking.rs:    pub fn new(
crates/causality-effects/src/resource/locking.rs:    pub fn with_domain(mut self, domain_id: DomainId) -> Self {
crates/causality-effects/src/resource/locking.rs:    pub fn with_timeout(mut self, timeout: Duration) -> Self {
crates/causality-effects/src/resource/locking.rs:    pub fn with_transaction(mut self, transaction_id: String) -> Self {
crates/causality-effects/src/resource/locking.rs:    pub fn resource_id(&self) -> &ContentId {
crates/causality-effects/src/resource/locking.rs:    pub fn lock_type(&self) -> CrossDomainLockType {
crates/causality-effects/src/resource/locking.rs:    pub fn domain_id(&self) -> Option<&DomainId> {
crates/causality-effects/src/resource/locking.rs:    pub fn new(resource_id: ContentId) -> Self {
crates/causality-effects/src/resource/locking.rs:    pub fn with_domain(mut self, domain_id: DomainId) -> Self {
crates/causality-effects/src/resource/locking.rs:    pub fn resource_id(&self) -> &ContentId {
crates/causality-effects/src/resource/locking.rs:    pub fn domain_id(&self) -> Option<&DomainId> {
crates/causality-effects/src/resource/capability.rs:    pub fn new(
crates/causality-effects/src/resource/capability.rs:    pub fn clear_cache(&self) {
crates/causality-effects/src/resource/capability.rs:    pub fn clear_cache_for_resource(&self, resource_id: &ContentId) {
crates/causality-effects/src/transfer.rs:    pub fn new(
crates/causality-effects/src/transfer.rs:    pub fn create_transfer(resource_api: Arc<dyn ResourceAPI>, params: TransferParams) -> Arc<dyn Effect> {
crates/causality-effects/src/transfer.rs:pub fn create_transfer_effect(
crates/causality-effects/src/content.rs:    pub fn digest_size(&self) -> usize {
crates/causality-effects/src/content.rs:    pub fn as_str(&self) -> &'static str {
crates/causality-effects/src/content.rs:    pub fn new(algorithm: HashAlgorithm, bytes: Vec<u8>) -> Self {
crates/causality-effects/src/content.rs:    pub fn blake3(data: &[u8]) -> Self {
crates/causality-effects/src/content.rs:    pub fn from_string(s: &str) -> Self {
crates/causality-effects/src/content.rs:    pub fn to_hex(&self) -> String {
crates/causality-effects/src/content.rs:    pub fn is_empty(&self) -> bool {
crates/causality-effects/src/content.rs:    pub fn builder() -> CodeDefinitionBuilder {
crates/causality-effects/src/content.rs:    pub fn new() -> Self {
crates/causality-effects/src/content.rs:    pub fn name(mut self, name: &str) -> Self {
crates/causality-effects/src/content.rs:    pub fn content(mut self, content: CodeContent) -> Self {
crates/causality-effects/src/content.rs:    pub fn dependency(mut self, hash: ContentHash) -> Self {
crates/causality-effects/src/content.rs:    pub fn dependencies(mut self, hashes: Vec<ContentHash>) -> Self {
crates/causality-effects/src/content.rs:    pub fn metadata(mut self, key: &str, value: serde_json::Value) -> Self {
crates/causality-effects/src/content.rs:    pub fn build(self) -> Result<CodeDefinition, String> {
